/* automatically generated by rust-bindgen 0.72.1 */
/* Pre-generated bindings for docs.rs builds (no network access).
   These bindings were generated from SCIP headers and are used
   when building documentation on docs.rs. */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __has_bounds_safety_attributes: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_KERNELKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_13_7: u32 = 130700;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_14_6: u32 = 140600;
pub const __MAC_14_7: u32 = 140700;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __MAC_15_3: u32 = 150300;
pub const __MAC_15_4: u32 = 150400;
pub const __MAC_15_5: u32 = 150500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_17_6: u32 = 170600;
pub const __IPHONE_17_7: u32 = 170700;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __IPHONE_18_3: u32 = 180300;
pub const __IPHONE_18_4: u32 = 180400;
pub const __IPHONE_18_5: u32 = 180500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_10_6: u32 = 100600;
pub const __WATCHOS_10_7: u32 = 100700;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __WATCHOS_11_3: u32 = 110300;
pub const __WATCHOS_11_4: u32 = 110400;
pub const __WATCHOS_11_5: u32 = 110500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_17_6: u32 = 170600;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __TVOS_18_3: u32 = 180300;
pub const __TVOS_18_4: u32 = 180400;
pub const __TVOS_18_5: u32 = 180500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_8_6: u32 = 80600;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __BRIDGEOS_9_3: u32 = 90300;
pub const __BRIDGEOS_9_4: u32 = 90400;
pub const __BRIDGEOS_9_5: u32 = 90500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_23_6: u32 = 230600;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __DRIVERKIT_24_3: u32 = 240300;
pub const __DRIVERKIT_24_4: u32 = 240400;
pub const __DRIVERKIT_24_5: u32 = 240500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_1_3: u32 = 10300;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const __VISIONOS_2_3: u32 = 20300;
pub const __VISIONOS_2_4: u32 = 20400;
pub const __VISIONOS_2_5: u32 = 20500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_13_7: u32 = 130700;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_14_6: u32 = 140600;
pub const MAC_OS_VERSION_14_7: u32 = 140700;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const MAC_OS_VERSION_15_3: u32 = 150300;
pub const MAC_OS_VERSION_15_4: u32 = 150400;
pub const MAC_OS_VERSION_15_5: u32 = 150500;
pub const __AVAILABILITY_VERSIONS_VERSION_HASH: u32 = 93585900;
pub const __AVAILABILITY_VERSIONS_VERSION_STRING: &[u8; 6] = b"Local\0";
pub const __AVAILABILITY_FILE: &[u8; 23] = b"AvailabilityVersions.h\0";
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const USE_CLANG_STDARG: u32 = 0;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const USE_CLANG_LIMITS: u32 = 0;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const SCIP_BUILD_TYPE: &[u8; 8] = b"Release\0";
pub const SCIP_VERSION_MAJOR: u32 = 10;
pub const SCIP_VERSION_MINOR: u32 = 0;
pub const SCIP_VERSION_PATCH: u32 = 0;
pub const SCIP_VERSION_API: u32 = 156;
pub const SCIP_HAVE_VARIADIC_MACROS: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const SCIP_VERSION: u32 = 1000;
pub const SCIP_VERSION_SUB: u32 = 0;
pub const SCIP_SUBVERSION: u32 = 0;
pub const SCIP_APIVERSION: u32 = 156;
pub const SCIP_COPYRIGHT: &[u8; 52] = b"Copyright (c) 2002-2025 Zuse Institute Berlin (ZIB)\0";
pub const SCIP_LONGINT_MAX: u64 = 9223372036854775807;
pub const SCIP_LONGINT_MIN: i64 = -9223372036854775808;
pub const SCIP_LONGINT_FORMAT: &[u8; 4] = b"lld\0";
pub const SCIP_REAL_UNITROUNDOFF: f64 = 0.00000000000000011102230246251565;
pub const SCIP_REAL_FORMAT: &[u8; 3] = b"lf\0";
pub const SCIP_DEFAULT_INFINITY: f64 = 100000000000000000000.0;
pub const SCIP_DEFAULT_EPSILON: f64 = 0.000000001;
pub const SCIP_DEFAULT_SUMEPSILON: f64 = 0.000001;
pub const SCIP_DEFAULT_FEASTOL: f64 = 0.000001;
pub const SCIP_DEFAULT_CHECKFEASTOLFAC: f64 = 1.0;
pub const SCIP_DEFAULT_LPFEASTOLFACTOR: f64 = 1.0;
pub const SCIP_DEFAULT_DUALFEASTOL: f64 = 0.0000001;
pub const SCIP_DEFAULT_BARRIERCONVTOL: f64 = 0.0000000001;
pub const SCIP_DEFAULT_BOUNDSTREPS: f64 = 0.05;
pub const SCIP_DEFAULT_PSEUDOCOSTEPS: f64 = 0.1;
pub const SCIP_DEFAULT_PSEUDOCOSTDELTA: f64 = 0.0001;
pub const SCIP_DEFAULT_RECOMPFAC: f64 = 1000000.0;
pub const SCIP_DEFAULT_HUGEVAL: f64 = 1000000000000000.0;
pub const SCIP_MAXEPSILON: f64 = 0.001;
pub const SCIP_MINEPSILON: f64 = 0.00000000000000000001;
pub const SCIP_INVALID : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const SCIP_MAXSTRLEN: u32 = 1024;
pub const SCIP_SPACECONTROL: &[u8; 7] = b" tnvfr\0";
pub const SCIP_MAXMEMSIZE: u32 = 0;
pub const SCIP_HASHSIZE_PARAMS: u32 = 2048;
pub const SCIP_HASHSIZE_NAMES: u32 = 500;
pub const SCIP_HASHSIZE_CUTPOOLS: u32 = 500;
pub const SCIP_HASHSIZE_CLIQUES: u32 = 500;
pub const SCIP_HASHSIZE_NAMES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CUTPOOLS_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CLIQUES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_VBC: u32 = 500;
pub const SCIP_DEFAULT_MEM_ARRAYGROWFAC: f64 = 1.2;
pub const SCIP_DEFAULT_MEM_ARRAYGROWINIT: u32 = 4;
pub const SCIP_MAXTREEDEPTH: u32 = 1073741822;
pub const SCIP_PROBINGSCORE_PENALTYRATIO: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE: u32 = 2;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const SCIP_PRESOLTIMING_NONE: u32 = 2;
pub const SCIP_PRESOLTIMING_FAST: u32 = 4;
pub const SCIP_PRESOLTIMING_MEDIUM: u32 = 8;
pub const SCIP_PRESOLTIMING_EXHAUSTIVE: u32 = 16;
pub const SCIP_PRESOLTIMING_FINAL: u32 = 32;
pub const SCIP_PRESOLTIMING_ALWAYS: u32 = 28;
pub const SCIP_PRESOLTIMING_MAX: u32 = 60;
pub const SCIP_PROPTIMING_NONE: u32 = 0;
pub const SCIP_PROPTIMING_BEFORELP: u32 = 1;
pub const SCIP_PROPTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_PROPTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_PROPTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_PROPTIMING_ALWAYS: u32 = 15;
pub const SCIP_HEURTIMING_NONE: u32 = 0;
pub const SCIP_HEURTIMING_BEFORENODE: u32 = 1;
pub const SCIP_HEURTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_HEURTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_HEURTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_HEURTIMING_AFTERPSEUDONODE: u32 = 16;
pub const SCIP_HEURTIMING_AFTERLPPLUNGE: u32 = 32;
pub const SCIP_HEURTIMING_AFTERPSEUDOPLUNGE: u32 = 64;
pub const SCIP_HEURTIMING_DURINGPRICINGLOOP: u32 = 128;
pub const SCIP_HEURTIMING_BEFOREPRESOL: u32 = 256;
pub const SCIP_HEURTIMING_DURINGPRESOLLOOP: u32 = 512;
pub const SCIP_HEURTIMING_AFTERPROPLOOP: u32 = 1024;
pub const SCIP_HEURTIMING_AFTERNODE: u32 = 24;
pub const SCIP_HEURTIMING_AFTERPLUNGE: u32 = 96;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const SCIP_EVENTTYPE_FORMAT: &[u8; 4] = b"llx\0";
pub const SCIP_VARTYPE_BINARY_CHAR: u8 = 66u8;
pub const SCIP_VARTYPE_INTEGER_CHAR: u8 = 73u8;
pub const SCIP_VARTYPE_CONTINUOUS_CHAR: u8 = 67u8;
pub const SCIP_DEPRECATED_VARTYPE_IMPLINT_CHAR: u8 = 77u8;
pub const NLOCKTYPES: u32 = 2;
pub const SCIP_DIVETYPE_NONE: u32 = 0;
pub const SCIP_DIVETYPE_INTEGRALITY: u32 = 1;
pub const SCIP_DIVETYPE_SOS1VARIABLE: u32 = 2;
pub const SCIP_HEURDISPCHAR_LNS: u8 = 76u8;
pub const SCIP_HEURDISPCHAR_DIVING: u8 = 100u8;
pub const SCIP_HEURDISPCHAR_ITERATIVE: u8 = 105u8;
pub const SCIP_HEURDISPCHAR_OBJDIVING: u8 = 111u8;
pub const SCIP_HEURDISPCHAR_PROP: u8 = 112u8;
pub const SCIP_HEURDISPCHAR_ROUNDING: u8 = 114u8;
pub const SCIP_HEURDISPCHAR_TRIVIAL: u8 = 116u8;
pub const SCIP_EXPR_MAXINITESTIMATES: u32 = 10;
pub const SCIP_EXPRITER_MAXNACTIVE: u32 = 5;
pub const SCIP_EXPRITER_ENTEREXPR: u32 = 1;
pub const SCIP_EXPRITER_VISITINGCHILD: u32 = 2;
pub const SCIP_EXPRITER_VISITEDCHILD: u32 = 4;
pub const SCIP_EXPRITER_LEAVEEXPR: u32 = 8;
pub const SCIP_EXPRITER_ALLSTAGES: u32 = 15;
pub const SCIP_EXPRPRINT_EXPRSTRING: u32 = 1;
pub const SCIP_EXPRPRINT_EXPRHDLR: u32 = 2;
pub const SCIP_EXPRPRINT_NUSES: u32 = 4;
pub const SCIP_EXPRPRINT_EVALVALUE: u32 = 8;
pub const SCIP_EXPRPRINT_EVALTAG: u32 = 24;
pub const SCIP_EXPRPRINT_ACTIVITY: u32 = 32;
pub const SCIP_EXPRPRINT_ACTIVITYTAG: u32 = 96;
pub const SCIP_EXPRPRINT_OWNER: u32 = 128;
pub const SCIP_EXPRPRINT_ALL: u32 = 255;
pub const SCIP_NLPPARAM_DEFAULT_VERBLEVEL: u32 = 0;
pub const SCIP_DECOMP_LINKVAR: i32 = -1;
pub const SCIP_DECOMP_LINKCONS: i32 = -2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const QUAD_EPSILON: f64 = 0.000000000001;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SCIP_NLHDLR_METHOD_NONE: u32 = 0;
pub const SCIP_NLHDLR_METHOD_SEPABELOW: u32 = 1;
pub const SCIP_NLHDLR_METHOD_SEPAABOVE: u32 = 2;
pub const SCIP_NLHDLR_METHOD_SEPABOTH: u32 = 3;
pub const SCIP_NLHDLR_METHOD_ACTIVITY: u32 = 4;
pub const SCIP_NLHDLR_METHOD_ALL: u32 = 7;
pub const SCIP_MAXVERTEXPOLYDIM: u32 = 14;
pub const SYM_TIMING_BEFOREPRESOL: u32 = 0;
pub const SYM_TIMING_DURINGPRESOL: u32 = 1;
pub const SYM_TIMING_AFTERPRESOL: u32 = 2;
pub const SYM_COMPUTETIMING_BEFOREPRESOL: u32 = 0;
pub const SYM_COMPUTETIMING_DURINGPRESOL: u32 = 1;
pub const SYM_COMPUTETIMING_AFTERPRESOL: u32 = 2;
pub const ARTIFICIALVARNAMEPREFIX: &[u8; 14] = b"andresultant_\0";
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
unsafe extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::std::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::std::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::std::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::std::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::std::mem::size_of::<__sFILE>() - 152usize];
    ["Alignment of __sFILE"][::std::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::std::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::std::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::std::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::std::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::std::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::std::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::std::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_cookie"][::std::mem::offset_of!(__sFILE, _cookie) - 48usize];
    ["Offset of field: __sFILE::_close"][::std::mem::offset_of!(__sFILE, _close) - 56usize];
    ["Offset of field: __sFILE::_read"][::std::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_seek"][::std::mem::offset_of!(__sFILE, _seek) - 72usize];
    ["Offset of field: __sFILE::_write"][::std::mem::offset_of!(__sFILE, _write) - 80usize];
    ["Offset of field: __sFILE::_ub"][::std::mem::offset_of!(__sFILE, _ub) - 88usize];
    ["Offset of field: __sFILE::_extra"][::std::mem::offset_of!(__sFILE, _extra) - 104usize];
    ["Offset of field: __sFILE::_ur"][::std::mem::offset_of!(__sFILE, _ur) - 112usize];
    ["Offset of field: __sFILE::_ubuf"][::std::mem::offset_of!(__sFILE, _ubuf) - 116usize];
    ["Offset of field: __sFILE::_nbuf"][::std::mem::offset_of!(__sFILE, _nbuf) - 119usize];
    ["Offset of field: __sFILE::_lb"][::std::mem::offset_of!(__sFILE, _lb) - 120usize];
    ["Offset of field: __sFILE::_blksize"][::std::mem::offset_of!(__sFILE, _blksize) - 136usize];
    ["Offset of field: __sFILE::_offset"][::std::mem::offset_of!(__sFILE, _offset) - 144usize];
};
pub type FILE = __sFILE;
unsafe extern "C" {
    pub static mut __stdinp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stderrp: *mut FILE;
}
unsafe extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
        arg2: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
unsafe extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fgetln(arg1: *mut FILE, __len: *mut usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn round(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
unsafe extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabsf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __hypotf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __sqrtf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __ceilf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __floorf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __rintf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __roundf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __truncf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __copysignf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __nextafterf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaxf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fminf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaf16(
        arg1: __BindgenFloat16,
        arg2: __BindgenFloat16,
        arg3: __BindgenFloat16,
    ) -> __BindgenFloat16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __float2"][::std::mem::size_of::<__float2>() - 8usize];
    ["Alignment of __float2"][::std::mem::align_of::<__float2>() - 4usize];
    ["Offset of field: __float2::__sinval"][::std::mem::offset_of!(__float2, __sinval) - 0usize];
    ["Offset of field: __float2::__cosval"][::std::mem::offset_of!(__float2, __cosval) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __double2"][::std::mem::size_of::<__double2>() - 16usize];
    ["Alignment of __double2"][::std::mem::align_of::<__double2>() - 8usize];
    ["Offset of field: __double2::__sinval"][::std::mem::offset_of!(__double2, __sinval) - 0usize];
    ["Offset of field: __double2::__cosval"][::std::mem::offset_of!(__double2, __cosval) - 8usize];
};
unsafe extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of exception"][::std::mem::size_of::<exception>() - 40usize];
    ["Alignment of exception"][::std::mem::align_of::<exception>() - 8usize];
    ["Offset of field: exception::type_"][::std::mem::offset_of!(exception, type_) - 0usize];
    ["Offset of field: exception::name"][::std::mem::offset_of!(exception, name) - 8usize];
    ["Offset of field: exception::arg1"][::std::mem::offset_of!(exception, arg1) - 16usize];
    ["Offset of field: exception::arg2"][::std::mem::offset_of!(exception, arg2) - 24usize];
    ["Offset of field: exception::retval"][::std::mem::offset_of!(exception, retval) - 32usize];
};
unsafe extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state"]
        [::std::mem::size_of::<__darwin_arm_exception_state>() - 12usize];
    ["Alignment of __darwin_arm_exception_state"]
        [::std::mem::align_of::<__darwin_arm_exception_state>() - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __exception) - 0usize];
    ["Offset of field: __darwin_arm_exception_state::__fsr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __fsr) - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __far) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64"]
        [::std::mem::size_of::<__darwin_arm_exception_state64>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64"]
        [::std::mem::align_of::<__darwin_arm_exception_state64>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __esr) - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __exception) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64_v2"]
        [::std::mem::size_of::<__darwin_arm_exception_state64_v2>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64_v2"]
        [::std::mem::align_of::<__darwin_arm_exception_state64_v2>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __esr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state"]
        [::std::mem::size_of::<__darwin_arm_thread_state>() - 68usize];
    ["Alignment of __darwin_arm_thread_state"]
        [::std::mem::align_of::<__darwin_arm_thread_state>() - 4usize];
    ["Offset of field: __darwin_arm_thread_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_thread_state::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __sp) - 52usize];
    ["Offset of field: __darwin_arm_thread_state::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __lr) - 56usize];
    ["Offset of field: __darwin_arm_thread_state::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __pc) - 60usize];
    ["Offset of field: __darwin_arm_thread_state::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __cpsr) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state64"]
        [::std::mem::size_of::<__darwin_arm_thread_state64>() - 272usize];
    ["Alignment of __darwin_arm_thread_state64"]
        [::std::mem::align_of::<__darwin_arm_thread_state64>() - 8usize];
    ["Offset of field: __darwin_arm_thread_state64::__x"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __x) - 0usize];
    ["Offset of field: __darwin_arm_thread_state64::__fp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __fp) - 232usize];
    ["Offset of field: __darwin_arm_thread_state64::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __lr) - 240usize];
    ["Offset of field: __darwin_arm_thread_state64::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __sp) - 248usize];
    ["Offset of field: __darwin_arm_thread_state64::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pc) - 256usize];
    ["Offset of field: __darwin_arm_thread_state64::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __cpsr) - 264usize];
    ["Offset of field: __darwin_arm_thread_state64::__pad"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pad) - 268usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_vfp_state"][::std::mem::size_of::<__darwin_arm_vfp_state>() - 260usize];
    ["Alignment of __darwin_arm_vfp_state"]
        [::std::mem::align_of::<__darwin_arm_vfp_state>() - 4usize];
    ["Offset of field: __darwin_arm_vfp_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_vfp_state::__fpscr"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __fpscr) - 256usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state64"]
        [::std::mem::size_of::<__darwin_arm_neon_state64>() - 528usize];
    ["Alignment of __darwin_arm_neon_state64"]
        [::std::mem::align_of::<__darwin_arm_neon_state64>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state64::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpsr) - 512usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpcr) - 516usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state"]
        [::std::mem::size_of::<__darwin_arm_neon_state>() - 272usize];
    ["Alignment of __darwin_arm_neon_state"]
        [::std::mem::align_of::<__darwin_arm_neon_state>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpsr) - 256usize];
    ["Offset of field: __darwin_arm_neon_state::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpcr) - 260usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_pagein_state"][::std::mem::size_of::<__arm_pagein_state>() - 4usize];
    ["Alignment of __arm_pagein_state"][::std::mem::align_of::<__arm_pagein_state>() - 4usize];
    ["Offset of field: __arm_pagein_state::__pagein_error"]
        [::std::mem::offset_of!(__arm_pagein_state, __pagein_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_state {
    pub __svcr: __uint64_t,
    pub __tpidr2_el0: __uint64_t,
    pub __svl_b: __uint16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_state"][::std::mem::size_of::<__darwin_arm_sme_state>() - 24usize];
    ["Alignment of __darwin_arm_sme_state"]
        [::std::mem::align_of::<__darwin_arm_sme_state>() - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svcr"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svcr) - 0usize];
    ["Offset of field: __darwin_arm_sme_state::__tpidr2_el0"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __tpidr2_el0) - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svl_b"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svl_b) - 16usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_z_state {
    pub __z: [[::std::os::raw::c_char; 256usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_z_state"]
        [::std::mem::size_of::<__darwin_arm_sve_z_state>() - 4096usize];
    ["Alignment of __darwin_arm_sve_z_state"]
        [::std::mem::align_of::<__darwin_arm_sve_z_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_z_state::__z"]
        [::std::mem::offset_of!(__darwin_arm_sve_z_state, __z) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_p_state {
    pub __p: [[::std::os::raw::c_char; 32usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_p_state"]
        [::std::mem::size_of::<__darwin_arm_sve_p_state>() - 512usize];
    ["Alignment of __darwin_arm_sve_p_state"]
        [::std::mem::align_of::<__darwin_arm_sve_p_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_p_state::__p"]
        [::std::mem::offset_of!(__darwin_arm_sve_p_state, __p) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_za_state {
    pub __za: [::std::os::raw::c_char; 4096usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_za_state"]
        [::std::mem::size_of::<__darwin_arm_sme_za_state>() - 4096usize];
    ["Alignment of __darwin_arm_sme_za_state"]
        [::std::mem::align_of::<__darwin_arm_sme_za_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme_za_state::__za"]
        [::std::mem::offset_of!(__darwin_arm_sme_za_state, __za) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme2_state {
    pub __zt0: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme2_state"][::std::mem::size_of::<__darwin_arm_sme2_state>() - 64usize];
    ["Alignment of __darwin_arm_sme2_state"]
        [::std::mem::align_of::<__darwin_arm_sme2_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme2_state::__zt0"]
        [::std::mem::offset_of!(__darwin_arm_sme2_state, __zt0) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_legacy_debug_state"]
        [::std::mem::size_of::<__arm_legacy_debug_state>() - 256usize];
    ["Alignment of __arm_legacy_debug_state"]
        [::std::mem::align_of::<__arm_legacy_debug_state>() - 4usize];
    ["Offset of field: __arm_legacy_debug_state::__bvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bvr) - 0usize];
    ["Offset of field: __arm_legacy_debug_state::__bcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bcr) - 64usize];
    ["Offset of field: __arm_legacy_debug_state::__wvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wvr) - 128usize];
    ["Offset of field: __arm_legacy_debug_state::__wcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wcr) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state32"]
        [::std::mem::size_of::<__darwin_arm_debug_state32>() - 264usize];
    ["Alignment of __darwin_arm_debug_state32"]
        [::std::mem::align_of::<__darwin_arm_debug_state32>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state32::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state32::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bcr) - 64usize];
    ["Offset of field: __darwin_arm_debug_state32::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wvr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state32::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wcr) - 192usize];
    ["Offset of field: __darwin_arm_debug_state32::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __mdscr_el1) - 256usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state64"]
        [::std::mem::size_of::<__darwin_arm_debug_state64>() - 520usize];
    ["Alignment of __darwin_arm_debug_state64"]
        [::std::mem::align_of::<__darwin_arm_debug_state64>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state64::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state64::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bcr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state64::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wvr) - 256usize];
    ["Offset of field: __darwin_arm_debug_state64::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wcr) - 384usize];
    ["Offset of field: __darwin_arm_debug_state64::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __mdscr_el1) - 512usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_cpmu_state64"]
        [::std::mem::size_of::<__darwin_arm_cpmu_state64>() - 128usize];
    ["Alignment of __darwin_arm_cpmu_state64"]
        [::std::mem::align_of::<__darwin_arm_cpmu_state64>() - 8usize];
    ["Offset of field: __darwin_arm_cpmu_state64::__ctrs"]
        [::std::mem::offset_of!(__darwin_arm_cpmu_state64, __ctrs) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext32"][::std::mem::size_of::<__darwin_mcontext32>() - 340usize];
    ["Alignment of __darwin_mcontext32"][::std::mem::align_of::<__darwin_mcontext32>() - 4usize];
    ["Offset of field: __darwin_mcontext32::__es"]
        [::std::mem::offset_of!(__darwin_mcontext32, __es) - 0usize];
    ["Offset of field: __darwin_mcontext32::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext32, __ss) - 12usize];
    ["Offset of field: __darwin_mcontext32::__fs"]
        [::std::mem::offset_of!(__darwin_mcontext32, __fs) - 80usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext64"][::std::mem::size_of::<__darwin_mcontext64>() - 816usize];
    ["Alignment of __darwin_mcontext64"][::std::mem::align_of::<__darwin_mcontext64>() - 16usize];
    ["Offset of field: __darwin_mcontext64::__es"]
        [::std::mem::offset_of!(__darwin_mcontext64, __es) - 0usize];
    ["Offset of field: __darwin_mcontext64::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ss) - 16usize];
    ["Offset of field: __darwin_mcontext64::__ns"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ns) - 288usize];
};
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_sigaltstack"][::std::mem::size_of::<__darwin_sigaltstack>() - 24usize];
    ["Alignment of __darwin_sigaltstack"][::std::mem::align_of::<__darwin_sigaltstack>() - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_sp"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_sp) - 0usize];
    ["Offset of field: __darwin_sigaltstack::ss_size"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_size) - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_flags"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_flags) - 16usize];
};
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_ucontext"][::std::mem::size_of::<__darwin_ucontext>() - 56usize];
    ["Alignment of __darwin_ucontext"][::std::mem::align_of::<__darwin_ucontext>() - 8usize];
    ["Offset of field: __darwin_ucontext::uc_onstack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_onstack) - 0usize];
    ["Offset of field: __darwin_ucontext::uc_sigmask"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_sigmask) - 4usize];
    ["Offset of field: __darwin_ucontext::uc_stack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_stack) - 8usize];
    ["Offset of field: __darwin_ucontext::uc_link"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_link) - 32usize];
    ["Offset of field: __darwin_ucontext::uc_mcsize"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcsize) - 40usize];
    ["Offset of field: __darwin_ucontext::uc_mcontext"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcontext) - 48usize];
};
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::std::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::std::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __siginfo"][::std::mem::size_of::<__siginfo>() - 104usize];
    ["Alignment of __siginfo"][::std::mem::align_of::<__siginfo>() - 8usize];
    ["Offset of field: __siginfo::si_signo"][::std::mem::offset_of!(__siginfo, si_signo) - 0usize];
    ["Offset of field: __siginfo::si_errno"][::std::mem::offset_of!(__siginfo, si_errno) - 4usize];
    ["Offset of field: __siginfo::si_code"][::std::mem::offset_of!(__siginfo, si_code) - 8usize];
    ["Offset of field: __siginfo::si_pid"][::std::mem::offset_of!(__siginfo, si_pid) - 12usize];
    ["Offset of field: __siginfo::si_uid"][::std::mem::offset_of!(__siginfo, si_uid) - 16usize];
    ["Offset of field: __siginfo::si_status"]
        [::std::mem::offset_of!(__siginfo, si_status) - 20usize];
    ["Offset of field: __siginfo::si_addr"][::std::mem::offset_of!(__siginfo, si_addr) - 24usize];
    ["Offset of field: __siginfo::si_value"][::std::mem::offset_of!(__siginfo, si_value) - 32usize];
    ["Offset of field: __siginfo::si_band"][::std::mem::offset_of!(__siginfo, si_band) - 40usize];
    ["Offset of field: __siginfo::__pad"][::std::mem::offset_of!(__siginfo, __pad) - 48usize];
};
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction_u"][::std::mem::size_of::<__sigaction_u>() - 8usize];
    ["Alignment of __sigaction_u"][::std::mem::align_of::<__sigaction_u>() - 8usize];
    ["Offset of field: __sigaction_u::__sa_handler"]
        [::std::mem::offset_of!(__sigaction_u, __sa_handler) - 0usize];
    ["Offset of field: __sigaction_u::__sa_sigaction"]
        [::std::mem::offset_of!(__sigaction_u, __sa_sigaction) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction"][::std::mem::size_of::<__sigaction>() - 24usize];
    ["Alignment of __sigaction"][::std::mem::align_of::<__sigaction>() - 8usize];
    ["Offset of field: __sigaction::__sigaction_u"]
        [::std::mem::offset_of!(__sigaction, __sigaction_u) - 0usize];
    ["Offset of field: __sigaction::sa_tramp"]
        [::std::mem::offset_of!(__sigaction, sa_tramp) - 8usize];
    ["Offset of field: __sigaction::sa_mask"]
        [::std::mem::offset_of!(__sigaction, sa_mask) - 16usize];
    ["Offset of field: __sigaction::sa_flags"]
        [::std::mem::offset_of!(__sigaction, sa_flags) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 16usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_u"]
        [::std::mem::offset_of!(sigaction, __sigaction_u) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"][::std::mem::offset_of!(sigaction, sa_flags) - 12usize];
};
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigvec"][::std::mem::size_of::<sigvec>() - 16usize];
    ["Alignment of sigvec"][::std::mem::align_of::<sigvec>() - 8usize];
    ["Offset of field: sigvec::sv_handler"][::std::mem::offset_of!(sigvec, sv_handler) - 0usize];
    ["Offset of field: sigvec::sv_mask"][::std::mem::offset_of!(sigvec, sv_mask) - 8usize];
    ["Offset of field: sigvec::sv_flags"][::std::mem::offset_of!(sigvec, sv_flags) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage"][::std::mem::size_of::<rusage>() - 144usize];
    ["Alignment of rusage"][::std::mem::align_of::<rusage>() - 8usize];
    ["Offset of field: rusage::ru_utime"][::std::mem::offset_of!(rusage, ru_utime) - 0usize];
    ["Offset of field: rusage::ru_stime"][::std::mem::offset_of!(rusage, ru_stime) - 16usize];
    ["Offset of field: rusage::ru_maxrss"][::std::mem::offset_of!(rusage, ru_maxrss) - 32usize];
    ["Offset of field: rusage::ru_ixrss"][::std::mem::offset_of!(rusage, ru_ixrss) - 40usize];
    ["Offset of field: rusage::ru_idrss"][::std::mem::offset_of!(rusage, ru_idrss) - 48usize];
    ["Offset of field: rusage::ru_isrss"][::std::mem::offset_of!(rusage, ru_isrss) - 56usize];
    ["Offset of field: rusage::ru_minflt"][::std::mem::offset_of!(rusage, ru_minflt) - 64usize];
    ["Offset of field: rusage::ru_majflt"][::std::mem::offset_of!(rusage, ru_majflt) - 72usize];
    ["Offset of field: rusage::ru_nswap"][::std::mem::offset_of!(rusage, ru_nswap) - 80usize];
    ["Offset of field: rusage::ru_inblock"][::std::mem::offset_of!(rusage, ru_inblock) - 88usize];
    ["Offset of field: rusage::ru_oublock"][::std::mem::offset_of!(rusage, ru_oublock) - 96usize];
    ["Offset of field: rusage::ru_msgsnd"][::std::mem::offset_of!(rusage, ru_msgsnd) - 104usize];
    ["Offset of field: rusage::ru_msgrcv"][::std::mem::offset_of!(rusage, ru_msgrcv) - 112usize];
    ["Offset of field: rusage::ru_nsignals"]
        [::std::mem::offset_of!(rusage, ru_nsignals) - 120usize];
    ["Offset of field: rusage::ru_nvcsw"][::std::mem::offset_of!(rusage, ru_nvcsw) - 128usize];
    ["Offset of field: rusage::ru_nivcsw"][::std::mem::offset_of!(rusage, ru_nivcsw) - 136usize];
};
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v0"][::std::mem::size_of::<rusage_info_v0>() - 96usize];
    ["Alignment of rusage_info_v0"][::std::mem::align_of::<rusage_info_v0>() - 8usize];
    ["Offset of field: rusage_info_v0::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v0, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v0::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v0::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v0::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v0::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v0::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v0::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v0::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v0::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v0, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v0::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v0::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_exit_abstime) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v1"][::std::mem::size_of::<rusage_info_v1>() - 144usize];
    ["Alignment of rusage_info_v1"][::std::mem::align_of::<rusage_info_v1>() - 8usize];
    ["Offset of field: rusage_info_v1::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v1, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v1::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v1::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v1::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v1::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v1::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v1::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v1::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v1::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v1, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v1::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v1::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v1::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v1::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v1::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v1::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v1::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v1::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_elapsed_abstime) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v2"][::std::mem::size_of::<rusage_info_v2>() - 160usize];
    ["Alignment of rusage_info_v2"][::std::mem::align_of::<rusage_info_v2>() - 8usize];
    ["Offset of field: rusage_info_v2::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v2, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v2::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v2::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v2::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v2::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v2::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v2::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v2::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v2::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v2, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v2::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v2::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v2::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v2::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v2::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v2::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v2::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v2::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v2::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v2::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_byteswritten) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v3"][::std::mem::size_of::<rusage_info_v3>() - 232usize];
    ["Alignment of rusage_info_v3"][::std::mem::align_of::<rusage_info_v3>() - 8usize];
    ["Offset of field: rusage_info_v3::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v3, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v3::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v3::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v3::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v3::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v3::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v3::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v3::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v3::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v3, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v3::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v3::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v3::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v3::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v3::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v3::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v3::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v3::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v3::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v3::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v3::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v3::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_serviced_system_time) - 224usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v4"][::std::mem::size_of::<rusage_info_v4>() - 296usize];
    ["Alignment of rusage_info_v4"][::std::mem::align_of::<rusage_info_v4>() - 8usize];
    ["Offset of field: rusage_info_v4::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v4, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v4::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v4::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v4::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v4::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v4::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v4::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v4::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v4::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v4::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v4::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v4::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v4::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v4::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v4::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v4::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v4::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v4::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v4::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v4::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v4::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v4::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v4, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v4::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v4::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v4, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v4::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v4::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v4::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v4::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v4::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_runnable_time) - 288usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v5"][::std::mem::size_of::<rusage_info_v5>() - 304usize];
    ["Alignment of rusage_info_v5"][::std::mem::align_of::<rusage_info_v5>() - 8usize];
    ["Offset of field: rusage_info_v5::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v5, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v5::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v5::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v5::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v5::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v5::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v5::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v5::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v5::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v5::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v5::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v5::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v5::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v5::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v5::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v5::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v5::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v5::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v5::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v5::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v5::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v5::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v5, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v5::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v5::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v5, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v5::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v5::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v5::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v5::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v5::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v5::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v5, ri_flags) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v6"][::std::mem::size_of::<rusage_info_v6>() - 464usize];
    ["Alignment of rusage_info_v6"][::std::mem::align_of::<rusage_info_v6>() - 8usize];
    ["Offset of field: rusage_info_v6::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v6, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v6::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v6::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v6::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v6::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v6::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v6::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v6::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v6::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v6::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v6::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v6::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v6::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v6::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v6::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v6::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v6::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v6::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v6::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v6::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v6::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v6::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v6, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v6::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v6::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v6::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v6::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v6::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v6::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v6, ri_flags) - 296usize];
    ["Offset of field: rusage_info_v6::ri_user_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_ptime) - 304usize];
    ["Offset of field: rusage_info_v6::ri_system_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_ptime) - 312usize];
    ["Offset of field: rusage_info_v6::ri_pinstructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pinstructions) - 320usize];
    ["Offset of field: rusage_info_v6::ri_pcycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pcycles) - 328usize];
    ["Offset of field: rusage_info_v6::ri_energy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_energy_nj) - 336usize];
    ["Offset of field: rusage_info_v6::ri_penergy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_penergy_nj) - 344usize];
    ["Offset of field: rusage_info_v6::ri_secure_time_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_time_in_system) - 352usize];
    ["Offset of field: rusage_info_v6::ri_secure_ptime_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_ptime_in_system) - 360usize];
    ["Offset of field: rusage_info_v6::ri_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_neural_footprint) - 368usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_neural_footprint) - 376usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_neural_footprint) - 384usize];
    ["Offset of field: rusage_info_v6::ri_reserved"]
        [::std::mem::offset_of!(rusage_info_v6, ri_reserved) - 392usize];
};
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rlimit"][::std::mem::size_of::<rlimit>() - 16usize];
    ["Alignment of rlimit"][::std::mem::align_of::<rlimit>() - 8usize];
    ["Offset of field: rlimit::rlim_cur"][::std::mem::offset_of!(rlimit, rlim_cur) - 0usize];
    ["Offset of field: rlimit::rlim_max"][::std::mem::offset_of!(rlimit, rlim_max) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proc_rlimit_control_wakeupmon"]
        [::std::mem::size_of::<proc_rlimit_control_wakeupmon>() - 8usize];
    ["Alignment of proc_rlimit_control_wakeupmon"]
        [::std::mem::align_of::<proc_rlimit_control_wakeupmon>() - 4usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_flags"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_flags) - 0usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_rate"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_rate) - 4usize];
};
unsafe extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_1"][::std::mem::size_of::<wait__bindgen_ty_1>() - 4usize];
    ["Alignment of wait__bindgen_ty_1"][::std::mem::align_of::<wait__bindgen_ty_1>() - 4usize];
};
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Termsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Coredump_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Retcode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_2"][::std::mem::size_of::<wait__bindgen_ty_2>() - 4usize];
    ["Alignment of wait__bindgen_ty_2"][::std::mem::align_of::<wait__bindgen_ty_2>() - 4usize];
};
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopval_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait"][::std::mem::size_of::<wait>() - 4usize];
    ["Alignment of wait"][::std::mem::align_of::<wait>() - 4usize];
    ["Offset of field: wait::w_status"][::std::mem::offset_of!(wait, w_status) - 0usize];
    ["Offset of field: wait::w_T"][::std::mem::offset_of!(wait, w_T) - 0usize];
    ["Offset of field: wait::w_S"][::std::mem::offset_of!(wait, w_S) - 0usize];
};
unsafe extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
unsafe extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
unsafe extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
unsafe extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
unsafe extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        __size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
unsafe extern "C" {
    pub fn arc4random() -> u32;
}
unsafe extern "C" {
    pub fn arc4random_addrandom(
        arg1: *mut ::std::os::raw::c_uchar,
        __datlen: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
unsafe extern "C" {
    pub fn arc4random_stir();
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
unsafe extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getloadavg(arg1: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sranddev();
}
unsafe extern "C" {
    pub fn srandomdev();
}
unsafe extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
unsafe extern "C" {
    #[doc = " allocates array and initializes it with 0; returns NULL if memory allocation failed"]
    pub fn BMSallocClearMemory_call(
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSallocMemory_call(
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates array; returns NULL if memory allocation failed"]
    pub fn BMSallocMemoryArray_call(
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " reallocates array; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemoryArray_call(
        ptr: *mut ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " clears a memory element (i.e. fills it with zeros)"]
    pub fn BMSclearMemory_call(ptr: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    #[doc = " copies the contents of one memory element into another memory element"]
    pub fn BMScopyMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: usize,
    );
}
unsafe extern "C" {
    #[doc = " moves the contents of one memory element into another memory element, should be used if both elements overlap,\n  otherwise BMScopyMemory is faster"]
    pub fn BMSmoveMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: usize,
    );
}
unsafe extern "C" {
    #[doc = " allocates memory and copies the contents of the given memory element into the new memory element"]
    pub fn BMSduplicateMemory_call(
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates array and copies the contents of the given source array into the new array"]
    pub fn BMSduplicateMemoryArray_call(
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " frees an allocated memory element and sets pointer to NULL"]
    pub fn BMSfreeMemory_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " frees an allocated memory element if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeMemoryNull_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the size of an allocated memory element"]
    pub fn BMSgetPointerSize_call(ptr: *const ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = " outputs information about currently allocated memory to the screen"]
    pub fn BMSdisplayMemory_call();
}
unsafe extern "C" {
    #[doc = " displays a warning message on the screen, if allocated memory exists"]
    pub fn BMScheckEmptyMemory_call();
}
unsafe extern "C" {
    #[doc = " returns total number of allocated bytes"]
    pub fn BMSgetMemoryUsed_call() -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_ChkMem {
    _unused: [u8; 0],
}
#[doc = " Chunk Memory Management\n\n Efficient memory management for multiple objects of the same size"]
pub type BMS_CHKMEM = BMS_ChkMem;
unsafe extern "C" {
    #[doc = " aligns the given byte size corresponding to the minimal alignment for chunk and block memory"]
    pub fn BMSalignMemsize(size: *mut usize);
}
unsafe extern "C" {
    #[doc = " checks whether the given size meets the alignment conditions for chunk and block memory"]
    pub fn BMSisAligned(size: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a new chunk block data structure"]
    pub fn BMScreateChunkMemory_call(
        size: usize,
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_CHKMEM;
}
unsafe extern "C" {
    #[doc = " clears a chunk block data structure"]
    pub fn BMSclearChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " destroys and frees a chunk block data structure"]
    pub fn BMSdestroyChunkMemory_call(
        chkmem: *mut *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " allocates a memory element of the given chunk block"]
    pub fn BMSallocChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " duplicates a given memory element by allocating a new element of the same chunk block and copying the data"]
    pub fn BMSduplicateChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " frees a memory element of the given chunk block and sets pointer to NULL"]
    pub fn BMSfreeChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " frees a memory element of the given chunk block if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeChunkMemoryNull_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " calls garbage collection of chunk block and frees chunks without allocated memory elements"]
    pub fn BMSgarbagecollectChunkMemory_call(chkmem: *mut BMS_CHKMEM);
}
unsafe extern "C" {
    #[doc = " returns the number of allocated bytes in the chunk block"]
    pub fn BMSgetChunkMemoryUsed_call(chkmem: *const BMS_CHKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BlkMem {
    _unused: [u8; 0],
}
#[doc = " Block Memory Management\n\n Efficient memory management for objects of varying sizes"]
pub type BMS_BLKMEM = BMS_BlkMem;
unsafe extern "C" {
    #[doc = " creates a block memory allocation data structure"]
    pub fn BMScreateBlockMemory_call(
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BLKMEM;
}
unsafe extern "C" {
    #[doc = " frees all chunk blocks in the block memory"]
    pub fn BMSclearBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " clears and deletes block memory"]
    pub fn BMSdestroyBlockMemory_call(
        blkmem: *mut *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " allocates memory in the block memory pool"]
    pub fn BMSallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates memory in the block memory pool and clears it"]
    pub fn BMSallocClearBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates array in the block memory pool"]
    pub fn BMSallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates array in the block memory pool and clears it"]
    pub fn BMSallocClearBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " resizes memory element in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " resizes array in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldnum: usize,
        newnum: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " duplicates memory element in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " duplicates array in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " frees memory element in the block memory pool and sets pointer to NULL"]
    pub fn BMSfreeBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " frees memory element in the block memory pool if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBlockMemoryNull_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " calls garbage collection of block memory, frees chunks without allocated memory elements, and frees\n  chunk blocks without any chunks"]
    pub fn BMSgarbagecollectBlockMemory_call(blkmem: *mut BMS_BLKMEM);
}
unsafe extern "C" {
    #[doc = " returns the number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocated_call(blkmem: *const BMS_BLKMEM)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsed_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnused_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the maximal number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsedMax_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the maximal number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnusedMax_call(blkmem: *const BMS_BLKMEM)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the maximal number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocatedMax_call(
        blkmem: *const BMS_BLKMEM,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the size of the given memory element; returns 0, if the element is not member of the block memory"]
    pub fn BMSgetBlockPointerSize_call(
        blkmem: *const BMS_BLKMEM,
        ptr: *const ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " outputs allocation diagnostics of block memory"]
    pub fn BMSdisplayBlockMemory_call(blkmem: *const BMS_BLKMEM);
}
unsafe extern "C" {
    #[doc = " outputs error messages, if there are allocated elements in the block memory and returns number of unfreed bytes"]
    pub fn BMScheckEmptyBlockMemory_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BufMem {
    _unused: [u8; 0],
}
#[doc = " Buffer Memory Management\n\n Efficient memory management for temporary objects"]
pub type BMS_BUFMEM = BMS_BufMem;
unsafe extern "C" {
    #[doc = " creates memory buffer storage"]
    pub fn BMScreateBufferMemory_call(
        arraygrowfac: f64,
        arraygrowinit: ::std::os::raw::c_int,
        clean: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BUFMEM;
}
unsafe extern "C" {
    #[doc = " destroys buffer memory"]
    pub fn BMSdestroyBufferMemory_call(
        buffer: *mut *mut BMS_BUFMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " set arraygrowfac"]
    pub fn BMSsetBufferMemoryArraygrowfac(buffer: *mut BMS_BUFMEM, arraygrowfac: f64);
}
unsafe extern "C" {
    #[doc = " set arraygrowinit"]
    pub fn BMSsetBufferMemoryArraygrowinit(
        buffer: *mut BMS_BUFMEM,
        arraygrowinit: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " allocates the next unused buffer"]
    pub fn BMSallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates the next unused buffer array"]
    pub fn BMSallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates the next unused buffer and clears it"]
    pub fn BMSallocClearBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " reallocates the buffer to at least the given size"]
    pub fn BMSreallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " reallocates an array in the buffer to at least the given size"]
    pub fn BMSreallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " allocates an array in the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        num: usize,
        typesize: usize,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " frees a buffer and sets pointer to NULL"]
    pub fn BMSfreeBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " frees a buffer if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBufferMemoryNull_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " gets number of used buffers"]
    pub fn BMSgetNUsedBufferMemory(buffer: *mut BMS_BUFMEM) -> usize;
}
unsafe extern "C" {
    #[doc = " returns the number of allocated bytes in the buffer memory"]
    pub fn BMSgetBufferMemoryUsed(buffer: *const BMS_BUFMEM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " outputs statistics about currently allocated buffers to the screen"]
    pub fn BMSprintBufferMemory(buffer: *mut BMS_BUFMEM);
}
#[doc = "< normal termination"]
pub const SCIP_Retcode_SCIP_OKAY: SCIP_Retcode = 1;
#[doc = "< unspecified error"]
pub const SCIP_Retcode_SCIP_ERROR: SCIP_Retcode = 0;
#[doc = "< insufficient memory error"]
pub const SCIP_Retcode_SCIP_NOMEMORY: SCIP_Retcode = -1;
#[doc = "< read error"]
pub const SCIP_Retcode_SCIP_READERROR: SCIP_Retcode = -2;
#[doc = "< write error"]
pub const SCIP_Retcode_SCIP_WRITEERROR: SCIP_Retcode = -3;
#[doc = "< file not found error"]
pub const SCIP_Retcode_SCIP_NOFILE: SCIP_Retcode = -4;
#[doc = "< cannot create file"]
pub const SCIP_Retcode_SCIP_FILECREATEERROR: SCIP_Retcode = -5;
#[doc = "< error in LP solver"]
pub const SCIP_Retcode_SCIP_LPERROR: SCIP_Retcode = -6;
#[doc = "< no problem exists"]
pub const SCIP_Retcode_SCIP_NOPROBLEM: SCIP_Retcode = -7;
#[doc = "< method cannot be called at this time in solution process"]
pub const SCIP_Retcode_SCIP_INVALIDCALL: SCIP_Retcode = -8;
#[doc = "< error in input data"]
pub const SCIP_Retcode_SCIP_INVALIDDATA: SCIP_Retcode = -9;
#[doc = "< method returned an invalid result code"]
pub const SCIP_Retcode_SCIP_INVALIDRESULT: SCIP_Retcode = -10;
#[doc = "< a required plugin was not found"]
pub const SCIP_Retcode_SCIP_PLUGINNOTFOUND: SCIP_Retcode = -11;
#[doc = "< the parameter with the given name was not found"]
pub const SCIP_Retcode_SCIP_PARAMETERUNKNOWN: SCIP_Retcode = -12;
#[doc = "< the parameter is not of the expected type"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGTYPE: SCIP_Retcode = -13;
#[doc = "< the value is invalid for the given parameter"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGVAL: SCIP_Retcode = -14;
#[doc = "< the given key is already existing in table"]
pub const SCIP_Retcode_SCIP_KEYALREADYEXISTING: SCIP_Retcode = -15;
#[doc = "< maximal branching depth level exceeded"]
pub const SCIP_Retcode_SCIP_MAXDEPTHLEVEL: SCIP_Retcode = -16;
#[doc = "< no branching could be created"]
pub const SCIP_Retcode_SCIP_BRANCHERROR: SCIP_Retcode = -17;
#[doc = "< function not implemented"]
pub const SCIP_Retcode_SCIP_NOTIMPLEMENTED: SCIP_Retcode = -18;
#[doc = " return codes for SCIP methods: non-positive return codes are errors"]
pub type SCIP_Retcode = ::std::os::raw::c_int;
#[doc = " return codes for SCIP methods: non-positive return codes are errors"]
pub use self::SCIP_Retcode as SCIP_RETCODE;
#[doc = "< the method was not executed"]
pub const SCIP_Result_SCIP_DIDNOTRUN: SCIP_Result = 1;
#[doc = "< the method was not executed, but should be called again later"]
pub const SCIP_Result_SCIP_DELAYED: SCIP_Result = 2;
#[doc = "< the method was executed, but failed finding anything"]
pub const SCIP_Result_SCIP_DIDNOTFIND: SCIP_Result = 3;
#[doc = "< no infeasibility could be found"]
pub const SCIP_Result_SCIP_FEASIBLE: SCIP_Result = 4;
#[doc = "< an infeasibility was detected"]
pub const SCIP_Result_SCIP_INFEASIBLE: SCIP_Result = 5;
#[doc = "< an unboundedness was detected"]
pub const SCIP_Result_SCIP_UNBOUNDED: SCIP_Result = 6;
#[doc = "< the current node is infeasible and can be cut off"]
pub const SCIP_Result_SCIP_CUTOFF: SCIP_Result = 7;
#[doc = "< the method added a cutting plane"]
pub const SCIP_Result_SCIP_SEPARATED: SCIP_Result = 8;
#[doc = "< the method added a cutting plane and a new separation round should immediately start"]
pub const SCIP_Result_SCIP_NEWROUND: SCIP_Result = 9;
#[doc = "< the method reduced the domain of a variable"]
pub const SCIP_Result_SCIP_REDUCEDDOM: SCIP_Result = 10;
#[doc = "< the method added a constraint"]
pub const SCIP_Result_SCIP_CONSADDED: SCIP_Result = 11;
#[doc = "< the method changed a constraint"]
pub const SCIP_Result_SCIP_CONSCHANGED: SCIP_Result = 12;
#[doc = "< the method created a branching"]
pub const SCIP_Result_SCIP_BRANCHED: SCIP_Result = 13;
#[doc = "< the current node's LP must be solved"]
pub const SCIP_Result_SCIP_SOLVELP: SCIP_Result = 14;
#[doc = "< the method found a feasible primal solution"]
pub const SCIP_Result_SCIP_FOUNDSOL: SCIP_Result = 15;
#[doc = "< the method interrupted its execution, but can continue if needed"]
pub const SCIP_Result_SCIP_SUSPENDED: SCIP_Result = 16;
#[doc = "< the method was successfully executed"]
pub const SCIP_Result_SCIP_SUCCESS: SCIP_Result = 17;
#[doc = "< the processing of the branch-and-bound node should stopped and continued later"]
pub const SCIP_Result_SCIP_DELAYNODE: SCIP_Result = 18;
#[doc = " result codes for SCIP callback methods"]
pub type SCIP_Result = ::std::os::raw::c_uint;
#[doc = " result codes for SCIP callback methods"]
pub use self::SCIP_Result as SCIP_RESULT;
#[doc = "< use default clock type"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_DEFAULT: SCIP_ClockType = 0;
#[doc = "< use CPU clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_CPU: SCIP_ClockType = 1;
#[doc = "< use wall clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_WALL: SCIP_ClockType = 2;
pub type SCIP_ClockType = ::std::os::raw::c_uint;
pub use self::SCIP_ClockType as SCIP_CLOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clock {
    _unused: [u8; 0],
}
pub type SCIP_CLOCK = SCIP_Clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CPUClock {
    _unused: [u8; 0],
}
pub type SCIP_CPUCLOCK = SCIP_CPUClock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_WallClock {
    _unused: [u8; 0],
}
pub type SCIP_WALLCLOCK = SCIP_WallClock;
#[doc = "< one-sided confidence level 75 %, two-sided 50 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MIN: SCIP_Confidencelevel = 0;
#[doc = "< (one-sided) confidence level 87.5 %, two-sided 75 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_LOW: SCIP_Confidencelevel = 1;
#[doc = "< (one-sided) confidence level 90 %, two-sided 80 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MEDIUM: SCIP_Confidencelevel = 2;
#[doc = "< (one-sided) confidence level 95 %, two-sided 90 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_HIGH: SCIP_Confidencelevel = 3;
#[doc = "< (one-sided) confidence level 97.5 %, two-sided 95 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MAX: SCIP_Confidencelevel = 4;
#[doc = " represents different confidence levels for (one-sided) hypothesis testing; in order to obtain two-sided confidence\n  levels, calculate 2 * c - 1, i.e., if the one-sided confidence level is 90 %, the two-sided level is 80 %"]
pub type SCIP_Confidencelevel = ::std::os::raw::c_uint;
#[doc = " represents different confidence levels for (one-sided) hypothesis testing; in order to obtain two-sided confidence\n  levels, calculate 2 * c - 1, i.e., if the one-sided confidence level is 90 %, the two-sided level is 80 %"]
pub use self::SCIP_Confidencelevel as SCIP_CONFIDENCELEVEL;
#[doc = "< the hashmap did not store a single element yet, type unknown"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_UNKNOWN: SCIP_Hashmaptype = 0;
#[doc = "< the hashmap stores pointers %"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_POINTER: SCIP_Hashmaptype = 1;
#[doc = "< the hashmap stores reals"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_REAL: SCIP_Hashmaptype = 2;
#[doc = "< the hashmap stores ints"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_INT: SCIP_Hashmaptype = 3;
#[doc = "< the hashmap stores long ints"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_LONG: SCIP_Hashmaptype = 4;
#[doc = " type of hashmap: are pointers, reals or ints stored, or unknown"]
pub type SCIP_Hashmaptype = ::std::os::raw::c_uint;
#[doc = " type of hashmap: are pointers, reals or ints stored, or unknown"]
pub use self::SCIP_Hashmaptype as SCIP_HASHMAPTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SparseSol {
    _unused: [u8; 0],
}
#[doc = " Sparse solution data structure\n\n  - \\ref SparseSol \"List of all available methods\""]
pub type SCIP_SPARSESOL = SCIP_SparseSol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Queue {
    _unused: [u8; 0],
}
#[doc = " (circular) Queue data structure\n\n  - \\ref Queue \"List of all available methods\""]
pub type SCIP_QUEUE = SCIP_Queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PQueue {
    _unused: [u8; 0],
}
#[doc = " Priority queue data structure\n\n  - \\ref PriorityQueue \"List of all available methods\""]
pub type SCIP_PQUEUE = SCIP_PQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashTable {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure\n\n  - \\ref HashTable \"List of all available methods\""]
pub type SCIP_HASHTABLE = SCIP_HashTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHash {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure which allows multiple occurences of an element\n\n  - \\ref MultiHash \"List of all available methods\""]
pub type SCIP_MULTIHASH = SCIP_MultiHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHashList {
    _unused: [u8; 0],
}
#[doc = " Hash table element list to store single elements of a multi hash table"]
pub type SCIP_MULTIHASHLIST = SCIP_MultiHashList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMapEntry {
    _unused: [u8; 0],
}
#[doc = " Hash map entry"]
pub type SCIP_HASHMAPENTRY = SCIP_HashMapEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMap {
    _unused: [u8; 0],
}
#[doc = " Hash map data structure\n\n  - \\ref HashMap \"List of all available methods\""]
pub type SCIP_HASHMAP = SCIP_HashMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashSet {
    _unused: [u8; 0],
}
#[doc = " Hash set data structure\n\n  - \\ref HashSet \"List of all available methods\""]
pub type SCIP_HASHSET = SCIP_HashSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RealArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Real values"]
pub type SCIP_REALARRAY = SCIP_RealArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IntArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing int values"]
pub type SCIP_INTARRAY = SCIP_IntArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoolArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Bool values"]
pub type SCIP_BOOLARRAY = SCIP_BoolArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PtrArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing pointers"]
pub type SCIP_PTRARRAY = SCIP_PtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RandNumGen {
    _unused: [u8; 0],
}
#[doc = " random number generator"]
pub type SCIP_RANDNUMGEN = SCIP_RandNumGen;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ResourceActivity {
    _unused: [u8; 0],
}
#[doc = " Resource activity data structure\n\n  - \\ref ResourceActivity \"List of all available methods\""]
pub type SCIP_RESOURCEACTIVITY = SCIP_ResourceActivity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Profile {
    _unused: [u8; 0],
}
#[doc = " Resource profile data structure\n\n  - \\ref ResourceProfile \"List of all available methods\""]
pub type SCIP_PROFILE = SCIP_Profile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Digraph {
    _unused: [u8; 0],
}
#[doc = " Directed graph data structure (stored as adjacency list)\n\n  - \\ref DirectedGraph \"List of all available methods\""]
pub type SCIP_DIGRAPH = SCIP_Digraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bt {
    _unused: [u8; 0],
}
#[doc = " Binary tree data structure\n\n  - \\ref BinaryTree \"List of all available methods\""]
pub type SCIP_BT = SCIP_Bt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BtNode {
    _unused: [u8; 0],
}
#[doc = " search node of \\ref SCIP_BT \"binary tree\""]
pub type SCIP_BTNODE = SCIP_BtNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Regression {
    _unused: [u8; 0],
}
#[doc = " regression data structure to compute an incremental linear regression of paired observations\n\n  - \\ref Regression \"List of all available methods\""]
pub type SCIP_REGRESSION = SCIP_Regression;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DisjointSet {
    _unused: [u8; 0],
}
#[doc = " disjoint set (disjoint set (union find)) data structure for querying and updating connectedness of a graph with integer vertices 0,...,n - 1\n\n  - \\ref DisjointSet \"List of available methods\""]
pub type SCIP_DISJOINTSET = SCIP_DisjointSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowPrep {
    _unused: [u8; 0],
}
#[doc = " a linear inequality row in preparation to become a SCIP_ROW\n\n Used to assemble data that could eventually make a SCIP_ROW.\n @note Only one-sided rows are allowed here."]
pub type SCIP_ROWPREP = SCIP_RowPrep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scip {
    _unused: [u8; 0],
}
pub type SCIP = Scip;
pub type SCIP_PRESOLTIMING = ::std::os::raw::c_uint;
pub type SCIP_PROPTIMING = ::std::os::raw::c_uint;
pub type SCIP_HEURTIMING = ::std::os::raw::c_uint;
#[doc = "< bool values: TRUE or FALSE"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_BOOL: SCIP_ParamType = 0;
#[doc = "< integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_INT: SCIP_ParamType = 1;
#[doc = "< long integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_LONGINT: SCIP_ParamType = 2;
#[doc = "< real values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_REAL: SCIP_ParamType = 3;
#[doc = "< characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_CHAR: SCIP_ParamType = 4;
#[doc = "< strings: arrays of characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_STRING: SCIP_ParamType = 5;
#[doc = " possible parameter types"]
pub type SCIP_ParamType = ::std::os::raw::c_uint;
#[doc = " possible parameter types"]
pub use self::SCIP_ParamType as SCIP_PARAMTYPE;
#[doc = "< use default values"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_DEFAULT: SCIP_ParamSetting = 0;
#[doc = "< set to aggressive settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_AGGRESSIVE: SCIP_ParamSetting = 1;
#[doc = "< set to fast settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_FAST: SCIP_ParamSetting = 2;
#[doc = "< turn off"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_OFF: SCIP_ParamSetting = 3;
#[doc = " possible parameter settings - used to determine the behavior of different SCIP components, e.g., heuristics, separators, ..."]
pub type SCIP_ParamSetting = ::std::os::raw::c_uint;
#[doc = " possible parameter settings - used to determine the behavior of different SCIP components, e.g., heuristics, separators, ..."]
pub use self::SCIP_ParamSetting as SCIP_PARAMSETTING;
#[doc = "< use default values"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_DEFAULT: SCIP_ParamEmphasis = 0;
#[doc = "< get CP like search (e.g. no LP relaxation)"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_CPSOLVER: SCIP_ParamEmphasis = 1;
#[doc = "< solve easy problems fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_EASYCIP: SCIP_ParamEmphasis = 2;
#[doc = "< detect feasibility fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_FEASIBILITY: SCIP_ParamEmphasis = 3;
#[doc = "< be capable to handle hard LPs"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_HARDLP: SCIP_ParamEmphasis = 4;
#[doc = "< prove optimality fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_OPTIMALITY: SCIP_ParamEmphasis = 5;
#[doc = "< get a feasible and \"fast\" counting process"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_COUNTER: SCIP_ParamEmphasis = 6;
#[doc = "< feasibility phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEFEAS: SCIP_ParamEmphasis = 7;
#[doc = "< improvement phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEIMPROVE: SCIP_ParamEmphasis = 8;
#[doc = "< proof phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEPROOF: SCIP_ParamEmphasis = 9;
#[doc = "< emphasis parameters for increased numerical safety"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_NUMERICS: SCIP_ParamEmphasis = 10;
#[doc = "< do not try to avoid running into memory limit"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_BENCHMARK: SCIP_ParamEmphasis = 11;
#[doc = " possible parameter emphases - used to determine the general SCIP behavior"]
pub type SCIP_ParamEmphasis = ::std::os::raw::c_uint;
#[doc = " possible parameter emphases - used to determine the general SCIP behavior"]
pub use self::SCIP_ParamEmphasis as SCIP_PARAMEMPHASIS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Param {
    _unused: [u8; 0],
}
pub type SCIP_PARAM = SCIP_Param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamData {
    _unused: [u8; 0],
}
pub type SCIP_PARAMDATA = SCIP_ParamData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamSet {
    _unused: [u8; 0],
}
pub type SCIP_PARAMSET = SCIP_ParamSet;
unsafe extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type SCIP_EVENTTYPE = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Eventhdlr {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLR = SCIP_Eventhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLRDATA = SCIP_EventhdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Event {
    _unused: [u8; 0],
}
pub type SCIP_EVENT = SCIP_Event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarAdded {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARADDED = SCIP_EventVarAdded;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarDeleted {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARDELETED = SCIP_EventVarDeleted;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarFixed {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARFIXED = SCIP_EventVarFixed;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarUnlocked {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARUNLOCKED = SCIP_EventVarUnlocked;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventObjChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTOBJCHG = SCIP_EventObjChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventBdChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTBDCHG = SCIP_EventBdChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventHole {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHOLE = SCIP_EventHole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventImplAdd {
    _unused: [u8; 0],
}
pub type SCIP_EVENTIMPLADD = SCIP_EventImplAdd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventTypeChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTTYPECHG = SCIP_EventTypeChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventImplTypeChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTTYPEIMPLCHG = SCIP_EventImplTypeChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDSEPA = SCIP_EventRowAddedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDSEPA = SCIP_EventRowDeletedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDLP = SCIP_EventRowAddedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDLP = SCIP_EventRowDeletedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowCoefChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCOEFCHANGED = SCIP_EventRowCoefChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowConstChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCONSTCHANGED = SCIP_EventRowConstChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowSideChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWSIDECHANGED = SCIP_EventRowSideChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTDATA = SCIP_EventData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventFilter {
    _unused: [u8; 0],
}
pub type SCIP_EVENTFILTER = SCIP_EventFilter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventQueue {
    _unused: [u8; 0],
}
pub type SCIP_EVENTQUEUE = SCIP_EventQueue;
#[doc = "< LP was not solved, no solution exists"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_NOTSOLVED: SCIP_LPSolStat = 0;
#[doc = "< LP was solved to optimality"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OPTIMAL: SCIP_LPSolStat = 1;
#[doc = "< LP is primal infeasible"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_INFEASIBLE: SCIP_LPSolStat = 2;
#[doc = "< LP has a primal unbounded ray"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_UNBOUNDEDRAY: SCIP_LPSolStat = 3;
#[doc = "< objective limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OBJLIMIT: SCIP_LPSolStat = 4;
#[doc = "< iteration limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ITERLIMIT: SCIP_LPSolStat = 5;
#[doc = "< time limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_TIMELIMIT: SCIP_LPSolStat = 6;
#[doc = "< an error occured during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ERROR: SCIP_LPSolStat = 7;
#[doc = " solution status after solving LP"]
pub type SCIP_LPSolStat = ::std::os::raw::c_uint;
#[doc = " solution status after solving LP"]
pub use self::SCIP_LPSolStat as SCIP_LPSOLSTAT;
#[doc = "< lower bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_LOWER: SCIP_BoundType = 0;
#[doc = "< upper bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_UPPER: SCIP_BoundType = 1;
#[doc = " type of variable bound: lower or upper bound"]
pub type SCIP_BoundType = ::std::os::raw::c_uint;
#[doc = " type of variable bound: lower or upper bound"]
pub use self::SCIP_BoundType as SCIP_BOUNDTYPE;
#[doc = "< left hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_LEFT: SCIP_SideType = 0;
#[doc = "< right hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_RIGHT: SCIP_SideType = 1;
#[doc = " type of row side: left hand or right hand side"]
pub type SCIP_SideType = ::std::os::raw::c_uint;
#[doc = " type of row side: left hand or right hand side"]
pub use self::SCIP_SideType as SCIP_SIDETYPE;
#[doc = "< unspecified origin of row"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_UNSPEC: SCIP_RowOriginType = 0;
#[doc = "< row created by a constraint handler"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONSHDLR: SCIP_RowOriginType = 1;
#[doc = "< row created by a constraint"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONS: SCIP_RowOriginType = 2;
#[doc = "< row created by separator"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_SEPA: SCIP_RowOriginType = 3;
#[doc = "< row created by reoptimization"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_REOPT: SCIP_RowOriginType = 4;
#[doc = " type of origin of row"]
pub type SCIP_RowOriginType = ::std::os::raw::c_uint;
#[doc = " type of origin of row"]
pub use self::SCIP_RowOriginType as SCIP_ROWORIGINTYPE;
#[doc = "< primal simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_PRIMALSIMPLEX: SCIP_LPAlgo = 0;
#[doc = "< dual simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_DUALSIMPLEX: SCIP_LPAlgo = 1;
#[doc = "< barrier algorithm"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIER: SCIP_LPAlgo = 2;
#[doc = "< barrier algorithm with crossover"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIERCROSSOVER: SCIP_LPAlgo = 3;
#[doc = " type of LP algorithm"]
pub type SCIP_LPAlgo = ::std::os::raw::c_uint;
#[doc = " type of LP algorithm"]
pub use self::SCIP_LPAlgo as SCIP_LPALGO;
#[doc = " collected values of a column which depend on the LP solution\n  We store these values in each column to recover the LP solution at start of diving or probing mode, say, without\n  having to resolve the LP.  Note that we do not store the farkascoef value since we do expect a node with infeasible\n  LP to be pruned anyway."]
pub type SCIP_COLSOLVALS = SCIP_ColSolVals;
#[doc = " collected values of a row which depend on the LP solution\n  We store these values in each row to recover the LP solution at start of diving or probing mode, say, without having\n  to resolve the LP.  We do not store the dualfarkas value since we expect a node with infeasible LP to be pruned\n  anyway. In this unlikely case, we have to resolve the LP."]
pub type SCIP_ROWSOLVALS = SCIP_RowSolVals;
#[doc = " collected values of the LP data which depend on the LP solution\n  We store these values to recover the LP solution at start of diving or probing mode, say, without having to resolve\n  the LP."]
pub type SCIP_LPSOLVALS = SCIP_LpSolVals;
#[doc = " column of an LP\n\n  - \\ref PublicColumnMethods \"List of all available methods\""]
pub type SCIP_COL = SCIP_Col;
#[doc = " row of an LP\n\n  - \\ref PublicRowMethods \"List of all available methods\""]
pub type SCIP_ROW = SCIP_Row;
#[doc = " LP structure\n\n  - \\ref PublicLPMethods \"List of all available methods\""]
pub type SCIP_LP = SCIP_Lp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlRow {
    _unused: [u8; 0],
}
pub type SCIP_NLROW = SCIP_NlRow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlp {
    _unused: [u8; 0],
}
pub type SCIP_NLP = SCIP_Nlp;
#[doc = "< variable belongs to original problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_ORIGINAL: SCIP_Varstatus = 0;
#[doc = "< variable is a loose variable of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_LOOSE: SCIP_Varstatus = 1;
#[doc = "< variable is a column of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_COLUMN: SCIP_Varstatus = 2;
#[doc = "< variable is fixed to specific value in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_FIXED: SCIP_Varstatus = 3;
#[doc = "< variable is aggregated to x = a*y + c in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_AGGREGATED: SCIP_Varstatus = 4;
#[doc = "< variable is aggregated to x = a_1*y_1 + ... + a_k*y_k + c"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_MULTAGGR: SCIP_Varstatus = 5;
#[doc = "< variable is the negation of an original or transformed variable"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_NEGATED: SCIP_Varstatus = 6;
#[doc = " status of problem variables"]
pub type SCIP_Varstatus = ::std::os::raw::c_uint;
#[doc = " status of problem variables"]
pub use self::SCIP_Varstatus as SCIP_VARSTATUS;
#[doc = "< binary variable: \\f$ x \\in \\{0,1\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_BINARY: SCIP_Vartype = 0;
#[doc = "< integer variable: \\f$ x \\in \\{lb, \\dots, ub\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_INTEGER: SCIP_Vartype = 1;
#[doc = "< @deprecated use `SCIPcreateVarImpl()` or `SCIPvarChgImplType()` to control implied integrality"]
pub const SCIP_Vartype_SCIP_VARTYPE_IMPLINT: SCIP_Vartype = 2;
#[doc = "< continuous variable: \\f$ lb \\leq x \\leq ub \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_CONTINUOUS: SCIP_Vartype = 3;
#[doc = " variable type"]
pub type SCIP_Vartype = ::std::os::raw::c_uint;
#[doc = " variable type"]
pub use self::SCIP_Vartype as SCIP_VARTYPE;
#[doc = "< The variable is not implied integral by other variables"]
pub const SCIP_ImplintType_SCIP_IMPLINTTYPE_NONE: SCIP_ImplintType = 0;
#[doc = "< The constraint handlers enforce that if the problem is relaxed\n   to have integrality constraints for the non-implied integral variables\n   only, there exists an optimal solution where all weakly and strongly\n   implied integral variables have integer solution values.\n   For infeasible problems, when relaxing integrality of all implied\n   integer variables, the problem remains infeasible.\n   For unbounded problems, when enforcing integrality of all implied\n   integer variables, the problem remains unbounded.\n\n   @note This notion of implied integrality is fragile and may break\n   if extra constraints are added.\n\n   Example: The variable z is a weakly implied integral if it only occurs\n   in the constraint 4x + 3y + z <= 10, where x and y are integer and\n   z has objective 0."]
pub const SCIP_ImplintType_SCIP_IMPLINTTYPE_WEAK: SCIP_ImplintType = 1;
#[doc = "< The constraint handlers enforce that if the problem is relaxed\n   to have integrality constraints for the non-implied integral variables\n   only, in every feasible solution all strongly implied integral\n   variables have integer solution values.\n\n   @note This notion of implied integrality remains intact under the\n   addition of additional constraints to the problem.\n\n   Example: The variable z is strongly implied integral if we have the\n   constraint: 4x + 3y + z = 10, where x and y are integer variables."]
pub const SCIP_ImplintType_SCIP_IMPLINTTYPE_STRONG: SCIP_ImplintType = 2;
#[doc = " implied integral type"]
pub type SCIP_ImplintType = ::std::os::raw::c_uint;
#[doc = " implied integral type"]
pub use self::SCIP_ImplintType as SCIP_IMPLINTTYPE;
#[doc = "< dynamic bound changes with size information of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_DYNAMIC: SCIP_DomchgType = 0;
#[doc = "< static domain changes: number of entries equals size of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOTH: SCIP_DomchgType = 1;
#[doc = "< static domain changes without any hole changes"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOUND: SCIP_DomchgType = 2;
#[doc = " domain change data type"]
pub type SCIP_DomchgType = ::std::os::raw::c_uint;
#[doc = " domain change data type"]
pub use self::SCIP_DomchgType as SCIP_DOMCHGTYPE;
#[doc = "< bound change was due to a branching decision"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_BRANCHING: SCIP_BoundchgType = 0;
#[doc = "< bound change was due to an inference of a constraint (domain propagation)"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_CONSINFER: SCIP_BoundchgType = 1;
#[doc = "< bound change was due to an inference of a domain propagator"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_PROPINFER: SCIP_BoundchgType = 2;
#[doc = " bound change type"]
pub type SCIP_BoundchgType = ::std::os::raw::c_uint;
#[doc = " bound change type"]
pub use self::SCIP_BoundchgType as SCIP_BOUNDCHGTYPE;
#[doc = "< variable locks for model and check constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_MODEL: SCIP_LockType = 0;
#[doc = "< variable locks for conflict constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_CONFLICT: SCIP_LockType = 1;
pub type SCIP_LockType = ::std::os::raw::c_uint;
pub use self::SCIP_LockType as SCIP_LOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBound {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOUND = SCIP_DomChgBound;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBoth {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOTH = SCIP_DomChgBoth;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgDyn {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGDYN = SCIP_DomChgDyn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_DomChg {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHG = SCIP_DomChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundChg {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDCHG = SCIP_BoundChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgIdx {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGIDX = SCIP_BdChgIdx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgInfo {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGINFO = SCIP_BdChgInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchingData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHINGDATA = SCIP_BranchingData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_InferenceData {
    _unused: [u8; 0],
}
pub type SCIP_INFERENCEDATA = SCIP_InferenceData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HoleChg {
    _unused: [u8; 0],
}
pub type SCIP_HOLECHG = SCIP_HoleChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Hole {
    _unused: [u8; 0],
}
pub type SCIP_HOLE = SCIP_Hole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Holelist {
    _unused: [u8; 0],
}
pub type SCIP_HOLELIST = SCIP_Holelist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dom {
    _unused: [u8; 0],
}
pub type SCIP_DOM = SCIP_Dom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Original {
    _unused: [u8; 0],
}
pub type SCIP_ORIGINAL = SCIP_Original;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Loose {
    _unused: [u8; 0],
}
pub type SCIP_LOOSE = SCIP_Loose;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Aggregate {
    _unused: [u8; 0],
}
pub type SCIP_AGGREGATE = SCIP_Aggregate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_AggregateExact {
    _unused: [u8; 0],
}
pub type SCIP_AGGREGATEEXACT = SCIP_AggregateExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Multaggr {
    _unused: [u8; 0],
}
pub type SCIP_MULTAGGR = SCIP_Multaggr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultaggrExact {
    _unused: [u8; 0],
}
pub type SCIP_MULTAGGREXACT = SCIP_MultaggrExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Negate {
    _unused: [u8; 0],
}
pub type SCIP_NEGATE = SCIP_Negate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Var {
    _unused: [u8; 0],
}
pub type SCIP_VAR = SCIP_Var;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VarData {
    _unused: [u8; 0],
}
pub type SCIP_VARDATA = SCIP_VarData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VarDataExact {
    _unused: [u8; 0],
}
pub type SCIP_VARDATAEXACT = SCIP_VarDataExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomExact {
    _unused: [u8; 0],
}
pub type SCIP_DOMEXACT = SCIP_DomExact;
#[doc = "< maximization of objective function"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MAXIMIZE: SCIP_Objsense = -1;
#[doc = "< minimization of objective function (the default)"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MINIMIZE: SCIP_Objsense = 1;
#[doc = " objective sense: minimization or maximization"]
pub type SCIP_Objsense = ::std::os::raw::c_int;
#[doc = " objective sense: minimization or maximization"]
pub use self::SCIP_Objsense as SCIP_OBJSENSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prob {
    _unused: [u8; 0],
}
pub type SCIP_PROB = SCIP_Prob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProbData {
    _unused: [u8; 0],
}
pub type SCIP_PROBDATA = SCIP_ProbData;
#[doc = "< the focus node, whose data is stored in the tree data structure"]
pub const SCIP_NodeType_SCIP_NODETYPE_FOCUSNODE: SCIP_NodeType = 0;
#[doc = "< temporary child node of the focus or refocused node used for probing"]
pub const SCIP_NodeType_SCIP_NODETYPE_PROBINGNODE: SCIP_NodeType = 1;
#[doc = "< unsolved sibling of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_SIBLING: SCIP_NodeType = 2;
#[doc = "< unsolved child of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_CHILD: SCIP_NodeType = 3;
#[doc = "< unsolved leaf of the tree, stored in the tree's queue"]
pub const SCIP_NodeType_SCIP_NODETYPE_LEAF: SCIP_NodeType = 4;
#[doc = "< temporary type of focus node, if it was solved completely"]
pub const SCIP_NodeType_SCIP_NODETYPE_DEADEND: SCIP_NodeType = 5;
#[doc = "< fork without LP solution"]
pub const SCIP_NodeType_SCIP_NODETYPE_JUNCTION: SCIP_NodeType = 6;
#[doc = "< fork without LP solution and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_PSEUDOFORK: SCIP_NodeType = 7;
#[doc = "< fork with solved LP and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_FORK: SCIP_NodeType = 8;
#[doc = "< fork with solved LP and arbitrarily changed rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_SUBROOT: SCIP_NodeType = 9;
#[doc = "< junction, fork, or subroot that was refocused for domain propagation"]
pub const SCIP_NodeType_SCIP_NODETYPE_REFOCUSNODE: SCIP_NodeType = 10;
pub type SCIP_NodeType = ::std::os::raw::c_uint;
pub use self::SCIP_NodeType as SCIP_NODETYPE;
#[doc = " probing node, possibly with solved LP, where bounds and constraints have been changed,\n  and rows and columns might have been added"]
pub type SCIP_PROBINGNODE = SCIP_Probingnode;
#[doc = " sibling information (should not exceed the size of a pointer)"]
pub type SCIP_SIBLING = SCIP_Sibling;
#[doc = " child information (should not exceed the size of a pointer)"]
pub type SCIP_CHILD = SCIP_Child;
#[doc = " leaf information (should not exceed the size of a pointer)"]
pub type SCIP_LEAF = SCIP_Leaf;
#[doc = " fork without LP solution, where only bounds and constraints have been changed"]
pub type SCIP_JUNCTION = SCIP_Junction;
#[doc = " fork without LP solution, where bounds and constraints have been changed, and rows and columns were added"]
pub type SCIP_PSEUDOFORK = SCIP_Pseudofork;
#[doc = " fork with solved LP, where bounds and constraints have been changed, and rows and columns were added"]
pub type SCIP_FORK = SCIP_Fork;
#[doc = " fork with solved LP, where bounds and constraints have been changed, and rows and columns were removed and added"]
pub type SCIP_SUBROOT = SCIP_Subroot;
#[doc = " node data structure"]
pub type SCIP_NODE = SCIP_Node;
#[doc = " bound change information for pending bound changes"]
pub type SCIP_PENDINGBDCHG = SCIP_PendingBdchg;
#[doc = " branch and bound tree"]
pub type SCIP_TREE = SCIP_Tree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bandit {
    _unused: [u8; 0],
}
#[doc = " data structure for bandit algorithms"]
pub type SCIP_BANDIT = SCIP_Bandit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditVTable {
    _unused: [u8; 0],
}
#[doc = " virtual function table for bandit callbacks"]
pub type SCIP_BANDITVTABLE = SCIP_BanditVTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditData {
    _unused: [u8; 0],
}
#[doc = " data structure for specific bandit algorithm implementation"]
pub type SCIP_BANDITDATA = SCIP_BanditData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchCand {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHCAND = SCIP_BranchCand;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Branchrule {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULE = SCIP_Branchrule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchruleData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULEDATA = SCIP_BranchruleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Treemodel {
    _unused: [u8; 0],
}
pub type SCIP_TREEMODEL = SCIP_Treemodel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflicthdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLR = SCIP_Conflicthdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflicthdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLRDATA = SCIP_ConflicthdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflictSet {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTSET = SCIP_ConflictSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProofSet {
    _unused: [u8; 0],
}
pub type SCIP_PROOFSET = SCIP_ProofSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflictRow {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTROW = SCIP_ConflictRow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPBdChgs {
    _unused: [u8; 0],
}
pub type SCIP_LPBDCHGS = SCIP_LPBdChgs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflict {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICT = SCIP_Conflict;
#[doc = "< unknown type"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_UNKNOWN: SCIP_ConflictType = 0;
#[doc = "< conflict results from propagation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_PROPAGATION: SCIP_ConflictType = 1;
#[doc = "< conflict results from an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_INFEASLP: SCIP_ConflictType = 2;
#[doc = "< conflict results from a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_BNDEXCEEDING: SCIP_ConflictType = 3;
#[doc = "< alternative proof of an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTINFPROOF: SCIP_ConflictType = 4;
#[doc = "< alternative proof of a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTBNDPROOF: SCIP_ConflictType = 5;
#[doc = " types of conflicts"]
pub type SCIP_ConflictType = ::std::os::raw::c_uint;
#[doc = " types of conflicts"]
pub use self::SCIP_ConflictType as SCIP_CONFTYPE;
#[doc = "< no presolving"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_DISABLED: SCIP_ConflictPresolStrat = 0;
#[doc = "< keep variables contributing with its local bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYLOCAL: SCIP_ConflictPresolStrat = 1;
#[doc = "< keep variables contributing with its global bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYGLOBAL: SCIP_ConflictPresolStrat = 2;
#[doc = "< keep variables contributing with its global bound and add a few\n   variables contributing with its local bound such that the\n   constraint is not globally redundant"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_BOTH: SCIP_ConflictPresolStrat = 3;
#[doc = " dualray presolving strategy"]
pub type SCIP_ConflictPresolStrat = ::std::os::raw::c_uint;
#[doc = " dualray presolving strategy"]
pub use self::SCIP_ConflictPresolStrat as SCIP_CONFPRES;
#[doc = "< solution describes original variables; non-cached elements are zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ORIGINAL: SCIP_SolOrigin = 0;
#[doc = "< all non-cached elements in solution are equal to zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ZERO: SCIP_SolOrigin = 1;
#[doc = "< all non-cached elements in solution are equal to current LP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_LPSOL: SCIP_SolOrigin = 2;
#[doc = "< all non-cached elements in solution are equal to current NLP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_NLPSOL: SCIP_SolOrigin = 3;
#[doc = "< all non-cached elements in solution are equal to current relaxation solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_RELAXSOL: SCIP_SolOrigin = 4;
#[doc = "< all non-cached elements in solution are equal to current pseudo solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PSEUDOSOL: SCIP_SolOrigin = 5;
#[doc = "< solution describes original solution; all non-cached elements in solution\n   are treated as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PARTIAL: SCIP_SolOrigin = 6;
#[doc = "< all non-cached elements in solution are unknown; they have to be treated\n   as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_UNKNOWN: SCIP_SolOrigin = 7;
#[doc = " origin of solution: where to retrieve uncached elements"]
pub type SCIP_SolOrigin = ::std::os::raw::c_uint;
#[doc = " origin of solution: where to retrieve uncached elements"]
pub use self::SCIP_SolOrigin as SCIP_SOLORIGIN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sol {
    _unused: [u8; 0],
}
pub type SCIP_SOL = SCIP_Sol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Viol {
    _unused: [u8; 0],
}
pub type SCIP_VIOL = SCIP_Viol;
#[doc = "< type of solution unspecified (the default)"]
pub const SCIP_SolType_SCIP_SOLTYPE_UNKNOWN: SCIP_SolType = 0;
#[doc = "< solution was found by a heuristic"]
pub const SCIP_SolType_SCIP_SOLTYPE_HEUR: SCIP_SolType = 1;
#[doc = "< solution was found by a relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_RELAX: SCIP_SolType = 2;
#[doc = "< solution was found by the LP relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_LPRELAX: SCIP_SolType = 3;
#[doc = "< solution was found during strong branching"]
pub const SCIP_SolType_SCIP_SOLTYPE_STRONGBRANCH: SCIP_SolType = 4;
#[doc = "< solution originates from a pseudo solution"]
pub const SCIP_SolType_SCIP_SOLTYPE_PSEUDO: SCIP_SolType = 5;
#[doc = " type of solution: heuristic or (LP) relaxation solution, or unspecified origin"]
pub type SCIP_SolType = ::std::os::raw::c_uint;
#[doc = " type of solution: heuristic or (LP) relaxation solution, or unspecified origin"]
pub use self::SCIP_SolType as SCIP_SOLTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ValsExact {
    _unused: [u8; 0],
}
pub type SCIP_VALSEXACT = SCIP_ValsExact;
pub type SCIP_DIVETYPE = ::std::os::raw::c_uint;
#[doc = "< all contexts combined"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_TOTAL: SCIP_DiveContext = 0;
#[doc = "< single heuristic context"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_SINGLE: SCIP_DiveContext = 1;
#[doc = "< within adaptive diving"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_ADAPTIVE: SCIP_DiveContext = 2;
#[doc = "< within the scheduler heuristic"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_SCHEDULER: SCIP_DiveContext = 3;
#[doc = " context for diving statistics"]
pub type SCIP_DiveContext = ::std::os::raw::c_uint;
#[doc = " context for diving statistics"]
pub use self::SCIP_DiveContext as SCIP_DIVECONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Heur {
    _unused: [u8; 0],
}
pub type SCIP_HEUR = SCIP_Heur;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HeurData {
    _unused: [u8; 0],
}
pub type SCIP_HEURDATA = SCIP_HeurData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Diveset {
    _unused: [u8; 0],
}
pub type SCIP_DIVESET = SCIP_Diveset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VGraph {
    _unused: [u8; 0],
}
pub type SCIP_VGRAPH = SCIP_VGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conshdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLR = SCIP_Conshdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cons {
    _unused: [u8; 0],
}
pub type SCIP_CONS = SCIP_Cons;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConshdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLRDATA = SCIP_ConshdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsData {
    _unused: [u8; 0],
}
pub type SCIP_CONSDATA = SCIP_ConsData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsSetChg {
    _unused: [u8; 0],
}
pub type SCIP_CONSSETCHG = SCIP_ConsSetChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LinConsStats {
    _unused: [u8; 0],
}
pub type SCIP_LINCONSSTATS = SCIP_LinConsStats;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYM_Graph {
    _unused: [u8; 0],
}
pub type SYM_GRAPH = SYM_Graph;
#[doc = "< linear constraints with no variables"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EMPTY: SCIP_LinConstype = 0;
#[doc = "< linear constraints with no finite side"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_FREE: SCIP_LinConstype = 1;
#[doc = "< linear constraints with a single variable"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SINGLETON: SCIP_LinConstype = 2;
#[doc = "< linear constraints of the type \\f$ ax + by = c\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_AGGREGATION: SCIP_LinConstype = 3;
#[doc = "< linear constraints of the type \\f$ a x - a y \\leq b\\f$ where \\f$x\\f$ and \\f$y\\f$ must have the same type"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_PRECEDENCE: SCIP_LinConstype = 4;
#[doc = "< linear constraints of the form \\f$ ax + by \\leq c \\, x \\in \\{0,1\\} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_VARBOUND: SCIP_LinConstype = 5;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPARTITION: SCIP_LinConstype = 6;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPACKING: SCIP_LinConstype = 7;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\geq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETCOVERING: SCIP_LinConstype = 8;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = k\\, x_i \\in \\{0,1\\} \\forall i, \\, k\\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_CARDINALITY: SCIP_LinConstype = 9;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INVKNAPSACK: SCIP_LinConstype = 10;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i = b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EQKNAPSACK: SCIP_LinConstype = 11;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i + a x \\leq a\\, x, x_i \\in \\{0,1\\} \\forall i, \\, a\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_BINPACKING: SCIP_LinConstype = 12;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_KNAPSACK: SCIP_LinConstype = 13;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\mathbb{Z} \\forall i, \\, b\\in \\mathbb{n} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INTKNAPSACK: SCIP_LinConstype = 14;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k + \\sum p_j s_j \\leq/= b\\, x_i \\in \\{0,1\\} \\forall i, s_j \\in \\text{ cont. } \\forall j\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_MIXEDBINARY: SCIP_LinConstype = 15;
#[doc = "< general linear constraints with no special structure"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_GENERAL: SCIP_LinConstype = 16;
#[doc = " linear constraint types recognizable"]
pub type SCIP_LinConstype = ::std::os::raw::c_uint;
#[doc = " linear constraint types recognizable"]
pub use self::SCIP_LinConstype as SCIP_LINCONSTYPE;
#[doc = "< a SCIP_Bool value"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_BOOL: SCIP_Datatree_Valuetype = 0;
#[doc = "< a SCIP_Longint integer value"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_LONG: SCIP_Datatree_Valuetype = 1;
#[doc = "< a SCIP_Real floating point value"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_REAL: SCIP_Datatree_Valuetype = 2;
#[doc = "< a C string"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_STRING: SCIP_Datatree_Valuetype = 3;
#[doc = "< an array of SCIP_Bool values"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_BOOLARRAY: SCIP_Datatree_Valuetype = 4;
#[doc = "< an array of SCIP_Longint values"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_LONGARRAY: SCIP_Datatree_Valuetype = 5;
#[doc = "< an array of SCIP_Real values"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_REALARRAY: SCIP_Datatree_Valuetype = 6;
#[doc = "< an array of C strings"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_STRINGARRAY: SCIP_Datatree_Valuetype = 7;
#[doc = "< a SCIP_DATATREE object"]
pub const SCIP_Datatree_Valuetype_SCIP_DATATREE_DATATREE: SCIP_Datatree_Valuetype = 8;
#[doc = " type of values stored in a SCIP_DATATREE"]
pub type SCIP_Datatree_Valuetype = ::std::os::raw::c_uint;
#[doc = " type of values stored in a SCIP_DATATREE"]
pub use self::SCIP_Datatree_Valuetype as SCIP_DATATREE_VALUETYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Datatree {
    _unused: [u8; 0],
}
#[doc = " generic hierarchical data storage"]
pub type SCIP_DATATREE = SCIP_Datatree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialog {
    _unused: [u8; 0],
}
pub type SCIP_DIALOG = SCIP_Dialog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DialogData {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGDATA = SCIP_DialogData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialoghdlr {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGHDLR = SCIP_Dialoghdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Linelist {
    _unused: [u8; 0],
}
pub type SCIP_LINELIST = SCIP_Linelist;
#[doc = "< display column is not displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_OFF: SCIP_DispStatus = 0;
#[doc = "< display column is switched on and off automatically"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_AUTO: SCIP_DispStatus = 1;
#[doc = "< display column is displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_ON: SCIP_DispStatus = 2;
#[doc = " display activation status of display column"]
pub type SCIP_DispStatus = ::std::os::raw::c_uint;
#[doc = " display activation status of display column"]
pub use self::SCIP_DispStatus as SCIP_DISPSTATUS;
#[doc = "< display column is displayed only in sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_DEFAULT: SCIP_DispMode = 1;
#[doc = "< display column is displayed only in concurrent mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_CONCURRENT: SCIP_DispMode = 2;
#[doc = "< display column is displayed in concurrent and sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_ALL: SCIP_DispMode = 3;
#[doc = " display activation status of display column"]
pub type SCIP_DispMode = ::std::os::raw::c_uint;
#[doc = " display activation status of display column"]
pub use self::SCIP_DispMode as SCIP_DISPMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Disp {
    _unused: [u8; 0],
}
pub type SCIP_DISP = SCIP_Disp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DispData {
    _unused: [u8; 0],
}
pub type SCIP_DISPDATA = SCIP_DispData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Rational {
    _unused: [u8; 0],
}
#[doc = " type used for rational numbers"]
pub type SCIP_RATIONAL = SCIP_Rational;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RationalArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Real values"]
pub type SCIP_RATIONALARRAY = SCIP_RationalArray;
#[doc = "< representability is unknown"]
pub const SCIP_IsFpRepresentable_SCIP_ISFPREPRESENTABLE_UNKNOWN: SCIP_IsFpRepresentable = 0;
#[doc = "< is representable"]
pub const SCIP_IsFpRepresentable_SCIP_ISFPREPRESENTABLE_TRUE: SCIP_IsFpRepresentable = 1;
#[doc = "< is not representable"]
pub const SCIP_IsFpRepresentable_SCIP_ISFPREPRESENTABLE_FALSE: SCIP_IsFpRepresentable = 2;
#[doc = " information if a rational is exactly representable as a floating point number"]
pub type SCIP_IsFpRepresentable = ::std::os::raw::c_uint;
#[doc = " information if a rational is exactly representable as a floating point number"]
pub use self::SCIP_IsFpRepresentable as SCIP_ISFPREPRESENTABLE;
#[doc = "< always round to nearest smaller double"]
pub const SCIP_RoundModeRational_SCIP_R_ROUND_DOWNWARDS: SCIP_RoundModeRational = 0;
#[doc = "< always round to nearest larger double"]
pub const SCIP_RoundModeRational_SCIP_R_ROUND_UPWARDS: SCIP_RoundModeRational = 1;
#[doc = "< always round to nearest double"]
pub const SCIP_RoundModeRational_SCIP_R_ROUND_NEAREST: SCIP_RoundModeRational = 2;
#[doc = " defines the possible rounding direction for a rational number, when converting to a double"]
pub type SCIP_RoundModeRational = ::std::os::raw::c_uint;
#[doc = " defines the possible rounding direction for a rational number, when converting to a double"]
pub use self::SCIP_RoundModeRational as SCIP_ROUNDMODE_RAT;
#[doc = " interval given by infimum and supremum"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Interval {
    #[doc = "< infimum (lower bound) of interval"]
    pub inf: f64,
    #[doc = "< supremum (upper bound) of interval"]
    pub sup: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Interval"][::std::mem::size_of::<SCIP_Interval>() - 16usize];
    ["Alignment of SCIP_Interval"][::std::mem::align_of::<SCIP_Interval>() - 8usize];
    ["Offset of field: SCIP_Interval::inf"][::std::mem::offset_of!(SCIP_Interval, inf) - 0usize];
    ["Offset of field: SCIP_Interval::sup"][::std::mem::offset_of!(SCIP_Interval, sup) - 8usize];
};
#[doc = " interval given by infimum and supremum"]
pub type SCIP_INTERVAL = SCIP_Interval;
#[doc = " rounding mode of floating point operations (upwards, downwards, nearest, ...)\n\n exact values depend on machine and compiler"]
pub type SCIP_ROUNDMODE = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " returns whether rounding mode control is available"]
    pub fn SCIPintervalHasRoundingControl() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets rounding mode of floating point operations"]
    pub fn SCIPintervalSetRoundingMode(roundmode: SCIP_ROUNDMODE);
}
unsafe extern "C" {
    #[doc = " gets current rounding mode of floating point operations"]
    pub fn SCIPintervalGetRoundingMode() -> SCIP_ROUNDMODE;
}
unsafe extern "C" {
    #[doc = " sets rounding mode of floating point operations to downwards rounding"]
    pub fn SCIPintervalSetRoundingModeDownwards();
}
unsafe extern "C" {
    #[doc = " sets rounding mode of floating point operations to upwards rounding"]
    pub fn SCIPintervalSetRoundingModeUpwards();
}
unsafe extern "C" {
    #[doc = " sets rounding mode of floating point operations to nearest rounding"]
    pub fn SCIPintervalSetRoundingModeToNearest();
}
unsafe extern "C" {
    #[doc = " sets rounding mode of floating point operations to towards zero rounding"]
    pub fn SCIPintervalSetRoundingModeTowardsZero();
}
unsafe extern "C" {
    #[doc = " negates a number in a way that the compiler does not optimize it away"]
    pub fn SCIPintervalNegateReal(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns infimum of interval"]
    pub fn SCIPintervalGetInf(interval: SCIP_INTERVAL) -> f64;
}
unsafe extern "C" {
    #[doc = " returns supremum of interval"]
    pub fn SCIPintervalGetSup(interval: SCIP_INTERVAL) -> f64;
}
unsafe extern "C" {
    #[doc = " stores given value as interval"]
    pub fn SCIPintervalSet(resultant: *mut SCIP_INTERVAL, value: f64);
}
unsafe extern "C" {
    #[doc = " stores given value as interval"]
    pub fn SCIPintervalSetRational(resultant: *mut SCIP_INTERVAL, value: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " stores given infimum and supremum as interval"]
    pub fn SCIPintervalSetBounds(resultant: *mut SCIP_INTERVAL, inf: f64, sup: f64);
}
unsafe extern "C" {
    #[doc = " sets interval to empty interval, which will be [1.0, -1.0]"]
    pub fn SCIPintervalSetEmpty(resultant: *mut SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " indicates whether interval is empty, i.e., whether inf > sup"]
    pub fn SCIPintervalIsEmpty(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets interval to entire [-infinity, +infinity]"]
    pub fn SCIPintervalSetEntire(infinity: f64, resultant: *mut SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " indicates whether interval is entire, i.e., whether inf &le; -infinity and sup &ge; infinity"]
    pub fn SCIPintervalIsEntire(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether interval is positive infinity, i.e., [infinity, infinity]"]
    pub fn SCIPintervalIsPositiveInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether interval is negative infinity, i.e., [-infinity, -infinity]"]
    pub fn SCIPintervalIsNegativeInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether operand1 is contained in operand2"]
    pub fn SCIPintervalIsSubsetEQ(
        infinity: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether operand1 and operand2 are disjoint"]
    pub fn SCIPintervalAreDisjoint(
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether operand1 and operand2 are disjoint with epsilon tolerance\n\n Returns whether minimal (relative) distance of intervals is larger than epsilon.\n Same as `SCIPintervalIsEmpty(SCIPintervalIntersectEps(operand1, operand2))`."]
    pub fn SCIPintervalAreDisjointEps(
        eps: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " intersection of two intervals"]
    pub fn SCIPintervalIntersect(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " intersection of two intervals with epsilon tolerance\n\n If intersection of operand1 and operand2 is empty, but minimal (relative) distance of intervals\n is at most epsilon, then set resultant to singleton containing the point in operand1\n that is closest to operand2, i.e.,\n - `resultant = { operand1.sup }`, if `operand1.sup` < `operand2.inf` and `reldiff(operand2.inf,operand1.sup)` &le; eps\n - `resultant = { operand1.inf }`, if `operand1.inf` > `operand2.sup` and `reldiff(operand1.inf,operand2.sup)` &le; eps\n - `resultant` = intersection of `operand1` and `operand2`, otherwise"]
    pub fn SCIPintervalIntersectEps(
        resultant: *mut SCIP_INTERVAL,
        eps: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " interval enclosure of the union of two intervals"]
    pub fn SCIPintervalUnify(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " adds operand1 and operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalAddInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " adds operand1 and operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalAddSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " adds operand1 and operand2 and stores result in resultant"]
    pub fn SCIPintervalAdd(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " adds operand1 and scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalAddScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " adds vector operand1 and vector operand2 and stores result in vector resultant"]
    pub fn SCIPintervalAddVectors(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " subtracts operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSub(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " subtracts scalar operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSubScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores result in resultant"]
    pub fn SCIPintervalMul(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulScalarInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulScalarSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalMulScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " divides operand1 by operand2 and stores result in resultant"]
    pub fn SCIPintervalDiv(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " divides operand1 by scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalDivScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " computes the scalar product of two vectors of intervals and stores result in resultant"]
    pub fn SCIPintervalScalprod(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalScalprodScalarsInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalScalprodScalarsSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores result in resultant"]
    pub fn SCIPintervalScalprodScalars(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " squares operand and stores result in resultant"]
    pub fn SCIPintervalSquare(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores (positive part of) square root of operand in resultant\n @attention we assume a correctly rounded sqrt(double) function when rounding is to nearest"]
    pub fn SCIPintervalSquareRoot(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores operand1 to the power of operand2 in resultant\n\n uses SCIPintervalPowerScalar if operand2 is a scalar, otherwise computes exp(op2*log(op1))"]
    pub fn SCIPintervalPower(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores operand1 to the power of the scalar operand2 in resultant\n @attention we assume a correctly rounded pow(double) function when rounding is to nearest"]
    pub fn SCIPintervalPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " stores bounds on the power of a scalar operand1 to a scalar operand2 in resultant\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 or operand2 integer and needs to have operand2 &ge; 0 if operand1 = 0.\n @attention we assume a correctly rounded pow(double) function when rounding is to nearest"]
    pub fn SCIPintervalPowerScalarScalar(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " computes lower bound on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and need to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarIntegerInf(operand1: f64, operand2: ::std::os::raw::c_int)
    -> f64;
}
unsafe extern "C" {
    #[doc = " computes upper bound on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and needs to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarIntegerSup(operand1: f64, operand2: ::std::os::raw::c_int)
    -> f64;
}
unsafe extern "C" {
    #[doc = " computes bounds on power of a scalar operand1 to an integer operand2\n\n Both operands need to be finite numbers.\n Needs to have operand1 &ge; 0 and needs to have operand2 &ge; 0 if operand1 = 0."]
    pub fn SCIPintervalPowerScalarInteger(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " given an interval for the image of a power operation, computes an interval for the origin\n\n That is, for \\f$y = x^p\\f$ with the exponent \\f$p\\f$ a given scalar and \\f$y\\f$ = `image` a given interval,\n computes \\f$x \\subseteq \\text{basedomain}\\f$ such that \\f$y \\in x^p\\f$ and such that for all \\f$z \\in \\text{basedomain} \\setminus x: z^p \\not \\in y\\f$."]
    pub fn SCIPintervalPowerScalarInverse(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        basedomain: SCIP_INTERVAL,
        exponent: f64,
        image: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores operand1 to the signed power of the scalar positive operand2 in resultant\n\n The signed power of x w.r.t. an exponent n &ge; 0 is given as \\f$\\mathrm{sign}(x) |x|^n\\f$.\n\n @attention we assume correctly rounded sqrt(double) and pow(double) functions when rounding is to nearest"]
    pub fn SCIPintervalSignPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
unsafe extern "C" {
    #[doc = " computes the reciprocal of an interval"]
    pub fn SCIPintervalReciprocal(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores exponential of operand in resultant\n @attention we assume a correctly rounded exp(double) function when rounding is to nearest"]
    pub fn SCIPintervalExp(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores natural logarithm of operand in resultant\n @attention we assume a correctly rounded log(double) function when rounding is to nearest"]
    pub fn SCIPintervalLog(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores minimum of operands in resultant"]
    pub fn SCIPintervalMin(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores maximum of operands in resultant"]
    pub fn SCIPintervalMax(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " returns the maximum of the absolute values of the infimum and supremum of the interval"]
    pub fn SCIPintervalAbsMax(interval: SCIP_INTERVAL) -> f64;
}
unsafe extern "C" {
    #[doc = " stores absolute value of operand in resultant"]
    pub fn SCIPintervalAbs(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores sine value of operand in resultant"]
    pub fn SCIPintervalSin(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores cosine value of operand in resultant"]
    pub fn SCIPintervalCos(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores sign of operand in resultant"]
    pub fn SCIPintervalSign(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
unsafe extern "C" {
    #[doc = " stores entropy of operand in resultant"]
    pub fn SCIPintervalEntropy(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " computes exact upper bound on \\f$ a x^2 + b x \\f$ for x in [xlb, xub], b an interval, and a scalar\n\n Uses Algorithm 2.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)."]
    pub fn SCIPintervalQuadUpperBound(
        infinity: f64,
        a: f64,
        b_: SCIP_INTERVAL,
        x: SCIP_INTERVAL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " stores range of quadratic term in resultant\n\n given scalar a and intervals b and x, computes interval for \\f$ a x^2 + b x \\f$"]
    pub fn SCIPintervalQuad(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: SCIP_INTERVAL,
        xrng: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " computes interval with positive solutions of a quadratic equation with interval coefficients\n\n Given intervals a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositive(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " computes interval with negative solutions of a quadratic equation with interval coefficients\n\n Given intervals a, b, and c, this function computes an interval that contains all negative solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionNegative(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " computes positive solutions of a quadratic equation with scalar coefficients\n\n Givens scalar a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\geq c\\f$ within xbnds.\n Implements Algorithm 3.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: f64,
        rhs: f64,
        xbnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " solves a quadratic equation with interval coefficients\n\n Given intervals a, b and c, this function computes an interval that contains all solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpression(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " stores range of bivariate quadratic term in resultant\n\n Given scalars \\f$a_x\\f$, \\f$a_y\\f$, \\f$a_{xy}\\f$, \\f$b_x\\f$, and \\f$b_y\\f$ and intervals for \\f$x\\f$ and \\f$y\\f$,\n computes interval for \\f$ a_x x^2 + a_y y^2 + a_{xy} x y + b_x x + b_y y \\f$.\n\n \\attention The operations are not applied rounding-safe here!"]
    pub fn SCIPintervalQuadBivar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " solves a bivariate quadratic equation for the first variable\n\n Given scalars \\f$a_x\\f$, \\f$a_y\\f$, \\f$a_{xy}\\f$, \\f$b_x\\f$ and \\f$b_y\\f$, and intervals for \\f$x\\f$, \\f$y\\f$, and rhs,\n computes \\f$ \\{ x \\in \\mathbf{x} : \\exists y \\in \\mathbf{y} : a_x x^2 + a_y y^2 + a_{xy} x y + b_x x + b_y y \\in \\mathbf{\\mbox{rhs}} \\} \\f$.\n\n \\attention the operations are not applied rounding-safe here"]
    pub fn SCIPintervalSolveBivariateQuadExpressionAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
unsafe extern "C" {
    #[doc = " propagates a weighted sum of intervals in a given interval\n\n Given \\f$\\text{constant} + \\sum_i \\text{weights}_i \\text{operands}_i \\in \\text{rhs}\\f$,\n computes possibly tighter interval for each term.\n\n @attention Valid values are returned in resultants only if any tightening has been found and no empty interval, that is, function returns with non-zero and `*infeasible` = FALSE.\n\n @return Number of terms for which resulting interval is smaller than operand interval."]
    pub fn SCIPintervalPropagateWeightedSum(
        infinity: f64,
        noperands: ::std::os::raw::c_int,
        operands: *mut SCIP_INTERVAL,
        weights: *mut f64,
        constant: f64,
        rhs: SCIP_INTERVAL,
        resultants: *mut SCIP_INTERVAL,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA = SCIP_ExprData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Expr {
    _unused: [u8; 0],
}
pub type SCIP_EXPR = SCIP_Expr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYM_ExprData {
    _unused: [u8; 0],
}
pub type SYM_EXPRDATA = SYM_ExprData;
#[doc = "< unknown or indefinite curvature"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_UNKNOWN: SCIP_EXPRCURV = 0;
#[doc = "< convex"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_CONVEX: SCIP_EXPRCURV = 1;
#[doc = "< concave"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_CONCAVE: SCIP_EXPRCURV = 2;
#[doc = "< linear = convex and concave"]
pub const SCIP_EXPRCURV_SCIP_EXPRCURV_LINEAR: SCIP_EXPRCURV = 3;
#[doc = " curvature types"]
pub type SCIP_EXPRCURV = ::std::os::raw::c_uint;
#[doc = "< unknown or non-monotone"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_UNKNOWN: SCIP_MONOTONE = 0;
#[doc = "< increasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_INC: SCIP_MONOTONE = 1;
#[doc = "< decreasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_DEC: SCIP_MONOTONE = 2;
#[doc = "< constant = increasing and decreasing"]
pub const SCIP_MONOTONE_SCIP_MONOTONE_CONST: SCIP_MONOTONE = 3;
#[doc = " monotonicity"]
pub type SCIP_MONOTONE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Expr_OwnerData {
    _unused: [u8; 0],
}
#[doc = "@name Expression Owner */\n/**@{"]
pub type SCIP_EXPR_OWNERDATA = SCIP_Expr_OwnerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Exprhdlr {
    _unused: [u8; 0],
}
#[doc = "@name Expression Handler */\n/**@{"]
pub type SCIP_EXPRHDLR = SCIP_Exprhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRHDLRDATA = SCIP_ExprhdlrData;
#[doc = " stage of DFS iterator"]
pub type SCIP_EXPRITER_STAGE = ::std::os::raw::c_uint;
#[doc = " user data storage type for expression iteration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SCIP_EXPRITER_USERDATA {
    #[doc = "< a floating-point value"]
    pub realval: f64,
    #[doc = "< an integer value"]
    pub intval: ::std::os::raw::c_int,
    #[doc = "< two integer values"]
    pub intvals: [::std::os::raw::c_int; 2usize],
    #[doc = "< an unsigned integer value"]
    pub uintval: ::std::os::raw::c_uint,
    #[doc = "< a pointer"]
    pub ptrval: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_EXPRITER_USERDATA"][::std::mem::size_of::<SCIP_EXPRITER_USERDATA>() - 8usize];
    ["Alignment of SCIP_EXPRITER_USERDATA"]
        [::std::mem::align_of::<SCIP_EXPRITER_USERDATA>() - 8usize];
    ["Offset of field: SCIP_EXPRITER_USERDATA::realval"]
        [::std::mem::offset_of!(SCIP_EXPRITER_USERDATA, realval) - 0usize];
    ["Offset of field: SCIP_EXPRITER_USERDATA::intval"]
        [::std::mem::offset_of!(SCIP_EXPRITER_USERDATA, intval) - 0usize];
    ["Offset of field: SCIP_EXPRITER_USERDATA::intvals"]
        [::std::mem::offset_of!(SCIP_EXPRITER_USERDATA, intvals) - 0usize];
    ["Offset of field: SCIP_EXPRITER_USERDATA::uintval"]
        [::std::mem::offset_of!(SCIP_EXPRITER_USERDATA, uintval) - 0usize];
    ["Offset of field: SCIP_EXPRITER_USERDATA::ptrval"]
        [::std::mem::offset_of!(SCIP_EXPRITER_USERDATA, ptrval) - 0usize];
};
#[doc = "< reverse topological order"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_RTOPOLOGIC: SCIP_EXPRITER_TYPE = 0;
#[doc = "< breadth-first search"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_BFS: SCIP_EXPRITER_TYPE = 1;
#[doc = "< depth-first search"]
pub const SCIP_EXPRITER_TYPE_SCIP_EXPRITER_DFS: SCIP_EXPRITER_TYPE = 2;
#[doc = " mode for expression iterator"]
pub type SCIP_EXPRITER_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprIterData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRITERDATA = SCIP_ExprIterData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprIter {
    _unused: [u8; 0],
}
pub type SCIP_EXPRITER = SCIP_ExprIter;
pub type SCIP_EXPRPRINT_WHAT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprPrintData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRPRINTDATA = SCIP_ExprPrintData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Compr {
    _unused: [u8; 0],
}
pub type SCIP_COMPR = SCIP_Compr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ComprData {
    _unused: [u8; 0],
}
pub type SCIP_COMPRDATA = SCIP_ComprData;
#[doc = "< downwards branching: decreasing upper bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_DOWNWARDS: SCIP_BranchDir = 0;
#[doc = "< upwards branching: increasing lower bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_UPWARDS: SCIP_BranchDir = 1;
#[doc = "< fixed branching: both bounds changed"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_FIXED: SCIP_BranchDir = 2;
#[doc = "< automatic setting for choosing bound changes"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_AUTO: SCIP_BranchDir = 3;
#[doc = " branching direction for branching on variables"]
pub type SCIP_BranchDir = ::std::os::raw::c_uint;
#[doc = " branching direction for branching on variables"]
pub use self::SCIP_BranchDir as SCIP_BRANCHDIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_History {
    _unused: [u8; 0],
}
pub type SCIP_HISTORY = SCIP_History;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ValueHistory {
    _unused: [u8; 0],
}
#[doc = " Value history data structure\n\n  branching and inference history informations for single variable dependent on the domain value\n\n  - \\ref SCIP_VALUEHISTORY \"List of all available methods\""]
pub type SCIP_VALUEHISTORY = SCIP_ValueHistory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IISfinder {
    _unused: [u8; 0],
}
pub type SCIP_IISFINDER = SCIP_IISfinder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IISfinderData {
    _unused: [u8; 0],
}
pub type SCIP_IISFINDERDATA = SCIP_IISfinderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IIS {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodePQ {
    _unused: [u8; 0],
}
pub type SCIP_NODEPQ = SCIP_NodePQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nodesel {
    _unused: [u8; 0],
}
pub type SCIP_NODESEL = SCIP_Nodesel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodeselData {
    _unused: [u8; 0],
}
pub type SCIP_NODESELDATA = SCIP_NodeselData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Presol {
    _unused: [u8; 0],
}
pub type SCIP_PRESOL = SCIP_Presol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PresolData {
    _unused: [u8; 0],
}
pub type SCIP_PRESOLDATA = SCIP_PresolData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pricer {
    _unused: [u8; 0],
}
pub type SCIP_PRICER = SCIP_Pricer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PricerData {
    _unused: [u8; 0],
}
pub type SCIP_PRICERDATA = SCIP_PricerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reader {
    _unused: [u8; 0],
}
pub type SCIP_READER = SCIP_Reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReaderData {
    _unused: [u8; 0],
}
pub type SCIP_READERDATA = SCIP_ReaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relax {
    _unused: [u8; 0],
}
pub type SCIP_RELAX = SCIP_Relax;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relaxation {
    _unused: [u8; 0],
}
pub type SCIP_RELAXATION = SCIP_Relaxation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RelaxData {
    _unused: [u8; 0],
}
pub type SCIP_RELAXDATA = SCIP_RelaxData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reopt {
    _unused: [u8; 0],
}
pub type SCIP_REOPT = SCIP_Reopt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolTree {
    _unused: [u8; 0],
}
pub type SCIP_SOLTREE = SCIP_SolTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolNode {
    _unused: [u8; 0],
}
pub type SCIP_SOLNODE = SCIP_SolNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptTree {
    _unused: [u8; 0],
}
pub type SCIP_REOPTTREE = SCIP_ReoptTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptNode {
    _unused: [u8; 0],
}
pub type SCIP_REOPTNODE = SCIP_ReoptNode;
pub type SCIP_REPRESENTATIVE = SCIP_ReoptNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptConsData {
    _unused: [u8; 0],
}
pub type SCIP_REOPTCONSDATA = SCIP_ReoptConsData;
#[doc = "< node is not part of the reoptimizationtree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_NONE: SCIP_ReoptType = 0;
#[doc = "< node is only needed for reconstructing the tree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_TRANSIT: SCIP_ReoptType = 1;
#[doc = "< node contains dual reductions which leed to LP infeasibility"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_INFSUBTREE: SCIP_ReoptType = 2;
#[doc = "< node contains dual reductions"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_STRBRANCHED: SCIP_ReoptType = 3;
#[doc = "< node contains additional constraints"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LOGICORNODE: SCIP_ReoptType = 4;
#[doc = "< node is a leaf node"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LEAF: SCIP_ReoptType = 5;
#[doc = "< node is a leaf node and pruned by boudning"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_PRUNED: SCIP_ReoptType = 6;
#[doc = "< node is a leaf node and has an integral optimal LP solution"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_FEASIBLE: SCIP_ReoptType = 7;
pub type SCIP_ReoptType = ::std::os::raw::c_uint;
pub use self::SCIP_ReoptType as SCIP_REOPTTYPE;
#[doc = "< constraint cutoffs an LP infeasible subtree"]
pub const Reopt_ConsType_REOPT_CONSTYPE_INFSUBTREE: Reopt_ConsType = 0;
#[doc = "< constraint reconstructs dual reductions"]
pub const Reopt_ConsType_REOPT_CONSTYPE_DUALREDS: Reopt_ConsType = 1;
#[doc = "< constraint representing a cut, e.g., to separate a solution"]
pub const Reopt_ConsType_REOPT_CONSTYPE_CUT: Reopt_ConsType = 2;
#[doc = "< constraint was added by SCIP, e.g., a (local) conflict"]
pub const Reopt_ConsType_REOPT_CONSTYPE_UNKNOWN: Reopt_ConsType = 3;
pub type Reopt_ConsType = ::std::os::raw::c_uint;
pub use self::Reopt_ConsType as REOPT_CONSTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sepa {
    _unused: [u8; 0],
}
pub type SCIP_SEPA = SCIP_Sepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SepaData {
    _unused: [u8; 0],
}
pub type SCIP_SEPADATA = SCIP_SepaData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cutsel {
    _unused: [u8; 0],
}
pub type SCIP_CUTSEL = SCIP_Cutsel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CutselData {
    _unused: [u8; 0],
}
pub type SCIP_CUTSELDATA = SCIP_CutselData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Table {
    _unused: [u8; 0],
}
pub type SCIP_TABLE = SCIP_Table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_TableData {
    _unused: [u8; 0],
}
pub type SCIP_TABLEDATA = SCIP_TableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prop {
    _unused: [u8; 0],
}
pub type SCIP_PROP = SCIP_Prop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PropData {
    _unused: [u8; 0],
}
pub type SCIP_PROPDATA = SCIP_PropData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlpi {
    _unused: [u8; 0],
}
pub type SCIP_NLPI = SCIP_Nlpi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiData {
    _unused: [u8; 0],
}
pub type SCIP_NLPIDATA = SCIP_NlpiData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiProblem {
    _unused: [u8; 0],
}
pub type SCIP_NLPIPROBLEM = SCIP_NlpiProblem;
#[doc = "< never stop if progress is still possible"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_OFF: SCIP_NlpParam_FastFail = 0;
#[doc = "< stop if it seems unlikely that an improving point can be found"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE: SCIP_NlpParam_FastFail = 1;
#[doc = "< stop if convergence rate is low"]
pub const SCIP_NlpParam_FastFail_SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE: SCIP_NlpParam_FastFail = 2;
#[doc = " NLP solver fast-fail levels"]
pub type SCIP_NlpParam_FastFail = ::std::os::raw::c_uint;
#[doc = " NLP solver fast-fail levels"]
pub use self::SCIP_NlpParam_FastFail as SCIP_NLPPARAM_FASTFAIL;
#[doc = " parameters for NLP solve"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpParam {
    #[doc = "< lower objective limit (cutoff)"]
    pub lobjlimit: f64,
    #[doc = "< feasibility tolerance (maximal allowed absolute violation of constraints and variable bounds)"]
    pub feastol: f64,
    #[doc = "< optimality tolerance (maximal allowed absolute violation of optimality conditions)"]
    pub opttol: f64,
    #[doc = "< solver-specific tolerance on accuracy, e.g., maximal violation of feasibility and optimality in scaled problem (0.0: use solver default)"]
    pub solvertol: f64,
    #[doc = "< time limit in seconds: use SCIP_REAL_MAX to use remaining time available for SCIP solve (limits/time - currenttime)"]
    pub timelimit: f64,
    #[doc = "< iteration limit"]
    pub iterlimit: ::std::os::raw::c_int,
    #[doc = "< verbosity level of output of NLP solver to the screen: 0 off, 1 normal, 2 debug, > 2 more debug"]
    pub verblevel: ::std::os::raw::c_ushort,
    #[doc = "< whether the NLP solver should stop early if convergence is slow"]
    pub fastfail: SCIP_NLPPARAM_FASTFAIL,
    #[doc = "< whether to expect an infeasible problem"]
    pub expectinfeas: ::std::os::raw::c_uint,
    #[doc = "< whether to try to use solution of previous solve as starting point (if available)"]
    pub warmstart: ::std::os::raw::c_uint,
    #[doc = "< name of file from which NLP is solved (it's fine to set this to NULL)"]
    pub caller: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_NlpParam"][::std::mem::size_of::<SCIP_NlpParam>() - 72usize];
    ["Alignment of SCIP_NlpParam"][::std::mem::align_of::<SCIP_NlpParam>() - 8usize];
    ["Offset of field: SCIP_NlpParam::lobjlimit"]
        [::std::mem::offset_of!(SCIP_NlpParam, lobjlimit) - 0usize];
    ["Offset of field: SCIP_NlpParam::feastol"]
        [::std::mem::offset_of!(SCIP_NlpParam, feastol) - 8usize];
    ["Offset of field: SCIP_NlpParam::opttol"]
        [::std::mem::offset_of!(SCIP_NlpParam, opttol) - 16usize];
    ["Offset of field: SCIP_NlpParam::solvertol"]
        [::std::mem::offset_of!(SCIP_NlpParam, solvertol) - 24usize];
    ["Offset of field: SCIP_NlpParam::timelimit"]
        [::std::mem::offset_of!(SCIP_NlpParam, timelimit) - 32usize];
    ["Offset of field: SCIP_NlpParam::iterlimit"]
        [::std::mem::offset_of!(SCIP_NlpParam, iterlimit) - 40usize];
    ["Offset of field: SCIP_NlpParam::verblevel"]
        [::std::mem::offset_of!(SCIP_NlpParam, verblevel) - 44usize];
    ["Offset of field: SCIP_NlpParam::fastfail"]
        [::std::mem::offset_of!(SCIP_NlpParam, fastfail) - 48usize];
    ["Offset of field: SCIP_NlpParam::expectinfeas"]
        [::std::mem::offset_of!(SCIP_NlpParam, expectinfeas) - 52usize];
    ["Offset of field: SCIP_NlpParam::warmstart"]
        [::std::mem::offset_of!(SCIP_NlpParam, warmstart) - 56usize];
    ["Offset of field: SCIP_NlpParam::caller"]
        [::std::mem::offset_of!(SCIP_NlpParam, caller) - 64usize];
};
#[doc = " parameters for NLP solve"]
pub type SCIP_NLPPARAM = SCIP_NlpParam;
#[doc = "< solved to global optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBOPT: SCIP_NlpSolStat = 0;
#[doc = "< solved to local optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCOPT: SCIP_NlpSolStat = 1;
#[doc = "< feasible solution found"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_FEASIBLE: SCIP_NlpSolStat = 2;
#[doc = "< solution found is local infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCINFEASIBLE: SCIP_NlpSolStat = 3;
#[doc = "< problem is proven infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBINFEASIBLE: SCIP_NlpSolStat = 4;
#[doc = "< problem is unbounded"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNBOUNDED: SCIP_NlpSolStat = 5;
#[doc = "< unknown solution status (e.g., problem not solved yet)"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNKNOWN: SCIP_NlpSolStat = 6;
#[doc = " NLP solution status"]
pub type SCIP_NlpSolStat = ::std::os::raw::c_uint;
#[doc = " NLP solution status"]
pub use self::SCIP_NlpSolStat as SCIP_NLPSOLSTAT;
#[doc = "< terminated successfully"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OKAY: SCIP_NlpTermStat = 0;
#[doc = "< time limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_TIMELIMIT: SCIP_NlpTermStat = 1;
#[doc = "< iteration limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_ITERLIMIT: SCIP_NlpTermStat = 2;
#[doc = "< lower objective limit reached"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LOBJLIMIT: SCIP_NlpTermStat = 3;
#[doc = "< SCIP has been asked to stop (SCIPinterruptSolve() called)"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_INTERRUPT: SCIP_NlpTermStat = 4;
#[doc = "< stopped on numerical error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_NUMERICERROR: SCIP_NlpTermStat = 5;
#[doc = "< stopped on function evaluation error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_EVALERROR: SCIP_NlpTermStat = 6;
#[doc = "< memory exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OUTOFMEMORY: SCIP_NlpTermStat = 7;
#[doc = "< problems with license of NLP solver"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LICENSEERROR: SCIP_NlpTermStat = 8;
#[doc = "< other error (= this should never happen)"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OTHER: SCIP_NlpTermStat = 9;
#[doc = " NLP solver termination status"]
pub type SCIP_NlpTermStat = ::std::os::raw::c_uint;
#[doc = " NLP solver termination status"]
pub use self::SCIP_NlpTermStat as SCIP_NLPTERMSTAT;
#[doc = " Statistics from an NLP solve"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpStatistics {
    #[doc = "< number of iterations the NLP solver spend in the last solve command"]
    pub niterations: ::std::os::raw::c_int,
    #[doc = "< total time in CPU sections the NLP solver spend in the last solve command"]
    pub totaltime: f64,
    #[doc = "< time spend in evaluation of functions and their derivatives (only measured if timing/nlpieval = TRUE)"]
    pub evaltime: f64,
    #[doc = "< maximal absolute constraint violation in current solution, or SCIP_INVALID if not available"]
    pub consviol: f64,
    #[doc = "< maximal absolute variable bound violation in current solution, or SCIP_INVALID if not available"]
    pub boundviol: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_NlpStatistics"][::std::mem::size_of::<SCIP_NlpStatistics>() - 40usize];
    ["Alignment of SCIP_NlpStatistics"][::std::mem::align_of::<SCIP_NlpStatistics>() - 8usize];
    ["Offset of field: SCIP_NlpStatistics::niterations"]
        [::std::mem::offset_of!(SCIP_NlpStatistics, niterations) - 0usize];
    ["Offset of field: SCIP_NlpStatistics::totaltime"]
        [::std::mem::offset_of!(SCIP_NlpStatistics, totaltime) - 8usize];
    ["Offset of field: SCIP_NlpStatistics::evaltime"]
        [::std::mem::offset_of!(SCIP_NlpStatistics, evaltime) - 16usize];
    ["Offset of field: SCIP_NlpStatistics::consviol"]
        [::std::mem::offset_of!(SCIP_NlpStatistics, consviol) - 24usize];
    ["Offset of field: SCIP_NlpStatistics::boundviol"]
        [::std::mem::offset_of!(SCIP_NlpStatistics, boundviol) - 32usize];
};
#[doc = " Statistics from an NLP solve"]
pub type SCIP_NLPSTATISTICS = SCIP_NlpStatistics;
#[doc = "< the solving status is not yet known"]
pub const SCIP_Status_SCIP_STATUS_UNKNOWN: SCIP_Status = 0;
#[doc = "< the problem was solved to optimality, an optimal solution is available"]
pub const SCIP_Status_SCIP_STATUS_OPTIMAL: SCIP_Status = 1;
#[doc = "< the problem was proven to be infeasible"]
pub const SCIP_Status_SCIP_STATUS_INFEASIBLE: SCIP_Status = 2;
#[doc = "< the problem was proven to be unbounded"]
pub const SCIP_Status_SCIP_STATUS_UNBOUNDED: SCIP_Status = 3;
#[doc = "< the problem was proven to be either infeasible or unbounded"]
pub const SCIP_Status_SCIP_STATUS_INFORUNBD: SCIP_Status = 4;
#[doc = "< the user interrupted the solving process (SIGINT or SCIPinterruptSolve())"]
pub const SCIP_Status_SCIP_STATUS_USERINTERRUPT: SCIP_Status = 10;
#[doc = "< the process received a SIGTERM signal"]
pub const SCIP_Status_SCIP_STATUS_TERMINATE: SCIP_Status = 11;
#[doc = "< the solving process was interrupted because the node limit was reached"]
pub const SCIP_Status_SCIP_STATUS_NODELIMIT: SCIP_Status = 20;
#[doc = "< the solving process was interrupted because the total node limit was\n   reached (incl. restarts)"]
pub const SCIP_Status_SCIP_STATUS_TOTALNODELIMIT: SCIP_Status = 21;
#[doc = "< the solving process was interrupted because the stalling node limit was\n   reached (no improvement w.r.t. primal bound)"]
pub const SCIP_Status_SCIP_STATUS_STALLNODELIMIT: SCIP_Status = 22;
#[doc = "< the solving process was interrupted because the time limit was reached"]
pub const SCIP_Status_SCIP_STATUS_TIMELIMIT: SCIP_Status = 23;
#[doc = "< the solving process was interrupted because the memory limit was reached"]
pub const SCIP_Status_SCIP_STATUS_MEMLIMIT: SCIP_Status = 24;
#[doc = "< the solving process was interrupted because the gap limit was reached"]
pub const SCIP_Status_SCIP_STATUS_GAPLIMIT: SCIP_Status = 25;
#[doc = "< the solving process was interrupted because the primal limit was reached"]
pub const SCIP_Status_SCIP_STATUS_PRIMALLIMIT: SCIP_Status = 26;
#[doc = "< the solving process was interrupted because the dual limit was reached"]
pub const SCIP_Status_SCIP_STATUS_DUALLIMIT: SCIP_Status = 27;
#[doc = "< the solving process was interrupted because the solution limit was reached"]
pub const SCIP_Status_SCIP_STATUS_SOLLIMIT: SCIP_Status = 28;
#[doc = "< the solving process was interrupted because the solution improvement limit\n   was reached"]
pub const SCIP_Status_SCIP_STATUS_BESTSOLLIMIT: SCIP_Status = 29;
#[doc = "< the solving process was interrupted because the restart limit was reached"]
pub const SCIP_Status_SCIP_STATUS_RESTARTLIMIT: SCIP_Status = 30;
#[doc = " SCIP solving status"]
pub type SCIP_Status = ::std::os::raw::c_uint;
#[doc = " SCIP solving status"]
pub use self::SCIP_Status as SCIP_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Stat {
    _unused: [u8; 0],
}
pub type SCIP_STAT = SCIP_Stat;
pub const SCIP_Parallelmode_SCIP_PARA_OPPORTUNISTIC: SCIP_Parallelmode = 0;
pub const SCIP_Parallelmode_SCIP_PARA_DETERMINISTIC: SCIP_Parallelmode = 1;
#[doc = " The parallel mode"]
pub type SCIP_Parallelmode = ::std::os::raw::c_uint;
#[doc = " The parallel mode"]
pub use self::SCIP_Parallelmode as SCIP_PARALLELMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncStore {
    _unused: [u8; 0],
}
pub type SCIP_SYNCSTORE = SCIP_SyncStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncData {
    _unused: [u8; 0],
}
pub type SCIP_SYNCDATA = SCIP_SyncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundStore {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDSTORE = SCIP_BoundStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverType {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPE = SCIP_ConcSolverType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverTypeData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPEDATA = SCIP_ConcSolverTypeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolver {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVER = SCIP_ConcSolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERDATA = SCIP_ConcSolverData;
#[doc = "< the Benders' subproblems are solved during the enforcement of an LP solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_LP: SCIP_BendersEnfoType = 1;
#[doc = "< the Benders' subproblems are solved during the enforcement of a relaxation solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_RELAX: SCIP_BendersEnfoType = 2;
#[doc = "< the Benders' subproblems are solved during the enforcement of a pseudo solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_PSEUDO: SCIP_BendersEnfoType = 3;
#[doc = "< the Benders' subproblems are solved during the checking of a solution for feasibility"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_CHECK: SCIP_BendersEnfoType = 4;
pub type SCIP_BendersEnfoType = ::std::os::raw::c_uint;
pub use self::SCIP_BendersEnfoType as SCIP_BENDERSENFOTYPE;
#[doc = "< the relaxation is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CONVEX: SCIP_BendersSolveLoop = 0;
#[doc = "< the CIP is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CIP: SCIP_BendersSolveLoop = 1;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCONVEX: SCIP_BendersSolveLoop = 2;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCIP: SCIP_BendersSolveLoop = 3;
pub type SCIP_BendersSolveLoop = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSolveLoop as SCIP_BENDERSSOLVELOOP;
#[doc = "< the subsystem status is unknown"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_UNKNOWN: SCIP_BendersSubStatus = 0;
#[doc = "< the subsystem is solved to be optimal"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_OPTIMAL: SCIP_BendersSubStatus = 1;
#[doc = "< the subproblem is optimal, but the auxiliary variable is violated"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_AUXVIOL: SCIP_BendersSubStatus = 2;
#[doc = "< the subproblem is solved to be infeasible"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_INFEAS: SCIP_BendersSubStatus = 3;
pub type SCIP_BendersSubStatus = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSubStatus as SCIP_BENDERSSUBSTATUS;
#[doc = "< the subproblem has convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXCONT: SCIP_BendersSubType = 0;
#[doc = "< the subproblem has convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXDIS: SCIP_BendersSubType = 1;
#[doc = "< the subproblem has non-convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXCONT: SCIP_BendersSubType = 2;
#[doc = "< the subproblem has non-convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXDIS: SCIP_BendersSubType = 3;
#[doc = "< the default type before the type is known"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_UNKNOWN: SCIP_BendersSubType = 4;
pub type SCIP_BendersSubType = ::std::os::raw::c_uint;
pub use self::SCIP_BendersSubType as SCIP_BENDERSSUBTYPE;
#[doc = "< the individual subproblem objectives are summed in the master problem"]
pub const SCIP_BendersObjectiveType_SCIP_BENDERSOBJTYPE_SUM: SCIP_BendersObjectiveType = 0;
#[doc = "< the minimum of the maximum subproblem objectives is computed in the master problem"]
pub const SCIP_BendersObjectiveType_SCIP_BENDERSOBJTYPE_MAX: SCIP_BendersObjectiveType = 1;
pub type SCIP_BendersObjectiveType = ::std::os::raw::c_uint;
pub use self::SCIP_BendersObjectiveType as SCIP_BENDERSOBJTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benders {
    _unused: [u8; 0],
}
pub type SCIP_BENDERS = SCIP_Benders;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BendersData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSDATA = SCIP_BendersData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SubproblemSolveStat {
    _unused: [u8; 0],
}
pub type SCIP_SUBPROBLEMSOLVESTAT = SCIP_SubproblemSolveStat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benderscut {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUT = SCIP_Benderscut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BenderscutData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUTDATA = SCIP_BenderscutData;
unsafe extern "C" {
    #[doc = " create and resets an epsilon greedy bandit algorithm"]
    pub fn SCIPcreateBanditEpsgreedy(
        scip: *mut SCIP,
        epsgreedy: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        eps: f64,
        usemodification: ::std::os::raw::c_uint,
        preferrecent: ::std::os::raw::c_uint,
        decayfactor: f64,
        avglim: ::std::os::raw::c_int,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get weights array of epsilon greedy bandit algorithm"]
    pub fn SCIPgetWeightsEpsgreedy(epsgreedy: *mut SCIP_BANDIT) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " set epsilon parameter of epsilon greedy bandit algorithm"]
    pub fn SCIPsetEpsilonEpsgreedy(epsgreedy: *mut SCIP_BANDIT, eps: f64);
}
unsafe extern "C" {
    #[doc = " creates and resets an Exp.3 bandit algorithm using \\p scip pointer"]
    pub fn SCIPcreateBanditExp3(
        scip: *mut SCIP,
        exp3: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        gammaparam: f64,
        beta: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set gamma parameter of Exp.3 bandit algorithm to increase weight of uniform distribution"]
    pub fn SCIPsetGammaExp3(exp3: *mut SCIP_BANDIT, gammaparam: f64);
}
unsafe extern "C" {
    #[doc = " set beta parameter of Exp.3 bandit algorithm to increase gain offset for actions that were not played"]
    pub fn SCIPsetBetaExp3(exp3: *mut SCIP_BANDIT, beta: f64);
}
unsafe extern "C" {
    #[doc = " returns probability to play an action"]
    pub fn SCIPgetProbabilityExp3(exp3: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " creates and resets an Exp.3-IX bandit algorithm using \\p scip pointer"]
    pub fn SCIPcreateBanditExp3IX(
        scip: *mut SCIP,
        exp3ix: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns probability to play an action"]
    pub fn SCIPgetProbabilityExp3IX(exp3ix: *mut SCIP_BANDIT, action: ::std::os::raw::c_int)
    -> f64;
}
unsafe extern "C" {
    #[doc = " create and reset UCB bandit algorithm"]
    pub fn SCIPcreateBanditUcb(
        scip: *mut SCIP,
        ucb: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        alpha: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the upper confidence bound of a selected action"]
    pub fn SCIPgetConfidenceBoundUcb(ucb: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " return start permutation of the UCB bandit algorithm"]
    pub fn SCIPgetStartPermutationUcb(ucb: *mut SCIP_BANDIT) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " select the next action"]
    pub fn SCIPbanditSelect(
        bandit: *mut SCIP_BANDIT,
        action: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " update the score of the selected action"]
    pub fn SCIPbanditUpdate(
        bandit: *mut SCIP_BANDIT,
        action: ::std::os::raw::c_int,
        score: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the name of this bandit virtual function table"]
    pub fn SCIPbanditvtableGetName(
        banditvtable: *mut SCIP_BANDITVTABLE,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " return the random number generator of a bandit algorithm"]
    pub fn SCIPbanditGetRandnumgen(bandit: *mut SCIP_BANDIT) -> *mut SCIP_RANDNUMGEN;
}
unsafe extern "C" {
    #[doc = " return number of actions of this bandit algorithm"]
    pub fn SCIPbanditGetNActions(bandit: *mut SCIP_BANDIT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two benderss w. r. to their priority"]
    pub fn SCIPbendersComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting benderss w.r.t. to their name"]
    pub fn SCIPbendersCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of Benders' decomposition"]
    pub fn SCIPbendersGetData(benders: *mut SCIP_BENDERS) -> *mut SCIP_BENDERSDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of Benders' decomposition; user has to free old data in advance!"]
    pub fn SCIPbendersSetData(benders: *mut SCIP_BENDERS, bendersdata: *mut SCIP_BENDERSDATA);
}
unsafe extern "C" {
    #[doc = " gets name of Benders' decomposition"]
    pub fn SCIPbendersGetName(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of Benders' decomposition"]
    pub fn SCIPbendersGetDesc(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of Benders' decomposition"]
    pub fn SCIPbendersGetPriority(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of subproblems for the Benders' decomposition"]
    pub fn SCIPbendersGetNSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the SCIP instance for a given subproblem"]
    pub fn SCIPbendersSubproblem(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the Bender' decomposition was called and tried to find a violated second stage constraint"]
    pub fn SCIPbendersGetNCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of optimality cuts found by the collection of Benders' decomposition subproblems"]
    pub fn SCIPbendersGetNCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of cuts found from the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of calls to the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of calls to the strengthening round that fail"]
    pub fn SCIPbendersGetNStrengthenFails(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition for setting up for next stages"]
    pub fn SCIPbendersGetSetupTime(benders: *mut SCIP_BENDERS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets execution time in seconds used in this Benders' decomposition"]
    pub fn SCIPbendersGetTime(benders: *mut SCIP_BENDERS) -> f64;
}
unsafe extern "C" {
    #[doc = " Is Benders' decomposition initialized?"]
    pub fn SCIPbendersIsInitialized(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the given Benders' decomposition is in use in the current problem"]
    pub fn SCIPbendersIsActive(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Returns whether only the convex relaxations will be checked in this solve loop\n  when Benders' is used in the LNS heuristics, only the convex relaxations of the master/subproblems are checked,\n  i.e. no integer cuts are generated. In this case, then Benders' decomposition is performed under the assumption\n  that all subproblems are convex relaxations."]
    pub fn SCIPbendersOnlyCheckConvexRelax(
        benders: *mut SCIP_BENDERS,
        subscipsoff: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns NLP solver parameters used for solving NLP subproblems"]
    pub fn SCIPbendersGetNLPParam(benders: *mut SCIP_BENDERS) -> SCIP_NLPPARAM;
}
unsafe extern "C" {
    #[doc = " Are Benders' cuts generated from the LP solutions?"]
    pub fn SCIPbendersCutLP(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Are Benders' cuts generated from the pseudo solutions?"]
    pub fn SCIPbendersCutPseudo(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Are Benders' cuts generated from the relaxation solutions?"]
    pub fn SCIPbendersCutRelaxation(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Should this Benders' use the auxiliary variables from the highest priority Benders'?"]
    pub fn SCIPbendersShareAuxVars(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the subproblem setup flag"]
    pub fn SCIPbendersSetSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        issetup: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the subproblem setup flag"]
    pub fn SCIPbendersSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the master auxiliary variable that represents an underestimation of the subproblem objective value."]
    pub fn SCIPbenderGetMasterAuxiliaryVar(benders: *mut SCIP_BENDERS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the auxiliary variable for the given subproblem"]
    pub fn SCIPbendersGetAuxiliaryVar(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns all auxiliary variables"]
    pub fn SCIPbendersGetAuxiliaryVars(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the subproblem master variables for the given subproblem"]
    pub fn SCIPbendersGetSubproblemMasterVars(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the number of subproblem master variables for the given subproblem"]
    pub fn SCIPbendersGetNSubproblemMasterVars(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the subproblem master variable data for the given subproblem"]
    pub fn SCIPbendersGetSubproblemMasterVarsData(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " stores the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersSetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        objval: f64,
    );
}
unsafe extern "C" {
    #[doc = " returns the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersGetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the number of cuts that have been added for storage"]
    pub fn SCIPbendersGetNStoredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the data for the cuts that have been added by the Benders' cut plugin"]
    pub fn SCIPbendersGetStoredCutData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the original problem data for the cuts that have been added by the Benders' cut plugin. The stored\n  variables and values will populate the input vars and vals arrays. Thus, memory must be allocated for the vars and\n  vals arrays"]
    pub fn SCIPbendersGetStoredCutOrigData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the Benders' cut of the given name, or NULL if not existing"]
    pub fn SCIPfindBenderscut(
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERSCUT;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available Benders' cuts; active Benders' decomposition are in the first slots of\n the array"]
    pub fn SCIPbendersGetBenderscuts(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_BENDERSCUT;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available Benders' cuts"]
    pub fn SCIPbendersGetNBenderscuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPbendersSetBenderscutPriority(
        benders: *mut SCIP_BENDERS,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the solution has non-zero slack variables"]
    pub fn SCIPbendersSolSlackVarsActive(
        benders: *mut SCIP_BENDERS,
        activeslack: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the subproblem type\n\n The subproblem types are:\n    - Convex constraints with continuous variables\n    - Convex constraints with discrete variables\n    - Non-convex constraints with continuous variables\n    - Non-convex constraints with discrete variables"]
    pub fn SCIPbendersSetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        subprobtype: SCIP_BENDERSSUBTYPE,
    );
}
unsafe extern "C" {
    #[doc = " returns the type of the subproblem\n\n  This type is used to determine whether the duals of the problem can be used to generate cuts"]
    pub fn SCIPbendersGetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_BENDERSSUBTYPE;
}
unsafe extern "C" {
    #[doc = " sets the flag indicating whether a subproblem is convex\n\n  It is possible that this can change during the solving process. One example is when the three-phase method is\n  employed, where the first phase solves the convex relaxation of both the master and subproblems, the second phase\n  reintroduces the integrality constraints to the master problem and the third phase then reintroduces integrality\n  constraints to the subproblems."]
    pub fn SCIPbendersSetSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isconvex: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns whether the subproblem is convex\n\n  This means that the dual solution can be used to generate cuts."]
    pub fn SCIPbendersSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of subproblems that are convex"]
    pub fn SCIPbendersGetNConvexSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the flag indicating whether a subproblem contains non-linear constraints"]
    pub fn SCIPbendersSetSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns whether the subproblem contains non-linear constraints."]
    pub fn SCIPbendersSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of subproblems that contain non-linear constraints"]
    pub fn SCIPbendersGetNNonlinearSubproblems(benders: *mut SCIP_BENDERS)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the flag indicating whether the master problem contains non-linear constraints"]
    pub fn SCIPbendersSetMasterIsNonlinear(
        benders: *mut SCIP_BENDERS,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns whether the master problem contains non-linear constraints."]
    pub fn SCIPbendersMasterIsNonlinear(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the objective type for the aggregation of the Benders' decomposition subproblem objectives"]
    pub fn SCIPbendersGetObjectiveType(benders: *mut SCIP_BENDERS) -> SCIP_BENDERSOBJTYPE;
}
unsafe extern "C" {
    #[doc = " returns the flag indicating that Benders' decomposition is in a cut strengthening round"]
    pub fn SCIPbendersInStrengthenRound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether at least one of the subproblems has been identified as infeasible.\n  NOTE: this is without any variable fixing being performed"]
    pub fn SCIPbendersSubproblemsAreInfeasible(
        benders: *mut SCIP_BENDERS,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " solves the LP of the Benders' decomposition subproblem\n\n  This requires that the subproblem is in probing mode."]
    pub fn SCIPbendersSolveSubproblemLP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the Benders' decomposition subproblem"]
    pub fn SCIPbendersSolveSubproblemCIP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        solvecip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of cuts that have been transferred from sub SCIPs to the master SCIP"]
    pub fn SCIPbendersGetNTransferredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " updates the lower bound for the subproblem. If the lower bound is not greater than the previously stored lowerbound,\n then no update occurs."]
    pub fn SCIPbendersUpdateSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: f64,
    );
}
unsafe extern "C" {
    #[doc = " returns the stored lower bound for the given subproblem"]
    pub fn SCIPbendersGetSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the independent subproblem flag"]
    pub fn SCIPbendersSetSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isindep: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns whether the subproblem is independent"]
    pub fn SCIPbendersSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the subproblem is enabled, i.e. the subproblem is still solved in the solving loop."]
    pub fn SCIPbendersSubproblemIsEnabled(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two Benders' decomposition cuts w. r. to their priority"]
    pub fn SCIPbenderscutComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting Benders' decomposition cuts w.r.t. to their name"]
    pub fn SCIPbenderscutCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetData(benderscut: *mut SCIP_BENDERSCUT) -> *mut SCIP_BENDERSCUTDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of the Benders' decomposition cut; user has to free old data in advance!"]
    pub fn SCIPbenderscutSetData(
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    );
}
unsafe extern "C" {
    #[doc = " gets name of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetName(benderscut: *mut SCIP_BENDERSCUT)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetDesc(benderscut: *mut SCIP_BENDERSCUT)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetPriority(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the Benders' decomposition cut was called and tried to find a violated cut"]
    pub fn SCIPbenderscutGetNCalls(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of the cuts found by this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetNFound(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " is the Benders' decomposition cut initialized?"]
    pub fn SCIPbenderscutIsInitialized(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut for setting up for next stages"]
    pub fn SCIPbenderscutGetSetupTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the Benders' cut uses the LP information"]
    pub fn SCIPbenderscutIsLPCut(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the enabled flag of the Benders' decomposition cut method"]
    pub fn SCIPbenderscutSetEnabled(
        benderscut: *mut SCIP_BENDERSCUT,
        enabled: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " compares two branching rules w. r. to their priority"]
    pub fn SCIPbranchruleComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting branching rules w.r.t. to their name"]
    pub fn SCIPbranchruleCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of branching rule"]
    pub fn SCIPbranchruleGetData(branchrule: *mut SCIP_BRANCHRULE) -> *mut SCIP_BRANCHRULEDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of branching rule; user has to free old data in advance!"]
    pub fn SCIPbranchruleSetData(
        branchrule: *mut SCIP_BRANCHRULE,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    );
}
unsafe extern "C" {
    #[doc = " marks this branching rule as safe to use in exact solving mode"]
    pub fn SCIPbranchruleMarkExact(branchrule: *mut SCIP_BRANCHRULE);
}
unsafe extern "C" {
    #[doc = " gets name of branching rule"]
    pub fn SCIPbranchruleGetName(branchrule: *mut SCIP_BRANCHRULE)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of branching rule"]
    pub fn SCIPbranchruleGetDesc(branchrule: *mut SCIP_BRANCHRULE)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of branching rule"]
    pub fn SCIPbranchruleGetPriority(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPbranchruleGetMaxdepth(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPbranchruleGetMaxbounddist(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this branching rule for setting up for next stages"]
    pub fn SCIPbranchruleGetSetupTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this branching rule"]
    pub fn SCIPbranchruleGetTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on an LP solution"]
    pub fn SCIPbranchruleGetNLPCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on external candidates"]
    pub fn SCIPbranchruleGetNExternCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on a pseudo solution"]
    pub fn SCIPbranchruleGetNPseudoCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the branching rule detected a cutoff"]
    pub fn SCIPbranchruleGetNCutoffs(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cuts, the branching rule separated"]
    pub fn SCIPbranchruleGetNCutsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of constraints, the branching rule added to the respective local nodes (not counting constraints\n  that were added to the child nodes as branching decisions)"]
    pub fn SCIPbranchruleGetNConssFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of domain reductions, the branching rule found"]
    pub fn SCIPbranchruleGetNDomredsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of children, the branching rule created"]
    pub fn SCIPbranchruleGetNChildren(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " is branching rule initialized?"]
    pub fn SCIPbranchruleIsInitialized(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two conflict handlers w. r. to their priority"]
    pub fn SCIPconflicthdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting conflict handler w.r.t. to their name"]
    pub fn SCIPconflicthdlrCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of conflict handler"]
    pub fn SCIPconflicthdlrGetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *mut SCIP_CONFLICTHDLRDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of conflict handler; user has to free old data in advance!"]
    pub fn SCIPconflicthdlrSetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    );
}
unsafe extern "C" {
    #[doc = " gets name of conflict handler"]
    pub fn SCIPconflicthdlrGetName(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of conflict handler"]
    pub fn SCIPconflicthdlrGetDesc(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of conflict handler"]
    pub fn SCIPconflicthdlrGetPriority(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " is conflict handler initialized?"]
    pub fn SCIPconflicthdlrIsInitialized(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this conflict handler for setting up for next stages"]
    pub fn SCIPconflicthdlrGetSetupTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this conflict handler"]
    pub fn SCIPconflicthdlrGetTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " compares two constraint handlers w.r.t. their separation priority"]
    pub fn SCIPconshdlrCompSepa(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two constraint handlers w.r.t. their enforcing priority"]
    pub fn SCIPconshdlrCompEnfo(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two constraint handlers w.r.t. their feasibility check priority"]
    pub fn SCIPconshdlrCompCheck(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two constraints w.r.t. their feasibility check priority"]
    pub fn SCIPconsCompCheck(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets name of constraint handler"]
    pub fn SCIPconshdlrGetName(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of constraint handler"]
    pub fn SCIPconshdlrGetDesc(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets user data of constraint handler"]
    pub fn SCIPconshdlrGetData(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_CONSHDLRDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of constraint handler; user has to free old data in advance!"]
    pub fn SCIPconshdlrSetData(conshdlr: *mut SCIP_CONSHDLR, conshdlrdata: *mut SCIP_CONSHDLRDATA);
}
unsafe extern "C" {
    #[doc = " is constraint handler safe to use in exact solving mode?"]
    pub fn SCIPconshdlrIsExact(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the constraint handler as safe to use in exact solving mode\n\n  @note Constraint handlers that are not marked as exact are skipped during exact solving mode."]
    pub fn SCIPconshdlrMarkExact(conshdlr: *mut SCIP_CONSHDLR);
}
unsafe extern "C" {
    #[doc = " sets all separation related callbacks of the constraint handler"]
    pub fn SCIPconshdlrSetSepa(
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler"]
    pub fn SCIPconshdlrSetProp(
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
    );
}
unsafe extern "C" {
    #[doc = " sets the relaxation enforcement method of the constraint handler"]
    pub fn SCIPconshdlrSetEnforelax(
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " gets array with constraints of constraint handler; the first SCIPconshdlrGetNActiveConss() entries are the active\n  constraints, the last SCIPconshdlrGetNConss() - SCIPconshdlrGetNActiveConss() constraints are deactivated\n\n  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local\n        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets array with enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets array with checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets array with delayed update constraints\n\n @attention Usually, there should be no need to access this array. Use this only if you are absolutely sure what you are doing."]
    pub fn SCIPconshdlrGetUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets total number of existing transformed constraints of constraint handler"]
    pub fn SCIPconshdlrGetNConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of active constraints of constraint handler\n\n  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local\n        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of enabled constraints of constraint handler"]
    pub fn SCIPconshdlrGetNEnabledConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints that have delayed updates"]
    pub fn SCIPconshdlrGetNUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for setting up this constraint handler for new stages"]
    pub fn SCIPconshdlrGetSetupTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for presolving in this constraint handler"]
    pub fn SCIPconshdlrGetPresolTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for separation in this constraint handler"]
    pub fn SCIPconshdlrGetSepaTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for LP enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoLPTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for pseudo enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoPSTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for relaxation enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoRelaxTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler"]
    pub fn SCIPconshdlrGetPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler during strong branching"]
    pub fn SCIPconshdlrGetStrongBranchPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for feasibility checking in this constraint handler"]
    pub fn SCIPconshdlrGetCheckTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for resolving propagation in this constraint handler"]
    pub fn SCIPconshdlrGetRespropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's separation method"]
    pub fn SCIPconshdlrGetNSepaCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's LP enforcing method"]
    pub fn SCIPconshdlrGetNEnfoLPCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's pseudo enforcing method"]
    pub fn SCIPconshdlrGetNEnfoPSCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's relaxation enforcing method"]
    pub fn SCIPconshdlrGetNEnfoRelaxCalls(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's propagation method"]
    pub fn SCIPconshdlrGetNPropCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's checking method"]
    pub fn SCIPconshdlrGetNCheckCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the constraint handler's resolve propagation method"]
    pub fn SCIPconshdlrGetNRespropCalls(conshdlr: *mut SCIP_CONSHDLR)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of times, this constraint handler detected a cutoff"]
    pub fn SCIPconshdlrGetNCutoffs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler"]
    pub fn SCIPconshdlrGetNCutsFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler applied to lp"]
    pub fn SCIPconshdlrGetNCutsApplied(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of additional constraints added by this constraint handler"]
    pub fn SCIPconshdlrGetNConssFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of domain reductions found by this constraint handler"]
    pub fn SCIPconshdlrGetNDomredsFound(conshdlr: *mut SCIP_CONSHDLR)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of children created by this constraint handler"]
    pub fn SCIPconshdlrGetNChildren(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets maximum number of active constraints of constraint handler existing at the same time"]
    pub fn SCIPconshdlrGetMaxNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets initial number of active constraints of constraint handler"]
    pub fn SCIPconshdlrGetStartNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variables fixed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNFixedVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variables aggregated in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAggrVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variable types changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgVarTypes(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of bounds changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgBds(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddHoles(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints deleted in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNDelConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints added in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints upgraded in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNUpgdConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of coefficients changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgCoefs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraint sides changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgSides(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of times the presolving method of the constraint handler was called and tried to find reductions"]
    pub fn SCIPconshdlrGetNPresolCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets separation priority of constraint handler"]
    pub fn SCIPconshdlrGetSepaPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets enforcing priority of constraint handler"]
    pub fn SCIPconshdlrGetEnfoPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets checking priority of constraint handler"]
    pub fn SCIPconshdlrGetCheckPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets separation frequency of constraint handler"]
    pub fn SCIPconshdlrGetSepaFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets propagation frequency of constraint handler"]
    pub fn SCIPconshdlrGetPropFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets frequency of constraint handler for eager evaluations in separation, propagation and enforcement"]
    pub fn SCIPconshdlrGetEagerFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " does the constraint handler need a constraint in order to be called?"]
    pub fn SCIPconshdlrNeedsCons(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the needscons flag of constraint handler, for example to disable without constraints"]
    pub fn SCIPconshdlrSetNeedsCons(
        conshdlr: *mut SCIP_CONSHDLR,
        needscons: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " does the constraint handler perform presolving?"]
    pub fn SCIPconshdlrDoesPresolve(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " should separation method be delayed, if other separators found cuts?"]
    pub fn SCIPconshdlrIsSeparationDelayed(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " should propagation method be delayed, if other propagators found reductions?"]
    pub fn SCIPconshdlrIsPropagationDelayed(conshdlr: *mut SCIP_CONSHDLR)
    -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was LP separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasLPSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was primal solution separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasSolSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was propagation method delayed at the last call?"]
    pub fn SCIPconshdlrWasPropagationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is constraint handler initialized?"]
    pub fn SCIPconshdlrIsInitialized(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " does the constraint handler have a copy function?"]
    pub fn SCIPconshdlrIsClonable(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrGetPropTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PROPTIMING;
}
unsafe extern "C" {
    #[doc = " gets added constraints data for a constraint set change"]
    pub fn SCIPconssetchgGetAddedConsData(
        conssetchg: *mut SCIP_CONSSETCHG,
        conss: *mut *mut *mut SCIP_CONS,
        nconss: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrSetPropTiming(conshdlr: *mut SCIP_CONSHDLR, proptiming: SCIP_PROPTIMING);
}
unsafe extern "C" {
    #[doc = " returns the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrGetPresolTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PRESOLTIMING;
}
unsafe extern "C" {
    #[doc = " sets the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrSetPresolTiming(
        conshdlr: *mut SCIP_CONSHDLR,
        presoltiming: SCIP_PRESOLTIMING,
    );
}
unsafe extern "C" {
    #[doc = " returns whether conshdlr supports permutation symmetry detection"]
    pub fn SCIPconshdlrSupportsPermsymDetection(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether conshdlr supports signed permutation symmetry detection"]
    pub fn SCIPconshdlrSupportsSignedPermsymDetection(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the name of the constraint\n\n  @note to change the name of a constraint, use SCIPchgConsName() from scip.h"]
    pub fn SCIPconsGetName(cons: *mut SCIP_CONS) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns the position of constraint in the corresponding handler's conss array"]
    pub fn SCIPconsGetPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the constraint handler of the constraint"]
    pub fn SCIPconsGetHdlr(cons: *mut SCIP_CONS) -> *mut SCIP_CONSHDLR;
}
unsafe extern "C" {
    #[doc = " returns the constraint data field of the constraint"]
    pub fn SCIPconsGetData(cons: *mut SCIP_CONS) -> *mut SCIP_CONSDATA;
}
unsafe extern "C" {
    #[doc = " gets number of times, the constraint is currently captured"]
    pub fn SCIPconsGetNUses(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " for an active constraint, returns the depth in the tree at which the constraint was activated"]
    pub fn SCIPconsGetActiveDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the depth in the tree at which the constraint is valid; returns INT_MAX, if the constraint is local\n  and currently not active"]
    pub fn SCIPconsGetValidDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is active in the current node"]
    pub fn SCIPconsIsActive(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint has to be deactivated in update phase"]
    pub fn SCIPconsIsUpdatedeactivate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is enabled in the current node"]
    pub fn SCIPconsIsEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint's separation is enabled in the current node"]
    pub fn SCIPconsIsSeparationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint's propagation is enabled in the current node"]
    pub fn SCIPconsIsPropagationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is deleted or marked to be deleted"]
    pub fn SCIPconsIsDeleted(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is marked obsolete"]
    pub fn SCIPconsIsObsolete(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is marked as a conflict"]
    pub fn SCIPconsIsConflict(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets age of constraint"]
    pub fn SCIPconsGetAge(cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff the LP relaxation of constraint should be in the initial LP"]
    pub fn SCIPconsIsInitial(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint should be separated during LP processing"]
    pub fn SCIPconsIsSeparated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint should be enforced during node processing"]
    pub fn SCIPconsIsEnforced(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint should be checked for feasibility"]
    pub fn SCIPconsIsChecked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the constraint is marked for propagation"]
    pub fn SCIPconsIsMarkedPropagate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint should be propagated during node processing"]
    pub fn SCIPconsIsPropagated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is globally valid"]
    pub fn SCIPconsIsGlobal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is only locally valid or not added to any (sub)problem"]
    pub fn SCIPconsIsLocal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is modifiable (subject to column generation)"]
    pub fn SCIPconsIsModifiable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is subject to aging"]
    pub fn SCIPconsIsDynamic(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsRemovable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsStickingAtNode(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint belongs to the global problem"]
    pub fn SCIPconsIsInProb(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to original space"]
    pub fn SCIPconsIsOriginal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to transformed space"]
    pub fn SCIPconsIsTransformed(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint are locked"]
    pub fn SCIPconsIsLockedPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsIsLockedNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLocked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " get number of times the roundings for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of times the roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLockedType(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns if the constraint was already added to a SCIP instance"]
    pub fn SCIPconsIsAdded(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " adds locks to (dis-)allow upgrading of constraint"]
    pub fn SCIPconsAddUpgradeLocks(cons: *mut SCIP_CONS, nlocks: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " gets number of locks against upgrading the constraint, 0 means this constraint can be upgraded"]
    pub fn SCIPconsGetNUpgradeLocks(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " create linear constraint statistics"]
    pub fn SCIPlinConsStatsCreate(
        scip: *mut SCIP,
        linconsstats: *mut *mut SCIP_LINCONSSTATS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " free linear constraint statistics"]
    pub fn SCIPlinConsStatsFree(scip: *mut SCIP, linconsstats: *mut *mut SCIP_LINCONSSTATS);
}
unsafe extern "C" {
    #[doc = " resets linear constraint statistics"]
    pub fn SCIPlinConsStatsReset(linconsstats: *mut SCIP_LINCONSSTATS);
}
unsafe extern "C" {
    #[doc = " returns the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsGetTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the total number of classified constraints"]
    pub fn SCIPlinConsStatsGetSum(linconsstats: *mut SCIP_LINCONSSTATS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " increases the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsIncTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
        increment: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " print linear constraint classification statistics"]
    pub fn SCIPprintLinConsStats(
        scip: *mut SCIP,
        file: *mut FILE,
        linconsstats: *mut SCIP_LINCONSSTATS,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cutpool {
    _unused: [u8; 0],
}
pub type SCIP_CUTPOOL = SCIP_Cutpool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cut {
    _unused: [u8; 0],
}
pub type SCIP_CUT = SCIP_Cut;
unsafe extern "C" {
    #[doc = " gets the row of the cut"]
    pub fn SCIPcutGetRow(cut: *mut SCIP_CUT) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets the age of the cut: the number of consecutive cut pool separation rounds where the cut was neither in the LP nor violated"]
    pub fn SCIPcutGetAge(cut: *mut SCIP_CUT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the ratio of LPs where the row belonging to this cut was active in an LP solution, i.e.\n  where the age of its row has not been increased\n\n  @see SCIPcutGetAge() to get the age of a cut"]
    pub fn SCIPcutGetLPActivityQuot(cut: *mut SCIP_CUT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets array of cuts in the cut pool"]
    pub fn SCIPcutpoolGetCuts(cutpool: *mut SCIP_CUTPOOL) -> *mut *mut SCIP_CUT;
}
unsafe extern "C" {
    #[doc = " get number of cuts in the cut pool"]
    pub fn SCIPcutpoolGetNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get maximum number of cuts that were stored in the cut pool at the same time"]
    pub fn SCIPcutpoolGetMaxNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for separating cuts from the pool"]
    pub fn SCIPcutpoolGetTime(cutpool: *mut SCIP_CUTPOOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get number of times the cut pool was separated"]
    pub fn SCIPcutpoolGetNCalls(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get number of times the cut pool was separated at the root"]
    pub fn SCIPcutpoolGetNRootCalls(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of cuts that were separated from the cut pool"]
    pub fn SCIPcutpoolGetNCutsFound(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of cuts that were added from the cut pool to sepastore"]
    pub fn SCIPcutpoolGetNCutsAdded(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Decomp {
    _unused: [u8; 0],
}
pub type SCIP_DECOMP = SCIP_Decomp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DecompStore {
    _unused: [u8; 0],
}
pub type SCIP_DECOMPSTORE = SCIP_DecompStore;
unsafe extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPdecompCreate(
        decomp: *mut *mut SCIP_DECOMP,
        blkmem: *mut BMS_BLKMEM,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPdecompFree(decomp: *mut *mut SCIP_DECOMP, blkmem: *mut BMS_BLKMEM);
}
unsafe extern "C" {
    #[doc = " returns TRUE if decomposition is in the original space"]
    pub fn SCIPdecompIsOriginal(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the parameter that indicates whether the variables must be labeled for the application of Benders'\n decomposition"]
    pub fn SCIPdecompSetUseBendersLabels(
        decomp: *mut SCIP_DECOMP,
        benderslabels: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns TRUE if the variables must be labeled for the application of Benders' decomposition"]
    pub fn SCIPdecompUseBendersLabels(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets number of blocks of this decomposition"]
    pub fn SCIPdecompGetNBlocks(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets area score of this decomposition"]
    pub fn SCIPdecompGetAreaScore(decomp: *mut SCIP_DECOMP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets modularity of this decomposition"]
    pub fn SCIPdecompGetModularity(decomp: *mut SCIP_DECOMP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets variable size for each block, sorted by increasing block label\n\n To get all variable sizes, set nlabels to SCIPdecompGetNBlocks() + 1.\n The first entry corresponds to the number of border variables.\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetVarsSize(
        decomp: *mut SCIP_DECOMP,
        varssize: *mut ::std::os::raw::c_int,
        nlabels: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets constraint size for each block, sorted by increasing block label\n\n To get all constraint sizes, set nlabels to SCIPdecompGetNBlocks() + 1.\n The first entry corresponds to the number of border constraints.\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetConssSize(
        decomp: *mut SCIP_DECOMP,
        consssize: *mut ::std::os::raw::c_int,
        nlabels: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of border variables of this decomposition\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetNBorderVars(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of border constraints of this decomposition\n\n @note Ensure that SCIPcomputeDecompStats() has been called before.\n       If the decomposition was read from a file, this was done automatically."]
    pub fn SCIPdecompGetNBorderConss(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of edges in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphEdges(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of connected components in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphComponents(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of articulation points in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphArticulations(decomp: *mut SCIP_DECOMP)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the maximum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMaxDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the minimum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMinDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets labels for an array of variables"]
    pub fn SCIPdecompSetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " queries labels for an array of variables"]
    pub fn SCIPdecompGetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets labels for an array of constraints"]
    pub fn SCIPdecompSetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " queries labels for an array of constraints"]
    pub fn SCIPdecompGetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " clears the corresponding labeling (constraints, variables, or both) of this decomposition"]
    pub fn SCIPdecompClear(
        decomp: *mut SCIP_DECOMP,
        clearvarlabels: ::std::os::raw::c_uint,
        clearconslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints decomposition statistics into string buffer"]
    pub fn SCIPdecompPrintStats(
        decomp: *mut SCIP_DECOMP,
        strbuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "@addtogroup PublicDialogMethods\n\n @{\n/\n/** returns the root dialog of the dialog handler"]
    pub fn SCIPdialoghdlrGetRoot(dialoghdlr: *mut SCIP_DIALOGHDLR) -> *mut SCIP_DIALOG;
}
unsafe extern "C" {
    #[doc = " clears the input command buffer of the dialog handler"]
    pub fn SCIPdialoghdlrClearBuffer(dialoghdlr: *mut SCIP_DIALOGHDLR);
}
unsafe extern "C" {
    #[doc = " returns TRUE iff input command buffer is empty"]
    pub fn SCIPdialoghdlrIsBufferEmpty(dialoghdlr: *mut SCIP_DIALOGHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the next line in the handler's command buffer; if the buffer is empty, displays the given prompt or the\n  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputline: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the next word in the handler's command buffer; if the buffer is empty, displays the given prompt or the\n  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetWord(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputword: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a single line of input to the dialog handler which is treated as if the user entered the command line"]
    pub fn SCIPdialoghdlrAddInputLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a command to the command history of the dialog handler; if a dialog is given, the command is preceeded\n  by the dialog's command path; if no command is given, only the path to the dialog is added to the command history"]
    pub fn SCIPdialoghdlrAddHistory(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        command: *const ::std::os::raw::c_char,
        escapecommand: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff a dialog entry matching exactly the given name is existing in the given dialog"]
    pub fn SCIPdialogHasEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " searches the dialog for entries corresponding to the given name;\n  If a complete match is found, the entry is returned as \"subdialog\" and\n  the return value is 1.\n  If no dialog entry completely matches the given \"entryname\", the number\n  of entries with names beginning with \"entryname\" is returned. If this\n  number is 1, the single match is returned as \"subdialog\". Otherwise,\n  \"subdialog\" is set to NULL."]
    pub fn SCIPdialogFindEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
        subdialog: *mut *mut SCIP_DIALOG,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " displays the dialog's menu"]
    pub fn SCIPdialogDisplayMenu(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " displays the entry for the dialog in it's parent's menu"]
    pub fn SCIPdialogDisplayMenuEntry(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " displays all dialog entries with names starting with the given \"entryname\""]
    pub fn SCIPdialogDisplayCompletions(
        dialog: *mut SCIP_DIALOG,
        scip: *mut SCIP,
        entryname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the name of the current path in the dialog tree, separated by the given character"]
    pub fn SCIPdialogGetPath(
        dialog: *mut SCIP_DIALOG,
        sepchar: ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " gets the command name of the dialog"]
    pub fn SCIPdialogGetName(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets the description of the dialog"]
    pub fn SCIPdialogGetDesc(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether the dialog is a sub menu"]
    pub fn SCIPdialogIsSubmenu(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the parent dialog of the given dialog"]
    pub fn SCIPdialogGetParent(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOG;
}
unsafe extern "C" {
    #[doc = " gets the array of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetSubdialogs(dialog: *mut SCIP_DIALOG) -> *mut *mut SCIP_DIALOG;
}
unsafe extern "C" {
    #[doc = " gets the number of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetNSubdialogs(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the user defined data associated with the given dialog"]
    pub fn SCIPdialogGetData(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOGDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of dialog; user has to free old data in advance!"]
    pub fn SCIPdialogSetData(dialog: *mut SCIP_DIALOG, dialogdata: *mut SCIP_DIALOGDATA);
}
unsafe extern "C" {
    #[doc = " is dialog hidden"]
    pub fn SCIPdialogIsHidden(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " set dialog to be hidden"]
    pub fn SCIPdialogSetHidden(dialog: *mut SCIP_DIALOG);
}
unsafe extern "C" {
    #[doc = " writes command history to specified filename"]
    pub fn SCIPdialogWriteHistory(filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
#[doc = "< only error and warning messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NONE: SCIP_VerbLevel = 0;
#[doc = "< only interactive dialogs, errors, and warnings are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_DIALOG: SCIP_VerbLevel = 1;
#[doc = "< only important messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_MINIMAL: SCIP_VerbLevel = 2;
#[doc = "< standard messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NORMAL: SCIP_VerbLevel = 3;
#[doc = "< a lot of information is displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_HIGH: SCIP_VerbLevel = 4;
#[doc = "< all messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_FULL: SCIP_VerbLevel = 5;
#[doc = " verbosity levels of output"]
pub type SCIP_VerbLevel = ::std::os::raw::c_uint;
#[doc = " verbosity levels of output"]
pub use self::SCIP_VerbLevel as SCIP_VERBLEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Messagehdlr {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLR = SCIP_Messagehdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MessagehdlrData {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLRDATA = SCIP_MessagehdlrData;
unsafe extern "C" {
    #[doc = " gets user data of display column"]
    pub fn SCIPdispGetData(disp: *mut SCIP_DISP) -> *mut SCIP_DISPDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of display column; user has to free old data in advance!"]
    pub fn SCIPdispSetData(disp: *mut SCIP_DISP, dispdata: *mut SCIP_DISPDATA);
}
unsafe extern "C" {
    #[doc = " gets name of display column"]
    pub fn SCIPdispGetName(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of display column"]
    pub fn SCIPdispGetDesc(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets head line of display column"]
    pub fn SCIPdispGetHeader(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets width of display column"]
    pub fn SCIPdispGetWidth(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets priority of display column"]
    pub fn SCIPdispGetPriority(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets position of display column"]
    pub fn SCIPdispGetPosition(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets status of display column"]
    pub fn SCIPdispGetStatus(disp: *mut SCIP_DISP) -> SCIP_DISPSTATUS;
}
unsafe extern "C" {
    #[doc = " is display column initialized?"]
    pub fn SCIPdispIsInitialized(disp: *mut SCIP_DISP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " displays a long integer in decimal form fitting in a given width"]
    pub fn SCIPdispLongint(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_longlong,
        width: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " displays an integer in decimal form fitting in a given width"]
    pub fn SCIPdispInt(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " displays a time value fitting in a given width"]
    pub fn SCIPdispTime(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " gets name of event handler"]
    pub fn SCIPeventhdlrGetName(eventhdlr: *mut SCIP_EVENTHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets user data of event handler"]
    pub fn SCIPeventhdlrGetData(eventhdlr: *mut SCIP_EVENTHDLR) -> *mut SCIP_EVENTHDLRDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of event handler; user has to free old data in advance!"]
    pub fn SCIPeventhdlrSetData(
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    );
}
unsafe extern "C" {
    #[doc = " is event handler initialized?"]
    pub fn SCIPeventhdlrIsInitialized(eventhdlr: *mut SCIP_EVENTHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this event handler for setting up for next stages"]
    pub fn SCIPeventhdlrGetSetupTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this event handler"]
    pub fn SCIPeventhdlrGetTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets type of event"]
    pub fn SCIPeventGetType(event: *mut SCIP_EVENT) -> SCIP_EVENTTYPE;
}
unsafe extern "C" {
    #[doc = " gets variable for a variable event (var added, var deleted, var fixed,\n  objective value or domain change, domain hole added or removed)"]
    pub fn SCIPeventGetVar(event: *mut SCIP_EVENT) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets old objective value for an objective value change event"]
    pub fn SCIPeventGetOldobj(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets new objective value for an objective value change event"]
    pub fn SCIPeventGetNewobj(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets old bound for a bound change event"]
    pub fn SCIPeventGetOldbound(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets exact old bound for a bound change event"]
    pub fn SCIPeventGetOldboundExact(event: *mut SCIP_EVENT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets new bound for a bound change event"]
    pub fn SCIPeventGetNewbound(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets old variable type for a variable type change event"]
    pub fn SCIPeventGetOldtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
unsafe extern "C" {
    #[doc = " gets new variable type for a variable type change event"]
    pub fn SCIPeventGetNewtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
unsafe extern "C" {
    #[doc = " gets old implied integral type for an implied integral type change event"]
    pub fn SCIPeventGetOldImpltype(event: *mut SCIP_EVENT) -> SCIP_IMPLINTTYPE;
}
unsafe extern "C" {
    #[doc = " gets new implied integral type for an implied integral type change event"]
    pub fn SCIPeventGetNewImpltype(event: *mut SCIP_EVENT) -> SCIP_IMPLINTTYPE;
}
unsafe extern "C" {
    #[doc = " gets node for a node or LP event"]
    pub fn SCIPeventGetNode(event: *mut SCIP_EVENT) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets solution for a primal solution event"]
    pub fn SCIPeventGetSol(event: *mut SCIP_EVENT) -> *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " gets the left bound of open interval in the hole"]
    pub fn SCIPeventGetHoleLeft(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the right bound of open interval in the hole"]
    pub fn SCIPeventGetHoleRight(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets row for a row event"]
    pub fn SCIPeventGetRow(event: *mut SCIP_EVENT) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets column for a row change coefficient event"]
    pub fn SCIPeventGetRowCol(event: *mut SCIP_EVENT) -> *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets old coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowOldCoefVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets new coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowNewCoefVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets old constant value for a row change constant event"]
    pub fn SCIPeventGetRowOldConstVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets new constant value for a row change constant event"]
    pub fn SCIPeventGetRowNewConstVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets side for a row change side event"]
    pub fn SCIPeventGetRowSide(event: *mut SCIP_EVENT) -> SCIP_SIDETYPE;
}
unsafe extern "C" {
    #[doc = " gets old side value for a row change side event"]
    pub fn SCIPeventGetRowOldSideVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " gets new side value for a row change side event"]
    pub fn SCIPeventGetRowNewSideVal(event: *mut SCIP_EVENT) -> f64;
}
unsafe extern "C" {
    #[doc = " set the expression handler callbacks to copy and free an expression handler"]
    pub fn SCIPexprhdlrSetCopyFreeHdlr(
        exprhdlr: *mut SCIP_EXPRHDLR,
        copyhdlr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourceexprhdlr: *mut SCIP_EXPRHDLR,
            ) -> SCIP_RETCODE,
        >,
        freehdlr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                exprhdlr: *mut SCIP_EXPRHDLR,
                exprhdlrdata: *mut *mut SCIP_EXPRHDLRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the expression handler callbacks to copy and free expression data"]
    pub fn SCIPexprhdlrSetCopyFreeData(
        exprhdlr: *mut SCIP_EXPRHDLR,
        copydata: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetexprhdlr: *mut SCIP_EXPRHDLR,
                targetexprdata: *mut *mut SCIP_EXPRDATA,
                sourcescip: *mut SCIP,
                sourceexpr: *mut SCIP_EXPR,
            ) -> SCIP_RETCODE,
        >,
        freedata: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the print callback of an expression handler"]
    pub fn SCIPexprhdlrSetPrint(
        exprhdlr: *mut SCIP_EXPRHDLR,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                stage: SCIP_EXPRITER_STAGE,
                currentchild: ::std::os::raw::c_int,
                parentprecedence: ::std::os::raw::c_uint,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the parse callback of an expression handler"]
    pub fn SCIPexprhdlrSetParse(
        exprhdlr: *mut SCIP_EXPRHDLR,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                exprhdlr: *mut SCIP_EXPRHDLR,
                string: *const ::std::os::raw::c_char,
                endstring: *mut *const ::std::os::raw::c_char,
                expr: *mut *mut SCIP_EXPR,
                success: *mut ::std::os::raw::c_uint,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the curvature detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetCurvature(
        exprhdlr: *mut SCIP_EXPRHDLR,
        curvature: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                exprcurvature: SCIP_EXPRCURV,
                success: *mut ::std::os::raw::c_uint,
                childcurv: *mut SCIP_EXPRCURV,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the monotonicity detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetMonotonicity(
        exprhdlr: *mut SCIP_EXPRHDLR,
        monotonicity: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                result: *mut SCIP_MONOTONE,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the integrality detection callback of an expression handler"]
    pub fn SCIPexprhdlrSetIntegrality(
        exprhdlr: *mut SCIP_EXPRHDLR,
        integrality: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                integrality: *mut SCIP_IMPLINTTYPE,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the hash callback of an expression handler"]
    pub fn SCIPexprhdlrSetHash(
        exprhdlr: *mut SCIP_EXPRHDLR,
        hash: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                hashkey: *mut ::std::os::raw::c_uint,
                childrenhashes: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the compare callback of an expression handler"]
    pub fn SCIPexprhdlrSetCompare(
        exprhdlr: *mut SCIP_EXPRHDLR,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr1: *mut SCIP_EXPR,
                expr2: *mut SCIP_EXPR,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set differentiation callbacks of an expression handler"]
    pub fn SCIPexprhdlrSetDiff(
        exprhdlr: *mut SCIP_EXPRHDLR,
        bwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                val: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        fwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                dot: *mut f64,
                direction: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        bwfwdiff: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                childidx: ::std::os::raw::c_int,
                bardot: *mut f64,
                direction: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the interval evaluation callback of an expression handler"]
    pub fn SCIPexprhdlrSetIntEval(
        exprhdlr: *mut SCIP_EXPRHDLR,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                interval: *mut SCIP_INTERVAL,
                intevalvar: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        var: *mut SCIP_VAR,
                        intevalvardata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_INTERVAL,
                >,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the simplify callback of an expression handler"]
    pub fn SCIPexprhdlrSetSimplify(
        exprhdlr: *mut SCIP_EXPRHDLR,
        simplify: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                simplifiedexpr: *mut *mut SCIP_EXPR,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the reverse propagation callback of an expression handler"]
    pub fn SCIPexprhdlrSetReverseProp(
        exprhdlr: *mut SCIP_EXPRHDLR,
        reverseprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                bounds: SCIP_INTERVAL,
                childrenbounds: *mut SCIP_INTERVAL,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the estimation callbacks of an expression handler"]
    pub fn SCIPexprhdlrSetEstimate(
        exprhdlr: *mut SCIP_EXPRHDLR,
        initestimates: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                bounds: *mut SCIP_INTERVAL,
                overestimate: ::std::os::raw::c_uint,
                coefs: *mut *mut f64,
                constant: *mut f64,
                nreturned: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                localbounds: *mut SCIP_INTERVAL,
                globalbounds: *mut SCIP_INTERVAL,
                refpoint: *mut f64,
                overestimate: ::std::os::raw::c_uint,
                targetvalue: f64,
                coefs: *mut f64,
                constant: *mut f64,
                islocal: *mut ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
                branchcand: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " set the symmetry information callback of an expression handler"]
    pub fn SCIPexprhdlrSetGetSymdata(
        exprhdlr: *mut SCIP_EXPRHDLR,
        getsymdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                symdata: *mut *mut SYM_EXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " gives the name of an expression handler"]
    pub fn SCIPexprhdlrGetName(exprhdlr: *mut SCIP_EXPRHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gives the description of an expression handler (can be NULL)"]
    pub fn SCIPexprhdlrGetDescription(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gives the precedence of an expression handler"]
    pub fn SCIPexprhdlrGetPrecedence(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives the data of an expression handler"]
    pub fn SCIPexprhdlrGetData(exprhdlr: *mut SCIP_EXPRHDLR) -> *mut SCIP_EXPRHDLRDATA;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the print callback"]
    pub fn SCIPexprhdlrHasPrint(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the backward differentiation callback"]
    pub fn SCIPexprhdlrHasBwdiff(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the forward differentiation callback"]
    pub fn SCIPexprhdlrHasFwdiff(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the interval evaluation callback"]
    pub fn SCIPexprhdlrHasIntEval(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the estimator callback"]
    pub fn SCIPexprhdlrHasEstimate(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the initial estimators callback"]
    pub fn SCIPexprhdlrHasInitEstimates(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the simplification callback"]
    pub fn SCIPexprhdlrHasSimplify(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the curvature callback"]
    pub fn SCIPexprhdlrHasCurvature(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the monotonicity callback"]
    pub fn SCIPexprhdlrHasMonotonicity(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether expression handler implements the reverse propagation callback"]
    pub fn SCIPexprhdlrHasReverseProp(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " return whether expression handler implements the symmetry data callback"]
    pub fn SCIPexprhdlrHasGetSymData(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two expression handler w.r.t. their name"]
    pub fn SCIPexprhdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of times an expression has been created with given expression handler"]
    pub fn SCIPexprhdlrGetNCreated(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets number of times the interval evaluation callback was called"]
    pub fn SCIPexprhdlrGetNIntevalCalls(exprhdlr: *mut SCIP_EXPRHDLR)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets time spend in interval evaluation callback"]
    pub fn SCIPexprhdlrGetIntevalTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of times the reverse propagation callback was called"]
    pub fn SCIPexprhdlrGetNReversepropCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets time spend in reverse propagation callback"]
    pub fn SCIPexprhdlrGetReversepropTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of times an empty interval was found in reverse propagation"]
    pub fn SCIPexprhdlrGetNCutoffs(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of times a bound reduction was found in reverse propagation (and accepted by caller)"]
    pub fn SCIPexprhdlrGetNDomainReductions(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " increments the domain reductions count of an expression handler"]
    pub fn SCIPexprhdlrIncrementNDomainReductions(
        exprhdlr: *mut SCIP_EXPRHDLR,
        nreductions: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " gets number of times the estimation callback was called"]
    pub fn SCIPexprhdlrGetNEstimateCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets time spend in estimation callback"]
    pub fn SCIPexprhdlrGetEstimateTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of times branching candidates reported by of this expression handler were used to assemble branching candidates\n\n that is, how often did we consider branching on a child of this expression"]
    pub fn SCIPexprhdlrGetNBranchings(exprhdlr: *mut SCIP_EXPRHDLR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " increments the branching candidates count of an expression handler"]
    pub fn SCIPexprhdlrIncrementNBranchings(exprhdlr: *mut SCIP_EXPRHDLR);
}
unsafe extern "C" {
    #[doc = " gets number of times the simplify callback was called"]
    pub fn SCIPexprhdlrGetNSimplifyCalls(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets time spend in simplify callback"]
    pub fn SCIPexprhdlrGetSimplifyTime(exprhdlr: *mut SCIP_EXPRHDLR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of times the simplify callback found a simplification"]
    pub fn SCIPexprhdlrGetNSimplifications(
        exprhdlr: *mut SCIP_EXPRHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of times the expression is currently captured"]
    pub fn SCIPexprGetNUses(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the number of children of an expression"]
    pub fn SCIPexprGetNChildren(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the children of an expression (can be NULL if no children)"]
    pub fn SCIPexprGetChildren(expr: *mut SCIP_EXPR) -> *mut *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " gets the expression handler of an expression\n\n This identifies the type of the expression (sum, variable, ...)."]
    pub fn SCIPexprGetHdlr(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " gets the expression data of an expression"]
    pub fn SCIPexprGetData(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPRDATA;
}
unsafe extern "C" {
    #[doc = " sets the expression data of an expression\n\n The pointer to possible old data is overwritten and the\n freedata-callback is not called before.\n This function is intended to be used by expression handler only."]
    pub fn SCIPexprSetData(expr: *mut SCIP_EXPR, exprdata: *mut SCIP_EXPRDATA);
}
unsafe extern "C" {
    #[doc = " gets the data that the owner of an expression has stored in an expression"]
    pub fn SCIPexprGetOwnerData(expr: *mut SCIP_EXPR) -> *mut SCIP_EXPR_OWNERDATA;
}
unsafe extern "C" {
    #[doc = " gives the value from the last evaluation of an expression (or SCIP_INVALID if there was an eval error)\n\n @see SCIPevalExpr to evaluate the expression at a given solution."]
    pub fn SCIPexprGetEvalValue(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gives the evaluation tag from the last evaluation, or 0\n\n @see SCIPevalExpr"]
    pub fn SCIPexprGetEvalTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the derivative stored in an expression (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPevalExprGradient"]
    pub fn SCIPexprGetDerivative(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gives the value of directional derivative from the last evaluation of a directional derivative of expression\n (or SCIP_INVALID if there was an error)\n\n @see SCIPevalExprHessianDir"]
    pub fn SCIPexprGetDot(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gives the value of directional derivative from the last evaluation of a directional derivative of derivative\n of root (or SCIP_INVALID if there was an error)\n\n @see SCIPevalExprHessianDir"]
    pub fn SCIPexprGetBardot(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the difftag stored in an expression\n\n can be used to check whether partial derivative value is valid\n\n @see SCIPevalExprGradient"]
    pub fn SCIPexprGetDiffTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the activity that is currently stored for an expression\n\n @see SCIPevalExprActivity"]
    pub fn SCIPexprGetActivity(expr: *mut SCIP_EXPR) -> SCIP_INTERVAL;
}
unsafe extern "C" {
    #[doc = " returns the tag associated with the activity of the expression\n\n It can depend on the owner of the expression how to interpret this tag.\n SCIPevalExprActivity() compares with `stat->domchgcount`.\n\n @see SCIPevalExprActivity"]
    pub fn SCIPexprGetActivityTag(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " set the activity with tag for an expression"]
    pub fn SCIPexprSetActivity(
        expr: *mut SCIP_EXPR,
        activity: SCIP_INTERVAL,
        activitytag: ::std::os::raw::c_longlong,
    );
}
unsafe extern "C" {
    #[doc = " returns the curvature of an expression\n\n  @note Call SCIPcomputeExprCurvature() before calling this function."]
    pub fn SCIPexprGetCurvature(expr: *mut SCIP_EXPR) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " sets the curvature of an expression"]
    pub fn SCIPexprSetCurvature(expr: *mut SCIP_EXPR, curvature: SCIP_EXPRCURV);
}
unsafe extern "C" {
    #[doc = " returns implied integrality of an expression"]
    pub fn SCIPexprGetIntegrality(expr: *mut SCIP_EXPR) -> SCIP_IMPLINTTYPE;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is integral, i.e. whether the integrality flag is not equal to SCIP_IMPLINTTYPE_NONE"]
    pub fn SCIPexprIsIntegral(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the integrality flag of an expression"]
    pub fn SCIPexprSetIntegrality(expr: *mut SCIP_EXPR, integrality: SCIP_IMPLINTTYPE);
}
unsafe extern "C" {
    #[doc = " gives the coefficients and expressions that define a quadratic expression\n\n It can return the constant part, the number, arguments, and coefficients of the purely linear part\n and the number of quadratic terms and bilinear terms.\n Note that for arguments that appear in the quadratic part, a linear coefficient is\n stored with the quadratic term.\n Use SCIPexprGetQuadraticQuadTerm() and SCIPexprGetQuadraticBilinTerm()\n to access the data for a quadratic or bilinear term.\n\n It can also return the eigenvalues and the eigenvectors of the matrix \\f$Q\\f$ when the quadratic is written\n as \\f$x^T Q x + b^T x + c^T y + d\\f$, where \\f$c^T y\\f$ defines the purely linear part.\n Note, however, that to have access to them one needs to call SCIPcomputeExprQuadraticCurvature()\n with `storeeigeninfo=TRUE`. If the eigen information was not stored or it failed to be computed,\n `eigenvalues` and `eigenvectors` will be set to NULL.\n\n This function returns pointers to internal data in linexprs and lincoefs.\n The user must not change this data.\n\n @attention SCIPcheckExprQuadratic() needs to be called first to check whether expression is quadratic and initialize the data of the quadratic representation."]
    pub fn SCIPexprGetQuadraticData(
        expr: *mut SCIP_EXPR,
        constant: *mut f64,
        nlinexprs: *mut ::std::os::raw::c_int,
        linexprs: *mut *mut *mut SCIP_EXPR,
        lincoefs: *mut *mut f64,
        nquadexprs: *mut ::std::os::raw::c_int,
        nbilinexprs: *mut ::std::os::raw::c_int,
        eigenvalues: *mut *mut f64,
        eigenvectors: *mut *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " gives the data of a quadratic expression term\n\n For a term \\f$a \\cdot \\text{expr}^2 + b \\cdot \\text{expr} + \\sum_i (c_i \\cdot \\text{expr} \\cdot \\text{otherexpr}_i)\\f$, returns\n `expr`, \\f$a\\f$, \\f$b\\f$, the number of summands, and indices of bilinear terms in the quadratic expressions `bilinexprterms`.\n\n This function returns pointers to internal data in adjbilin.\n The user must not change this data."]
    pub fn SCIPexprGetQuadraticQuadTerm(
        quadexpr: *mut SCIP_EXPR,
        termidx: ::std::os::raw::c_int,
        expr: *mut *mut SCIP_EXPR,
        lincoef: *mut f64,
        sqrcoef: *mut f64,
        nadjbilin: *mut ::std::os::raw::c_int,
        adjbilin: *mut *mut ::std::os::raw::c_int,
        sqrexpr: *mut *mut SCIP_EXPR,
    );
}
unsafe extern "C" {
    #[doc = " gives the data of a bilinear expression term\n\n For a term a*expr1*expr2, returns expr1, expr2, a, and\n the position of the quadratic expression term that uses expr2 in the quadratic expressions `quadexprterms`."]
    pub fn SCIPexprGetQuadraticBilinTerm(
        expr: *mut SCIP_EXPR,
        termidx: ::std::os::raw::c_int,
        expr1: *mut *mut SCIP_EXPR,
        expr2: *mut *mut SCIP_EXPR,
        coef: *mut f64,
        pos2: *mut ::std::os::raw::c_int,
        prodexpr: *mut *mut SCIP_EXPR,
    );
}
unsafe extern "C" {
    #[doc = " returns whether all expressions that are used in a quadratic expression are variable expressions\n\n @return TRUE iff all `linexprs` and `quadexprterms[.].expr` are variable expressions"]
    pub fn SCIPexprAreQuadraticExprsVariables(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the variable of a variable expression"]
    pub fn SCIPgetVarExprVar(expr: *mut SCIP_EXPR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the value of a constant value expression"]
    pub fn SCIPgetValueExprValue(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the coefficients of a summation expression"]
    pub fn SCIPgetCoefsExprSum(expr: *mut SCIP_EXPR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets the constant of a summation expression"]
    pub fn SCIPgetConstantExprSum(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the constant coefficient of a product expression"]
    pub fn SCIPgetCoefExprProduct(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the exponent of a power or signed power expression"]
    pub fn SCIPgetExponentExprPow(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether expression iterator is currently initialized"]
    pub fn SCIPexpriterIsInit(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " initializes an expression iterator\n\n @note If `expr` is NULL, then iterator will be set into ended-state (SCIPexpriterIsEnd() is TRUE). Useful if following with SCIPexpriterRestartDFS().\n\n If type is DFS, then `stopstages` will be set to \\ref SCIP_EXPRITER_ENTEREXPR.\n Use `SCIPexpriterSetStagesDFS` to change this."]
    pub fn SCIPexpriterInit(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
        type_: SCIP_EXPRITER_TYPE,
        allowrevisit: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " restarts an already initialized expression iterator in DFS mode\n\n The expression iterator will continue from the given expression, not revisiting expressions that\n this iterator has already been visited (if initialized with `allowrevisit=FALSE`) and giving access\n to the same iterator specified expression data that may have been set already.\n Also the stop-stages are not reset.\n\n If revisiting is forbidden and given expr has already been visited, then the iterator will behave\n as on the end of iteration (SCIPexpriterIsEnd() is TRUE).\n If the enterexpr stage is not one of the stop stages, then the iterator will be moved forward\n (SCIPexpriterGetNext() is called).\n\n @return The current expression."]
    pub fn SCIPexpriterRestartDFS(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
    ) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " specifies in which stages to stop a DFS iterator\n\n Parameter `stopstages` should be a bitwise OR of different \\ref SCIP_EXPRITER_STAGE values\n\n If the current stage is not one of the `stopstages`, then the iterator will be moved on."]
    pub fn SCIPexpriterSetStagesDFS(iterator: *mut SCIP_EXPRITER, stopstages: SCIP_EXPRITER_STAGE);
}
unsafe extern "C" {
    #[doc = " gets the current expression that the expression iterator points to"]
    pub fn SCIPexpriterGetCurrent(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " gets the current stage that the expression iterator is in when using DFS\n\n If the iterator has finished (SCIPexpriterIsEnd() is TRUE), then the stage is undefined."]
    pub fn SCIPexpriterGetStageDFS(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_STAGE;
}
unsafe extern "C" {
    #[doc = " gets the index of the child that the expression iterator considers when in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildIdxDFS(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the child expression that the expression iterator considers when in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildExprDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " gives the parent of the current expression of an expression iteration if in DFS mode\n\n @return the expression from which the current expression has been accessed"]
    pub fn SCIPexpriterGetParentDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " gives the iterator specific user data of the current expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterGetCurrentUserData(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_USERDATA;
}
unsafe extern "C" {
    #[doc = " gives the iterator specific user data of the current expressions current child\n\n @note The expression iterator mode must be in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterGetChildUserDataDFS(iterator: *mut SCIP_EXPRITER) -> SCIP_EXPRITER_USERDATA;
}
unsafe extern "C" {
    #[doc = " gives the iterator specific user data of a given expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterGetExprUserData(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_EXPRITER_USERDATA;
}
unsafe extern "C" {
    #[doc = " sets the iterator specific user data of the current expression for an expression iteration if in DFS mode\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterSetCurrentUserData(
        iterator: *mut SCIP_EXPRITER,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
unsafe extern "C" {
    #[doc = " sets the iterator specific user data of a given expression\n\n @note The expression iterator mode must be DFS or another mode with allowrevisit=FALSE"]
    pub fn SCIPexpriterSetExprUserData(
        iterator: *mut SCIP_EXPRITER,
        expr: *mut SCIP_EXPR,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
unsafe extern "C" {
    #[doc = " sets the iterator specific user data of the current expressions current child\n\n @note The expression iterator mode must be in DFS mode and stage \\ref SCIP_EXPRITER_VISITINGCHILD or \\ref SCIP_EXPRITER_VISITEDCHILD"]
    pub fn SCIPexpriterSetChildUserData(
        iterator: *mut SCIP_EXPRITER,
        userdata: SCIP_EXPRITER_USERDATA,
    );
}
unsafe extern "C" {
    #[doc = " moves the iterator to the next expression according to the mode of the expression iterator\n\n @return the next expression, if any, and NULL otherwise"]
    pub fn SCIPexpriterGetNext(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " moves a DFS iterator to one of the next expressions\n\n - If in \\ref SCIP_EXPRITER_ENTEREXPR stage, then all children of that expression will be skipped.\n   If \\ref SCIP_EXPRITER_LEAVEEXPR is one of the `stopstages`, then it will be the next stage. Otherwise, the iterator will move further on (go to the parent, etc).\n - If in \\ref SCIP_EXPRITER_VISITINGCHILD stage, then the child that was going to be visited next will be skipped and the iterator will be moved on to the next child (if any).\n - If in \\ref SCIP_EXPRITER_VISITEDCHILD stage, then all remaining children will be skipped and we move on to the \\ref SCIP_EXPRITER_LEAVEEXPR stage (if a stop stage, otherwise further on).\n - It is not allowed to call this function when in \\ref SCIP_EXPRITER_LEAVEEXPR stage.\n\n @return the next expression, if any, and NULL otherwise"]
    pub fn SCIPexpriterSkipDFS(iterator: *mut SCIP_EXPRITER) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " returns whether the iterator visited all expressions already"]
    pub fn SCIPexpriterIsEnd(iterator: *mut SCIP_EXPRITER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives curvature for a sum of two functions with given curvature"]
    pub fn SCIPexprcurvAdd(curv1: SCIP_EXPRCURV, curv2: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " gives the curvature for the negation of a function with given curvature"]
    pub fn SCIPexprcurvNegate(curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " gives curvature for a functions with given curvature multiplied by a constant factor"]
    pub fn SCIPexprcurvMultiply(factor: f64, curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " gives curvature for base^exponent for given bounds and curvature of base-function and constant exponent"]
    pub fn SCIPexprcurvPower(
        basebounds: SCIP_INTERVAL,
        basecurv: SCIP_EXPRCURV,
        exponent: f64,
    ) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " gives required curvature for base so that base^exponent has given curvature under given bounds on base and constant exponent\n\n returns curvature unknown if expected curvature cannot be obtained"]
    pub fn SCIPexprcurvPowerInv(
        basebounds: SCIP_INTERVAL,
        exponent: f64,
        powercurv: SCIP_EXPRCURV,
    ) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " gives curvature for a monomial with given curvatures and bounds for each factor\n\n  See Maranas and Floudas, Finding All Solutions of Nonlinearly Constrained Systems of Equations, JOGO 7, 1995\n  for the categorization in the case that all factors are linear.\n\n  Exponents can also be negative or rational."]
    pub fn SCIPexprcurvMonomial(
        nfactors: ::std::os::raw::c_int,
        exponents: *mut f64,
        factoridxs: *mut ::std::os::raw::c_int,
        factorcurv: *mut SCIP_EXPRCURV,
        factorbounds: *mut SCIP_INTERVAL,
    ) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " for a monomial with given bounds for each factor, gives condition on the curvature of each factor, so that monomial has a requested curvature, if possible\n\n @return whether `monomialcurv` can be achieved"]
    pub fn SCIPexprcurvMonomialInv(
        monomialcurv: SCIP_EXPRCURV,
        nfactors: ::std::os::raw::c_int,
        exponents: *mut f64,
        factorbounds: *mut SCIP_INTERVAL,
        factorcurv: *mut SCIP_EXPRCURV,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives name as string for a curvature"]
    pub fn SCIPexprcurvGetName(curv: SCIP_EXPRCURV) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_File {
    _unused: [u8; 0],
}
pub type SCIP_FILE = SCIP_File;
unsafe extern "C" {
    pub fn SCIPfopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
unsafe extern "C" {
    pub fn SCIPfdopen(
        fildes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
unsafe extern "C" {
    pub fn SCIPfread(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut SCIP_FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn SCIPfwrite(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut SCIP_FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn SCIPfprintf(
        stream: *mut SCIP_FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfputc(c: ::std::os::raw::c_int, stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut SCIP_FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfgetc(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfgets(
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        stream: *mut SCIP_FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn SCIPfflush(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfseek(
        stream: *mut SCIP_FILE,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPrewind(stream: *mut SCIP_FILE);
}
unsafe extern "C" {
    pub fn SCIPftell(stream: *mut SCIP_FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn SCIPfeof(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPfclose(fp: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two heuristics w.r.t. to their delay positions and priorities"]
    pub fn SCIPheurComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two heuristics w.r.t. to their priority values"]
    pub fn SCIPheurCompPriority(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting heuristics w.r.t. to their name"]
    pub fn SCIPheurCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of primal heuristic"]
    pub fn SCIPheurGetData(heur: *mut SCIP_HEUR) -> *mut SCIP_HEURDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of primal heuristic; user has to free old data in advance!"]
    pub fn SCIPheurSetData(heur: *mut SCIP_HEUR, heurdata: *mut SCIP_HEURDATA);
}
unsafe extern "C" {
    #[doc = " marks the primal heuristic as safe to use in exact solving mode"]
    pub fn SCIPheurMarkExact(heur: *mut SCIP_HEUR);
}
unsafe extern "C" {
    #[doc = " gets name of primal heuristic"]
    pub fn SCIPheurGetName(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of primal heuristic"]
    pub fn SCIPheurGetDesc(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets display character of primal heuristic"]
    pub fn SCIPheurGetDispchar(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns the timing mask of the heuristic"]
    pub fn SCIPheurGetTimingmask(heur: *mut SCIP_HEUR) -> SCIP_HEURTIMING;
}
unsafe extern "C" {
    #[doc = " sets new timing mask for heuristic"]
    pub fn SCIPheurSetTimingmask(heur: *mut SCIP_HEUR, timingmask: SCIP_HEURTIMING);
}
unsafe extern "C" {
    #[doc = " does the heuristic use a secondary SCIP instance?"]
    pub fn SCIPheurUsesSubscip(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets priority of primal heuristic"]
    pub fn SCIPheurGetPriority(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets frequency of primal heuristic"]
    pub fn SCIPheurGetFreq(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets frequency of primal heuristic"]
    pub fn SCIPheurSetFreq(heur: *mut SCIP_HEUR, freq: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " gets frequency offset of primal heuristic"]
    pub fn SCIPheurGetFreqofs(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets maximal depth level for calling primal heuristic (returns -1, if no depth limit exists)"]
    pub fn SCIPheurGetMaxdepth(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the heuristic was called and tried to find a solution"]
    pub fn SCIPheurGetNCalls(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of new best primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNBestSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " is primal heuristic initialized?"]
    pub fn SCIPheurIsInitialized(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this heuristic for setting up for next stages"]
    pub fn SCIPheurGetSetupTime(heur: *mut SCIP_HEUR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this heuristic"]
    pub fn SCIPheurGetTime(heur: *mut SCIP_HEUR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns array of divesets of this primal heuristic, or NULL if it has no divesets"]
    pub fn SCIPheurGetDivesets(heur: *mut SCIP_HEUR) -> *mut *mut SCIP_DIVESET;
}
unsafe extern "C" {
    #[doc = " returns the number of divesets of this primal heuristic"]
    pub fn SCIPheurGetNDivesets(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the heuristic to which this diving setting belongs"]
    pub fn SCIPdivesetGetHeur(diveset: *mut SCIP_DIVESET) -> *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " get the working solution of this dive set"]
    pub fn SCIPdivesetGetWorkSolution(diveset: *mut SCIP_DIVESET) -> *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " set the working solution for this dive set"]
    pub fn SCIPdivesetSetWorkSolution(diveset: *mut SCIP_DIVESET, sol: *mut SCIP_SOL);
}
unsafe extern "C" {
    #[doc = " get the name of the dive set"]
    pub fn SCIPdivesetGetName(diveset: *mut SCIP_DIVESET) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " get the minimum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMinRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the maximum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMaxRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the number of successful runs of the diving settings"]
    pub fn SCIPdivesetGetSolSuccess(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the number of calls to this dive set"]
    pub fn SCIPdivesetGetNCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the number of calls successfully terminated at a feasible leaf node"]
    pub fn SCIPdivesetGetNSolutionCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the minimum depth reached by this dive set"]
    pub fn SCIPdivesetGetMinDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the maximum depth reached by this dive set"]
    pub fn SCIPdivesetGetMaxDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the average depth this dive set reached during execution"]
    pub fn SCIPdivesetGetAvgDepth(diveset: *mut SCIP_DIVESET, divecontext: SCIP_DIVECONTEXT)
    -> f64;
}
unsafe extern "C" {
    #[doc = " get the minimum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMinSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the maximum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMaxSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the average depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetAvgSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " get the total number of LP iterations used by this dive set"]
    pub fn SCIPdivesetGetNLPIterations(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the total number of probing nodes used by this dive set"]
    pub fn SCIPdivesetGetNProbingNodes(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the total number of backtracks performed by this dive set"]
    pub fn SCIPdivesetGetNBacktracks(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the total number of conflicts found by this dive set"]
    pub fn SCIPdivesetGetNConflicts(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the total number of solutions (leaf and rounded solutions) found by the dive set"]
    pub fn SCIPdivesetGetNSols(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get the maximum LP iterations quotient of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the maximum LP iterations offset of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterOffset(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetUbQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the average quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetAvgQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetUbQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " get the average upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetAvgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " should backtracking be applied?"]
    pub fn SCIPdivesetUseBacktrack(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the LP solve frequency for diving LPs (0: dynamically based on number of intermediate domain reductions)"]
    pub fn SCIPdivesetGetLPSolveFreq(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the domain reduction quotient for triggering an immediate resolve of the diving LP (0.0: always resolve)"]
    pub fn SCIPdivesetGetLPResolveDomChgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
unsafe extern "C" {
    #[doc = " should only LP branching candidates be considered instead of the slower but\n  more general constraint handler diving variable selection?"]
    pub fn SCIPdivesetUseOnlyLPBranchcands(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE if dive set supports diving of the specified type"]
    pub fn SCIPdivesetSupportsType(
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the random number generator of this \\p diveset for tie-breaking"]
    pub fn SCIPdivesetGetRandnumgen(diveset: *mut SCIP_DIVESET) -> *mut SCIP_RANDNUMGEN;
}
unsafe extern "C" {
    #[doc = " is this dive set publicly available (ie., can be used by other primal heuristics?)"]
    pub fn SCIPdivesetIsPublic(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Perform breadth-first (BFS) search on the variable constraint graph.\n\n  The result of the algorithm is that the \\p distances array contains the correct distances for\n  every variable from the start variables. The distance of a variable can then be accessed through its\n  problem index (calling SCIPvarGetProbindex()).\n  Hence, The method assumes that the length of \\p distances is at least\n  SCIPgetNVars().\n  Variables that are not connected through constraints to the start variables have a distance of -1.\n\n  Limits can be provided to further restrict the breadth-first search. If a distance limit is given,\n  the search will be performed until the first variable at this distance is popped from the queue, i.e.,\n  all variables with a distance < maxdistance have been labeled by the search.\n  If a variable limit is given, the search stops after it completes the distance level at which\n  the limit was reached. Hence, more variables may be actually labeled.\n  The start variables are accounted for those variable limits.\n\n  If no variable variable constraint graph is provided, the method will create one and free it at the end\n  This is useful for a single use of the variable constraint graph. For several consecutive uses,\n  it is advised to create a variable constraint graph via SCIPvariableGraphCreate()."]
    pub fn SCIPvariablegraphBreadthFirst(
        scip: *mut SCIP,
        vargraph: *mut SCIP_VGRAPH,
        startvars: *mut *mut SCIP_VAR,
        nstartvars: ::std::os::raw::c_int,
        distances: *mut ::std::os::raw::c_int,
        maxdistance: ::std::os::raw::c_int,
        maxvars: ::std::os::raw::c_int,
        maxbinintvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initialization method of variable graph data structure"]
    pub fn SCIPvariableGraphCreate(
        scip: *mut SCIP,
        vargraph: *mut *mut SCIP_VGRAPH,
        relaxdenseconss: ::std::os::raw::c_uint,
        relaxdensity: f64,
        nrelaxedconstraints: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deinitialization method of variable graph data structure"]
    pub fn SCIPvariableGraphFree(scip: *mut SCIP, vargraph: *mut *mut SCIP_VGRAPH);
}
unsafe extern "C" {
    #[doc = " compares two compressions w. r. to their priority"]
    pub fn SCIPcomprComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting compressions w.r.t. to their name"]
    pub fn SCIPcomprCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of tree compression"]
    pub fn SCIPcomprGetData(compr: *mut SCIP_COMPR) -> *mut SCIP_COMPRDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of tree compression; user has to free old data in advance!"]
    pub fn SCIPcomprSetData(compr: *mut SCIP_COMPR, comprdata: *mut SCIP_COMPRDATA);
}
unsafe extern "C" {
    #[doc = " gets name of tree compression"]
    pub fn SCIPcomprGetName(compr: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of tree compression"]
    pub fn SCIPcomprGetDesc(compr: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of tree compression"]
    pub fn SCIPcomprGetPriority(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets minimal number of nodes for calling tree compression (returns -1, if no node threshold exists)"]
    pub fn SCIPcomprGetMinNodes(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the compression was called and tried to find a compression"]
    pub fn SCIPcomprGetNCalls(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of tree compressions found by this compression"]
    pub fn SCIPcomprGetNFound(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " is tree compression initialized?"]
    pub fn SCIPcomprIsInitialized(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this compression for setting up for next stages"]
    pub fn SCIPcomprGetSetupTime(compr: *mut SCIP_COMPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this compression"]
    pub fn SCIPcomprGetTime(compr: *mut SCIP_COMPR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the conflict score of the history entry"]
    pub fn SCIPhistoryGetVSIDS(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average conflict length of the history entry"]
    pub fn SCIPhistoryGetAvgConflictlength(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " get number of cutoffs counter"]
    pub fn SCIPhistoryGetCutoffSum(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " get number of inferences counter"]
    pub fn SCIPhistoryGetInferenceSum(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " return the number of (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetNValues(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return the array containing the histories for the individual (domain) values"]
    pub fn SCIPvaluehistoryGetHistories(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> *mut *mut SCIP_HISTORY;
}
unsafe extern "C" {
    #[doc = " return the array containing the (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetValues(valuehistory: *mut SCIP_VALUEHISTORY) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets name of IIS finder"]
    pub fn SCIPiisfinderGetName(iisfinder: *mut SCIP_IISFINDER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets user data of IIS finder"]
    pub fn SCIPiisfinderGetData(iisfinder: *mut SCIP_IISFINDER) -> *mut SCIP_IISFINDERDATA;
}
unsafe extern "C" {
    #[doc = " gets description of IIS finder"]
    pub fn SCIPiisfinderGetDesc(iisfinder: *mut SCIP_IISFINDER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of IIS finder"]
    pub fn SCIPiisfinderGetPriority(iisfinder: *mut SCIP_IISFINDER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets user data of IIS finder; user has to free old data in advance!"]
    pub fn SCIPiisfinderSetData(
        iisfinder: *mut SCIP_IISFINDER,
        iisfinderdata: *mut SCIP_IISFINDERDATA,
    );
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this IIS finder"]
    pub fn SCIPiisfinderGetTime(iisfinder: *mut SCIP_IISFINDER) -> f64;
}
unsafe extern "C" {
    #[doc = " prints output line during IIS calculations"]
    pub fn SCIPiisfinderInfoMessage(iis: *mut SCIP_IIS, printheaders: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in the IIS calculations"]
    pub fn SCIPiisGetTime(iis: *mut SCIP_IIS) -> f64;
}
unsafe extern "C" {
    #[doc = " Gets whether the IIS subscip is currently infeasible."]
    pub fn SCIPiisIsSubscipInfeasible(iis: *mut SCIP_IIS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Gets whether the IIS subscip is irreducible."]
    pub fn SCIPiisIsSubscipIrreducible(iis: *mut SCIP_IIS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Gets the number of nodes in the IIS solve."]
    pub fn SCIPiisGetNNodes(iis: *mut SCIP_IIS) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " Sets the flag that states whether the IIS subscip is currently infeasible."]
    pub fn SCIPiisSetSubscipInfeasible(iis: *mut SCIP_IIS, infeasible: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Sets the flag that states whether the IIS subscip is irreducible."]
    pub fn SCIPiisSetSubscipIrreducible(iis: *mut SCIP_IIS, irreducible: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Increments the number of nodes in the IIS solve."]
    pub fn SCIPiisAddNNodes(iis: *mut SCIP_IIS, nnodes: ::std::os::raw::c_longlong);
}
unsafe extern "C" {
    #[doc = " get the randnumgen of the IIS"]
    pub fn SCIPiisGetRandnumgen(iis: *mut SCIP_IIS) -> *mut SCIP_RANDNUMGEN;
}
unsafe extern "C" {
    #[doc = " get the subscip of an IIS"]
    pub fn SCIPiisGetSubscip(iis: *mut SCIP_IIS) -> *mut SCIP;
}
unsafe extern "C" {
    #[doc = " compares two IIS finders w. r. to their priority"]
    pub fn SCIPiisfinderComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VBounds {
    _unused: [u8; 0],
}
pub type SCIP_VBOUNDS = SCIP_VBounds;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Implics {
    _unused: [u8; 0],
}
pub type SCIP_IMPLICS = SCIP_Implics;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clique {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUE = SCIP_Clique;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueTable {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUETABLE = SCIP_CliqueTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueList {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUELIST = SCIP_CliqueList;
unsafe extern "C" {
    #[doc = " returns the position of the given variable/value pair in the clique; returns -1 if variable/value pair is not member\n  of the clique"]
    pub fn SCIPcliqueSearchVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the given variable/value pair is member of the given clique"]
    pub fn SCIPcliqueHasVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets number of variables in the cliques"]
    pub fn SCIPcliqueGetNVars(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of active problem variables in the cliques"]
    pub fn SCIPcliqueGetVars(clique: *mut SCIP_CLIQUE) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array of values of active problem variables in the cliques, i.e. whether the variable is fixed to FALSE or\n  to TRUE in the clique"]
    pub fn SCIPcliqueGetValues(clique: *mut SCIP_CLIQUE) -> *mut ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets unique identifier of the clique"]
    pub fn SCIPcliqueGetId(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets index of the clique in the clique table"]
    pub fn SCIPcliqueGetIndex(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the given clique is cleaned up"]
    pub fn SCIPcliqueIsCleanedUp(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " return whether the given clique is an equation"]
    pub fn SCIPcliqueIsEquation(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
#[doc = "< maximize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MAXIMIZE: SCIP_ObjSen = -1;
#[doc = "< minimize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MINIMIZE: SCIP_ObjSen = 1;
#[doc = " objective sense"]
pub type SCIP_ObjSen = ::std::os::raw::c_int;
#[doc = " objective sense"]
pub use self::SCIP_ObjSen as SCIP_OBJSEN;
#[doc = "< solver should start from scratch at next call?"]
pub const SCIP_LPParam_SCIP_LPPAR_FROMSCRATCH: SCIP_LPParam = 0;
#[doc = "< fast mip setting of LP solver"]
pub const SCIP_LPParam_SCIP_LPPAR_FASTMIP: SCIP_LPParam = 1;
#[doc = "< should LP solver use scaling?"]
pub const SCIP_LPParam_SCIP_LPPAR_SCALING: SCIP_LPParam = 2;
#[doc = "< should LP solver use presolving?"]
pub const SCIP_LPParam_SCIP_LPPAR_PRESOLVING: SCIP_LPParam = 3;
#[doc = "< pricing strategy"]
pub const SCIP_LPParam_SCIP_LPPAR_PRICING: SCIP_LPParam = 4;
#[doc = "< should LP solver output information to the screen?"]
pub const SCIP_LPParam_SCIP_LPPAR_LPINFO: SCIP_LPParam = 5;
#[doc = "< feasibility tolerance for primal variables and slacks, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_FEASTOL: SCIP_LPParam = 6;
#[doc = "< feasibility tolerance for dual variables and reduced costs, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_DUALFEASTOL: SCIP_LPParam = 7;
#[doc = "< convergence tolerance used in barrier algorithm"]
pub const SCIP_LPParam_SCIP_LPPAR_BARRIERCONVTOL: SCIP_LPParam = 8;
#[doc = "< objective limit (stop if objective is known be larger/smaller than limit for min/max-imization)"]
pub const SCIP_LPParam_SCIP_LPPAR_OBJLIM: SCIP_LPParam = 9;
#[doc = "< LP iteration limit, greater than or equal 0"]
pub const SCIP_LPParam_SCIP_LPPAR_LPITLIM: SCIP_LPParam = 10;
#[doc = "< LP time limit, positive"]
pub const SCIP_LPParam_SCIP_LPPAR_LPTILIM: SCIP_LPParam = 11;
#[doc = "< Markowitz tolerance"]
pub const SCIP_LPParam_SCIP_LPPAR_MARKOWITZ: SCIP_LPParam = 12;
#[doc = "< simplex algorithm shall use row representation of the basis\n   if number of rows divided by number of columns exceeds this value\n   (0 <= value or -1 = valu ; if negative, this change never occurs)"]
pub const SCIP_LPParam_SCIP_LPPAR_ROWREPSWITCH: SCIP_LPParam = 13;
#[doc = "< number of threads used to solve the LP"]
pub const SCIP_LPParam_SCIP_LPPAR_THREADS: SCIP_LPParam = 14;
#[doc = "< maximum condition number of LP basis counted as stable"]
pub const SCIP_LPParam_SCIP_LPPAR_CONDITIONLIMIT: SCIP_LPParam = 15;
#[doc = "< type of timer (1 - cpu, 2 - wallclock, 0 - off)"]
pub const SCIP_LPParam_SCIP_LPPAR_TIMING: SCIP_LPParam = 16;
#[doc = "< inital random seed, e.g. for perturbations in the simplex (0: LP default)"]
pub const SCIP_LPParam_SCIP_LPPAR_RANDOMSEED: SCIP_LPParam = 17;
#[doc = "< set solution polishing (0 - disable, 1 - enable)"]
pub const SCIP_LPParam_SCIP_LPPAR_POLISHING: SCIP_LPParam = 18;
#[doc = "< set refactorization interval (0 - automatic)"]
pub const SCIP_LPParam_SCIP_LPPAR_REFACTOR: SCIP_LPParam = 19;
#[doc = " LP solver parameters"]
pub type SCIP_LPParam = ::std::os::raw::c_uint;
#[doc = " LP solver parameters"]
pub use self::SCIP_LPParam as SCIP_LPPARAM;
#[doc = "< the SCIP/LP interface should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_LPIDEFAULT: SCIP_Pricing = 0;
#[doc = "< the LP solver should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_AUTO: SCIP_Pricing = 1;
#[doc = "< full pricing"]
pub const SCIP_Pricing_SCIP_PRICING_FULL: SCIP_Pricing = 2;
#[doc = "< partial pricing"]
pub const SCIP_Pricing_SCIP_PRICING_PARTIAL: SCIP_Pricing = 3;
#[doc = "< steepest edge pricing"]
pub const SCIP_Pricing_SCIP_PRICING_STEEP: SCIP_Pricing = 4;
#[doc = "< steepest edge pricing without initial dual norms"]
pub const SCIP_Pricing_SCIP_PRICING_STEEPQSTART: SCIP_Pricing = 5;
#[doc = "< devex pricing"]
pub const SCIP_Pricing_SCIP_PRICING_DEVEX: SCIP_Pricing = 6;
#[doc = " LP pricing strategy"]
pub type SCIP_Pricing = ::std::os::raw::c_uint;
#[doc = " LP pricing strategy"]
pub use self::SCIP_Pricing as SCIP_PRICING;
#[doc = "< (slack) variable is at its lower bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_LOWER: SCIP_BaseStat = 0;
#[doc = "< (slack) variable is basic"]
pub const SCIP_BaseStat_SCIP_BASESTAT_BASIC: SCIP_BaseStat = 1;
#[doc = "< (slack) variable is at its upper bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_UPPER: SCIP_BaseStat = 2;
#[doc = "< free variable is non-basic and set to zero"]
pub const SCIP_BaseStat_SCIP_BASESTAT_ZERO: SCIP_BaseStat = 3;
#[doc = " basis status for columns and rows"]
pub type SCIP_BaseStat = ::std::os::raw::c_uint;
#[doc = " basis status for columns and rows"]
pub use self::SCIP_BaseStat as SCIP_BASESTAT;
#[doc = "< estimated condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_ESTIMCONDITION: SCIP_LPSolQuality = 0;
#[doc = "< exact condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_EXACTCONDITION: SCIP_LPSolQuality = 1;
#[doc = " LP solution quality quantities"]
pub type SCIP_LPSolQuality = ::std::os::raw::c_uint;
#[doc = " LP solution quality quantities"]
pub use self::SCIP_LPSolQuality as SCIP_LPSOLQUALITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPi {
    _unused: [u8; 0],
}
pub type SCIP_LPI = SCIP_LPi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiState {
    _unused: [u8; 0],
}
pub type SCIP_LPISTATE = SCIP_LPiState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiNorms {
    _unused: [u8; 0],
}
pub type SCIP_LPINORMS = SCIP_LPiNorms;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ColExactSolVals {
    _unused: [u8; 0],
}
pub type SCIP_COLEXACTSOLVALS = SCIP_ColExactSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowExactSolVals {
    _unused: [u8; 0],
}
pub type SCIP_ROWEXACTSOLVALS = SCIP_RowExactSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LpExactSolVals {
    _unused: [u8; 0],
}
pub type SCIP_LPEXACTSOLVALS = SCIP_LpExactSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ColExact {
    _unused: [u8; 0],
}
#[doc = " column of an exact LP\n\n  - \\ref PublicLPExactMethods \"List of all available methods\""]
pub type SCIP_COLEXACT = SCIP_ColExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowExact {
    _unused: [u8; 0],
}
#[doc = " row of an exact LP\n\n  - \\ref PublicLPExactMethods \"List of all available methods\""]
pub type SCIP_ROWEXACT = SCIP_RowExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProjShiftData {
    _unused: [u8; 0],
}
#[doc = " data used for project and shift"]
pub type SCIP_PROJSHIFTDATA = SCIP_ProjShiftData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LpExact {
    _unused: [u8; 0],
}
#[doc = " exact LP structure\n\n  - \\ref PublicLPExactMethods \"List of all available methods\""]
pub type SCIP_LPEXACT = SCIP_LpExact;
#[doc = "< no selection"]
pub const Ps_dualcostsel_PS_DUALCOSTSEL_NO: Ps_dualcostsel = 0;
#[doc = "< active rows of fp lp"]
pub const Ps_dualcostsel_PS_DUALCOSTSEL_ACTIVE_FPLP: Ps_dualcostsel = 1;
#[doc = "< active rows of exact lp"]
pub const Ps_dualcostsel_PS_DUALCOSTSEL_ACTIVE_EXLP: Ps_dualcostsel = 2;
pub type Ps_dualcostsel = ::std::os::raw::c_uint;
pub use self::Ps_dualcostsel as PS_DUALCOSTSEL;
unsafe extern "C" {
    #[doc = " sorts column entries such that LP rows precede non-LP rows and inside both parts lower row indices precede higher ones"]
    pub fn SCIPcolSort(col: *mut SCIP_COL);
}
unsafe extern "C" {
    #[doc = " gets objective value of column"]
    pub fn SCIPcolGetObj(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lower bound of column"]
    pub fn SCIPcolGetLb(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets upper bound of column"]
    pub fn SCIPcolGetUb(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets best bound of column with respect to the objective function"]
    pub fn SCIPcolGetBestBound(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the primal LP solution of a column"]
    pub fn SCIPcolGetPrimsol(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the minimal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMinPrimsol(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the maximal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMaxPrimsol(col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the basis status of a column in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL\n  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_ZERO for columns not in the current SCIP_LP"]
    pub fn SCIPcolGetBasisStatus(col: *mut SCIP_COL) -> SCIP_BASESTAT;
}
unsafe extern "C" {
    #[doc = " gets variable this column represents"]
    pub fn SCIPcolGetVar(col: *mut SCIP_COL) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets unique index of col"]
    pub fn SCIPcolGetIndex(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets probindex of corresponding variable"]
    pub fn SCIPcolGetVarProbindex(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the associated variable is of integral type (binary, integer, or implied integral)"]
    pub fn SCIPcolIsIntegral(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the associated variable is implied integral"]
    pub fn SCIPcolIsImpliedIntegral(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPcolIsRemovable(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets position of column in current LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPPos(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets depth in the tree where the column entered the LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPDepth(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff column is member of current LP"]
    pub fn SCIPcolIsInLP(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " get number of nonzero entries in column vector"]
    pub fn SCIPcolGetNNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of nonzero entries in column vector, that correspond to rows currently in the SCIP_LP;\n\n  @warning This method is only applicable on columns, that are completely linked to their rows (e.g. a column\n  that is in the current LP and the LP was solved, or a column that was in a solved LP and didn't change afterwards"]
    pub fn SCIPcolGetNLPNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with rows of nonzero entries"]
    pub fn SCIPcolGetRows(col: *mut SCIP_COL) -> *mut *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIPcolGetVals(col: *mut SCIP_COL) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the\n  given column, or -1 if strong branching was never applied to the column in current run"]
    pub fn SCIPcolGetStrongbranchNode(col: *mut SCIP_COL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given column"]
    pub fn SCIPcolGetNStrongbranchs(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the age of a column, i.e., the total number of successive times a column was in the LP and was 0.0 in the solution"]
    pub fn SCIPcolGetAge(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets opposite bound type of given bound type"]
    pub fn SCIPboundtypeOpposite(boundtype: SCIP_BOUNDTYPE) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting rows by non-decreasing index"]
    pub fn SCIProwComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " locks an unmodifiable row, which forbids further changes; has no effect on modifiable rows"]
    pub fn SCIProwLock(row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " unlocks a lock of an unmodifiable row; a row with no sealed lock may be modified; has no effect on modifiable rows"]
    pub fn SCIProwUnlock(row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " returns the scalar product of the coefficient vectors of the two given rows"]
    pub fn SCIProwGetScalarProduct(row1: *mut SCIP_ROW, row2: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the degree of parallelism between the hyperplanes defined by the two row vectors v, w:\n  p = |v*w|/(|v|*|w|);\n  the hyperplanes are parallel, iff p = 1, they are orthogonal, iff p = 0"]
    pub fn SCIProwGetParallelism(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the degree of orthogonality between the hyperplanes defined by the two row vectors v, w:\n  o = 1 - |v*w|/(|v|*|w|);\n  the hyperplanes are orthogonal, iff p = 1, they are parallel, iff p = 0"]
    pub fn SCIProwGetOrthogonality(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " sorts row entries such that LP columns precede non-LP columns and inside both parts lower column indices precede\n  higher ones"]
    pub fn SCIProwSort(row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " get number of nonzero entries in row vector"]
    pub fn SCIProwGetNNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of nonzero entries in row vector, that correspond to columns currently in the SCIP_LP;\n\n  @warning This method is only applicable on rows, that are completely linked to their columns (e.g. a row\n  that is in the current LP and the LP was solved, or a row that was in a solved LP and didn't change afterwards"]
    pub fn SCIProwGetNLPNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with columns of nonzero entries"]
    pub fn SCIProwGetCols(row: *mut SCIP_ROW) -> *mut *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIProwGetVals(row: *mut SCIP_ROW) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets constant shift of row"]
    pub fn SCIProwGetConstant(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets Euclidean norm of row vector"]
    pub fn SCIProwGetNorm(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets sum norm of row vector (sum of absolute values of coefficients)"]
    pub fn SCIProwGetSumNorm(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the left hand side of the row"]
    pub fn SCIProwGetLhs(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the right hand side of the row"]
    pub fn SCIProwGetRhs(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual LP solution of a row"]
    pub fn SCIProwGetDualsol(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas coefficient of a row in an infeasible LP"]
    pub fn SCIProwGetDualfarkas(row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the basis status of a row in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL\n  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_BASIC for rows not in the current SCIP_LP"]
    pub fn SCIProwGetBasisStatus(row: *mut SCIP_ROW) -> SCIP_BASESTAT;
}
unsafe extern "C" {
    #[doc = " returns the name of the row"]
    pub fn SCIProwGetName(row: *mut SCIP_ROW) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets unique index of row"]
    pub fn SCIProwGetIndex(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets age of row"]
    pub fn SCIProwGetAge(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets rank of row"]
    pub fn SCIProwGetRank(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the activity of the row (without the row's constant) is integral for an optimal solution"]
    pub fn SCIProwIsIntegral(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is only valid locally"]
    pub fn SCIProwIsLocal(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is modifiable during node processing (subject to column generation)"]
    pub fn SCIProwIsModifiable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is removable from the LP (due to aging or cleanup)"]
    pub fn SCIProwIsRemovable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns type of origin that created the row"]
    pub fn SCIProwGetOrigintype(row: *mut SCIP_ROW) -> SCIP_ROWORIGINTYPE;
}
unsafe extern "C" {
    #[doc = " returns origin constraint handler that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginConshdlr(row: *mut SCIP_ROW) -> *mut SCIP_CONSHDLR;
}
unsafe extern "C" {
    #[doc = " returns origin constraint that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginCons(row: *mut SCIP_ROW) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " returns origin separator that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginSepa(row: *mut SCIP_ROW) -> *mut SCIP_SEPA;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is member of the global cut pool"]
    pub fn SCIProwIsInGlobalCutpool(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets position of row in current LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPPos(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets depth in the tree where the row entered the LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPDepth(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is member of current LP"]
    pub fn SCIProwIsInLP(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of times that this row has been sharp in an optimal LP solution"]
    pub fn SCIProwGetActiveLPCount(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the number of LPs since this row has been created"]
    pub fn SCIProwGetNLPsAfterCreation(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " changes the rank of LP row"]
    pub fn SCIProwChgRank(row: *mut SCIP_ROW, rank: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " returns exact row corresponding to fprow, if it exists. Otherwise returns NULL"]
    pub fn SCIProwGetRowExact(row: *mut SCIP_ROW) -> *mut SCIP_ROWEXACT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiExact {
    _unused: [u8; 0],
}
pub type SCIP_LPIEXACT = SCIP_LPiExact;
unsafe extern "C" {
    #[doc = " comparison method for sorting rows by non-decreasing index"]
    pub fn SCIProwExactComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets variable this column represents"]
    pub fn SCIPcolExactGetVar(col: *mut SCIP_COLEXACT) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the left hand side of the row"]
    pub fn SCIProwExactGetLhs(row: *mut SCIP_ROWEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the right hand side of the row"]
    pub fn SCIProwExactGetRhs(row: *mut SCIP_ROWEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the constant of the row"]
    pub fn SCIProwExactGetConstant(row: *mut SCIP_ROWEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the length of a row"]
    pub fn SCIProwExactGetNNonz(row: *mut SCIP_ROWEXACT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIProwExactGetVals(row: *mut SCIP_ROWEXACT) -> *mut *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is member of current LP"]
    pub fn SCIProwExactIsInLP(row: *mut SCIP_ROWEXACT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sorts row entries such that LP columns precede non-LP columns and inside both parts lower column indices precede\n  higher ones"]
    pub fn SCIProwExactSort(row: *mut SCIP_ROWEXACT);
}
unsafe extern "C" {
    #[doc = " gets array of exact columns"]
    pub fn SCIProwExactGetCols(row: *mut SCIP_ROWEXACT) -> *mut *mut SCIP_COLEXACT;
}
unsafe extern "C" {
    #[doc = " locks an unmodifiable row, which forbids further changes; has no effect on modifiable rows"]
    pub fn SCIProwExactLock(row: *mut SCIP_ROWEXACT);
}
unsafe extern "C" {
    #[doc = " unlocks a lock of an unmodifiable row; a row with no sealed lock may be modified; has no effect on modifiable rows"]
    pub fn SCIProwExactUnlock(row: *mut SCIP_ROWEXACT);
}
unsafe extern "C" {
    #[doc = " returns fp row corresponding to exact row, if it exists. Otherwise returns NULL"]
    pub fn SCIProwExactGetRow(row: *mut SCIP_ROWEXACT) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " returns rhs-relaxation part of exact row, if it exists. Otherwise returns NULL"]
    pub fn SCIProwExactGetRowRhs(row: *mut SCIP_ROWEXACT) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " true if row can be relaxed (possibly as two fp rows)"]
    pub fn SCIProwExactHasFpRelax(row: *mut SCIP_ROWEXACT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the exact LP is in diving mode"]
    pub fn SCIPlpExactDiving(lpexact: *mut SCIP_LPEXACT) -> ::std::os::raw::c_uint;
}
#[doc = "< SCIP data structures are initialized, no problem exists"]
pub const SCIP_Stage_SCIP_STAGE_INIT: SCIP_Stage = 0;
#[doc = "< the problem is being created and modified"]
pub const SCIP_Stage_SCIP_STAGE_PROBLEM: SCIP_Stage = 1;
#[doc = "< the problem is being transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMING: SCIP_Stage = 2;
#[doc = "< the problem was transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMED: SCIP_Stage = 3;
#[doc = "< presolving is initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITPRESOLVE: SCIP_Stage = 4;
#[doc = "< the problem is being presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVING: SCIP_Stage = 5;
#[doc = "< presolving is exited"]
pub const SCIP_Stage_SCIP_STAGE_EXITPRESOLVE: SCIP_Stage = 6;
#[doc = "< the problem was presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVED: SCIP_Stage = 7;
#[doc = "< the solving process data is being initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITSOLVE: SCIP_Stage = 8;
#[doc = "< the problem is being solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVING: SCIP_Stage = 9;
#[doc = "< the problem was solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVED: SCIP_Stage = 10;
#[doc = "< the solving process data is being freed"]
pub const SCIP_Stage_SCIP_STAGE_EXITSOLVE: SCIP_Stage = 11;
#[doc = "< the transformed problem is being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREETRANS: SCIP_Stage = 12;
#[doc = "< SCIP data structures are being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREE: SCIP_Stage = 13;
#[doc = " SCIP operation stage"]
pub type SCIP_Stage = ::std::os::raw::c_uint;
#[doc = " SCIP operation stage"]
pub use self::SCIP_Stage as SCIP_STAGE;
#[doc = "< undefined setting"]
pub const SCIP_Setting_SCIP_UNDEFINED: SCIP_Setting = 0;
#[doc = "< feature is disabled"]
pub const SCIP_Setting_SCIP_DISABLED: SCIP_Setting = 1;
#[doc = "< feature is set to automatic mode"]
pub const SCIP_Setting_SCIP_AUTO: SCIP_Setting = 2;
#[doc = "< feature is enabled"]
pub const SCIP_Setting_SCIP_ENABLED: SCIP_Setting = 3;
#[doc = " possible settings for enabling/disabling algorithms and other features"]
pub type SCIP_Setting = ::std::os::raw::c_uint;
#[doc = " possible settings for enabling/disabling algorithms and other features"]
pub use self::SCIP_Setting as SCIP_SETTING;
#[doc = " global SCIP settings"]
pub type SCIP_SET = SCIP_Set;
unsafe extern "C" {
    #[doc = " gets constant"]
    pub fn SCIPnlrowGetConstant(nlrow: *mut SCIP_NLROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of variables of linear part"]
    pub fn SCIPnlrowGetNLinearVars(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with variables of linear part"]
    pub fn SCIPnlrowGetLinearVars(nlrow: *mut SCIP_NLROW) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array with coefficients in linear part"]
    pub fn SCIPnlrowGetLinearCoefs(nlrow: *mut SCIP_NLROW) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets expression"]
    pub fn SCIPnlrowGetExpr(nlrow: *mut SCIP_NLROW) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " returns the left hand side of a nonlinear row"]
    pub fn SCIPnlrowGetLhs(nlrow: *mut SCIP_NLROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the right hand side of a nonlinear row"]
    pub fn SCIPnlrowGetRhs(nlrow: *mut SCIP_NLROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the curvature of a nonlinear row"]
    pub fn SCIPnlrowGetCurvature(nlrow: *mut SCIP_NLROW) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " returns the name of a nonlinear row"]
    pub fn SCIPnlrowGetName(nlrow: *mut SCIP_NLROW) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets position of a nonlinear row in current NLP, or -1 if not in NLP"]
    pub fn SCIPnlrowGetNLPPos(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff row is member of current NLP"]
    pub fn SCIPnlrowIsInNLP(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the dual NLP solution of a nlrow\n\n for a ranged constraint, the dual value is positive if the right hand side is active and negative if the left hand side is active"]
    pub fn SCIPnlrowGetDualsol(nlrow: *mut SCIP_NLROW) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MatrixValsExact {
    _unused: [u8; 0],
}
pub type SCIP_MATRIXVALSEXACT = SCIP_MatrixValsExact;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Matrix {
    _unused: [u8; 0],
}
pub type SCIP_MATRIX = SCIP_Matrix;
unsafe extern "C" {
    #[doc = " get column based start pointer of values"]
    pub fn SCIPmatrixGetColValPtr(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int)
    -> *mut f64;
}
unsafe extern "C" {
    #[doc = " get column based start pointer of row indices"]
    pub fn SCIPmatrixGetColIdxPtr(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get the number of non-zero entries of this column"]
    pub fn SCIPmatrixGetColNNonzs(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of columns of the matrix"]
    pub fn SCIPmatrixGetNColumns(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get upper bound of column"]
    pub fn SCIPmatrixGetColUb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " get lower bound of column"]
    pub fn SCIPmatrixGetColLb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " get number of uplocks of column"]
    pub fn SCIPmatrixGetColNUplocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of downlocks of column"]
    pub fn SCIPmatrixGetColNDownlocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get variable pointer of column"]
    pub fn SCIPmatrixGetVar(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " get name of column/variable"]
    pub fn SCIPmatrixGetColName(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " get row based start pointer of values"]
    pub fn SCIPmatrixGetRowValPtr(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
    -> *mut f64;
}
unsafe extern "C" {
    #[doc = " get row based start pointer of values"]
    pub fn SCIPmatrixGetRowValPtrExact(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " get row based start pointer of column indices"]
    pub fn SCIPmatrixGetRowIdxPtr(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of non-zeros of this row"]
    pub fn SCIPmatrixGetRowNNonzs(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get name of row"]
    pub fn SCIPmatrixGetRowName(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " get number of rows of the matrix"]
    pub fn SCIPmatrixGetNRows(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get left-hand-side of row"]
    pub fn SCIPmatrixGetRowLhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " get right-hand-side of row"]
    pub fn SCIPmatrixGetRowRhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " get left-hand-side of row"]
    pub fn SCIPmatrixGetRowLhsExact(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " get right-hand-side of row"]
    pub fn SCIPmatrixGetRowRhsExact(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " flag indicating if right-hand-side of row is infinity"]
    pub fn SCIPmatrixIsRowRhsInfinity(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " get number of non-zeros of matrix"]
    pub fn SCIPmatrixGetNNonzs(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get minimal activity of row"]
    pub fn SCIPmatrixGetRowMinActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
    -> f64;
}
unsafe extern "C" {
    #[doc = " get maximal activity of row"]
    pub fn SCIPmatrixGetRowMaxActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
    -> f64;
}
unsafe extern "C" {
    #[doc = " get number of negative infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of positive infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of negative infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of positive infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get constraint pointer for constraint representing row"]
    pub fn SCIPmatrixGetCons(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " get if conflicting uplocks of variable present"]
    pub fn SCIPmatrixUplockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " get if conflicting downlocks of variable present"]
    pub fn SCIPmatrixDownlockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " initialize matrix by copying all check constraints\n\n  @note Completeness is checked by testing whether all check constraints are from a list of linear constraint handlers\n        that can be represented."]
    pub fn SCIPmatrixCreate(
        scip: *mut SCIP,
        matrixptr: *mut *mut SCIP_MATRIX,
        onlyifcomplete: ::std::os::raw::c_uint,
        initialized: *mut ::std::os::raw::c_uint,
        complete: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the constraint matrix"]
    pub fn SCIPmatrixFree(scip: *mut SCIP, matrix: *mut *mut SCIP_MATRIX);
}
unsafe extern "C" {
    #[doc = " print one row of the MIP matrix"]
    pub fn SCIPmatrixPrintRow(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " detect parallel rows, rhs/lhs are ignored"]
    pub fn SCIPmatrixGetParallelRows(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes the bounds of a column and updates the activities accordingly"]
    pub fn SCIPmatrixRemoveColumnBounds(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " detect parallel columns, obj ignored"]
    pub fn SCIPmatrixGetParallelCols(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
        varineq: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
pub type __gnuc_va_list = __builtin_va_list;
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __len: isize,
    );
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Creates and captures a message handler which deals with warning, information, and dialog (interactive shell) methods.\n\n  Use SCIPsetMessagehdlr() to make SCIP aware of the created message handler.\n  @note The message handler does not handle error messages. For that see SCIPmessageSetErrorPrinting()\n  @note Creating a message handler automatically captures it."]
    pub fn SCIPmessagehdlrCreate(
        messagehdlr: *mut *mut SCIP_MESSAGEHDLR,
        bufferedoutput: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        quiet: ::std::os::raw::c_uint,
        messagewarning: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagedialog: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messageinfo: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagehdlrfree: ::std::option::Option<
            unsafe extern "C" fn(messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE,
        >,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " captures message handler"]
    pub fn SCIPmessagehdlrCapture(messagehdlr: *mut SCIP_MESSAGEHDLR);
}
unsafe extern "C" {
    #[doc = " releases message handler"]
    pub fn SCIPmessagehdlrRelease(messagehdlr: *mut *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the user data of the message handler"]
    pub fn SCIPmessagehdlrSetData(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the log file name for the message handler"]
    pub fn SCIPmessagehdlrSetLogfile(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        filename: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " sets the messages handler to be quiet"]
    pub fn SCIPmessagehdlrSetQuiet(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        quiet: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn SCIPmessagePrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessageFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessagePrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a warning message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessageFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a warning message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessagePrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a dialog message that requests user interaction, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessageFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a dialog message that requests user interaction into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessagePrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a message depending on the verbosity level, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    pub fn SCIPmessageFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " prints a message into a file depending on the verbosity level, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
unsafe extern "C" {
    #[doc = " prints the header with source file location for an error message using the static message handler"]
    pub fn SCIPmessagePrintErrorHeader(
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn SCIPmessagePrintError(formatstr: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    #[doc = " prints an error message, acting like the vprintf() command using the static message handler"]
    pub fn SCIPmessageVPrintError(formatstr: *const ::std::os::raw::c_char, ap: va_list);
}
unsafe extern "C" {
    #[doc = " Method to set the error printing method. Setting the error printing method to NULL will suspend all error methods.\n\n  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrinting(
        errorPrinting: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Method to set the error printing method to default version prints everything the stderr.\n\n  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrintingDefault();
}
unsafe extern "C" {
    #[doc = " returns the user data of the message handler"]
    pub fn SCIPmessagehdlrGetData(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut SCIP_MESSAGEHDLRDATA;
}
unsafe extern "C" {
    #[doc = " returns the log file or NULL for stdout"]
    pub fn SCIPmessagehdlrGetLogfile(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut FILE;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the message handler is set to be quiet"]
    pub fn SCIPmessagehdlrIsQuiet(messagehdlr: *mut SCIP_MESSAGEHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/pointers/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntPtrPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of ints/ints/pointers/pointers/interval, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntPtrPtrInterval(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intervalarray: *mut SCIP_INTERVAL,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/pointers/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntPtrPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of ints/ints/pointers/pointers/interval, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntPtrPtrInterval(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intervalarray: *mut SCIP_INTERVAL,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the \\p k-th element"]
    pub fn SCIPselectDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity"]
    pub fn SCIPselectWeightedDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,\n  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " default comparer for integers"]
    pub fn SCIPsortCompInt(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " implements argsort\n\n The data pointer is a lookup array of integers."]
    pub fn SCIPsortArgsortInt(
        dataptr: *mut ::std::os::raw::c_void,
        ind1: ::std::os::raw::c_int,
        ind2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " implements argsort\n\n The data pointer is a lookup array, which are pointer arrays."]
    pub fn SCIPsortArgsortPtr(
        dataptr: *mut ::std::os::raw::c_void,
        ind1: ::std::os::raw::c_int,
        ind2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sort an indexed element set in non-decreasing order, resulting in a permutation index array"]
    pub fn SCIPsort(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an index array in non-decreasing order"]
    pub fn SCIPsortInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of an array of pointers in non-decreasing order"]
    pub fn SCIPsortPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an array of Reals in non-decreasing order"]
    pub fn SCIPsortReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Pointers/Pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort array of ints in non-decreasing order"]
    pub fn SCIPsortInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/pointers/pointers/ sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntPtrPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of ints/ints/pointers/pointers/pointers sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntPtrPtrInterval(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intervalarray: *mut SCIP_INTERVAL,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an array of Longints in non-decreasing order"]
    pub fn SCIPsortLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an indexed element set in non-increasing order, resulting in a permutation index array"]
    pub fn SCIPsortDown(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an index array in non-increasing order"]
    pub fn SCIPsortDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of an array of pointers in non-increasing order"]
    pub fn SCIPsortDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an array of Reals in non-increasing order"]
    pub fn SCIPsortDownReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort array of ints in non-increasing order"]
    pub fn SCIPsortDownInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort an array of Longints in non-increasing order"]
    pub fn SCIPsortDownLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an index array in non-decreasing order"]
    pub fn SCIPsortedvecInsertInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecInsertInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntPtrPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntPtrPtrInterval(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intervalarray: *mut SCIP_INTERVAL,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        field3val: *mut ::std::os::raw::c_void,
        field4val: SCIP_INTERVAL,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an index array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealInt(
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of ints in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/int/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increased order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an index array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals//ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals/SCIP_Bools/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecDelPosReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntPtrPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of ints/ints/pointers/pointers/interval, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntPtrPtrInterval(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intervalarray: *mut SCIP_INTERVAL,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted by in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an index array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from two arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search.\n  If the element exists, the method returns TRUE and stores the position of the element in '*pos'.\n  If the element does not exist, the method returns FALSE and stores the position of the element that follows\n  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted.\n  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the right-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetRhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the left-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetLhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns exact the right-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetRhsExact(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the exact left-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetLhsExact(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the value array of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPgetConsVals(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vals: *mut f64,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the exact value array of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPgetConsValsExact(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vals: *mut *mut SCIP_RATIONAL,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the dual farkas solution of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the dual farkas solution"]
    pub fn SCIPconsGetDualfarkas(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualfarkas: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the dual solution of an arbitrary SCIP constraint that can be represented as a single linear constraint\n\n  @note The success pointer indicates if the individual contraint handler was able to return the dual solution"]
    pub fn SCIPconsGetDualsol(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsol: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the row of an arbitrary SCIP constraint that can be represented as a single linear constraint\n  or NULL of no row is available"]
    pub fn SCIPconsGetRow(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    pub fn SCIPconsCreateRow(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        row: *mut *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds the given variable to the input constraint.\n  If the constraint is setppc or logicor the value is ignored. If the constraint is knapsack, then the value is\n  converted to an int. A warning is passed if the SCIP_Real is not an integer.\n  TODO: Allow val to be a pointer."]
    pub fn SCIPconsAddCoef(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_ROWPREP datastructure\n\n Initial row represents 0 &le; 0."]
    pub fn SCIPcreateRowprep(
        scip: *mut SCIP,
        rowprep: *mut *mut SCIP_ROWPREP,
        sidetype: SCIP_SIDETYPE,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a SCIP_ROWPREP datastructure"]
    pub fn SCIPfreeRowprep(scip: *mut SCIP, rowprep: *mut *mut SCIP_ROWPREP);
}
unsafe extern "C" {
    #[doc = " creates a copy of a SCIP_ROWPREP datastructure"]
    pub fn SCIPcopyRowprep(
        scip: *mut SCIP,
        target: *mut *mut SCIP_ROWPREP,
        source: *mut SCIP_ROWPREP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives number of terms in rowprep"]
    pub fn SCIProwprepGetNVars(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives variables of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetVars(rowprep: *mut SCIP_ROWPREP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gives coefficients of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetCoefs(rowprep: *mut SCIP_ROWPREP) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gives side of rowprep"]
    pub fn SCIProwprepGetSide(rowprep: *mut SCIP_ROWPREP) -> f64;
}
unsafe extern "C" {
    #[doc = " gives kind of inequality of rowprep"]
    pub fn SCIProwprepGetSidetype(rowprep: *mut SCIP_ROWPREP) -> SCIP_SIDETYPE;
}
unsafe extern "C" {
    #[doc = " returns whether rowprep is locally valid only"]
    pub fn SCIProwprepIsLocal(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns name of rowprep (feel free to modify)"]
    pub fn SCIProwprepGetName(rowprep: *mut SCIP_ROWPREP) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns number of variables which coefficients were modified in cleanup"]
    pub fn SCIProwprepGetNModifiedVars(rowprep: *mut SCIP_ROWPREP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns variables which coefficients were modified in cleanup"]
    pub fn SCIProwprepGetModifiedVars(rowprep: *mut SCIP_ROWPREP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " resets rowprep to have 0 terms and side 0.0"]
    pub fn SCIProwprepReset(rowprep: *mut SCIP_ROWPREP);
}
unsafe extern "C" {
    #[doc = " sets coefficient idx of rowprep"]
    pub fn SCIProwprepSetCoef(rowprep: *mut SCIP_ROWPREP, idx: ::std::os::raw::c_int, newcoef: f64);
}
unsafe extern "C" {
    #[doc = " adds constant value to side of rowprep"]
    pub fn SCIProwprepAddSide(rowprep: *mut SCIP_ROWPREP, side: f64);
}
unsafe extern "C" {
    #[doc = " adds constant term to rowprep\n\n Substracts constant from side."]
    pub fn SCIProwprepAddConstant(rowprep: *mut SCIP_ROWPREP, constant: f64);
}
unsafe extern "C" {
    #[doc = " sets side type of rowprep"]
    pub fn SCIProwprepSetSidetype(rowprep: *mut SCIP_ROWPREP, sidetype: SCIP_SIDETYPE);
}
unsafe extern "C" {
    #[doc = " sets whether rowprep is local"]
    pub fn SCIProwprepSetLocal(rowprep: *mut SCIP_ROWPREP, islocal: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " enables recording for where modifications were done in cleanup"]
    pub fn SCIProwprepRecordModifications(rowprep: *mut SCIP_ROWPREP);
}
unsafe extern "C" {
    #[doc = " prints a rowprep"]
    pub fn SCIPprintRowprep(scip: *mut SCIP, rowprep: *mut SCIP_ROWPREP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " prints a rowprep and values in solution"]
    pub fn SCIPprintRowprepSol(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " ensures that rowprep has space for at least given number of additional terms\n\n Useful when knowing in advance how many terms will be added."]
    pub fn SCIPensureRowprepSize(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a term coef*var to a rowprep"]
    pub fn SCIPaddRowprepTerm(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds several terms coef*var to a rowprep"]
    pub fn SCIPaddRowprepTerms(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes violation of rowprep in a given solution\n\n Can return whether the violation value is reliable from a floating-point accuracy point of view.\n The value will not be deemed reliable when its calculation involved the subtraction of large numbers.\n To be precise, the violation of an inequality \\f$ \\sum_i a_ix_i \\leq b \\f$ in a solution \\f$x^*\\f$ is deemed\n reliable if \\f$ |\\sum_i a_ix^*_i - b| \\geq 2^{-50} \\max (|b|, \\max_i |a_ix^*_i|) \\f$."]
    pub fn SCIPgetRowprepViolation(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        reliable: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " computes violation of rowprep in a given solution and reports whether that value seem numerically reliable\n\n @see SCIPgetRowprepViolation()"]
    pub fn SCIPisRowprepViolationReliable(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Merge terms that use same variable and eliminate zero coefficients.\n\n Removes a variable if its bounds have a relative difference of below epsilon.\n Local bounds are checked for local rows, otherwise global bounds are used.\n If the bounds are not absolute equal, the bound that relaxes the row is used.\n\n Terms are sorted by variable (see SCIPvarComp()) after return."]
    pub fn SCIPmergeRowprepTerms(scip: *mut SCIP, rowprep: *mut SCIP_ROWPREP);
}
unsafe extern "C" {
    #[doc = " Cleans up and attempts to improve rowprep\n\n Drops small or large coefficients if their ratio is beyond separating/maxcoefratiofacrowprep / numerics/feastol,\n if this can be done by relaxing the row.\n Scales coefficients up to reach minimal violation, if possible.\n Scaling is omitted if violation is very small (\\ref ROWPREP_SCALEUP_VIOLNONZERO) or\n maximal coefficient would become huge (\\ref ROWPREP_SCALEUP_MAXMAXCOEF).\n Scales coefficients and side down if they are large and if the minimal violation is still reached.\n Rounds coefficients close to integral values to integrals, if this can be done by relaxing the row.\n Rounds side within epsilon of 0 to 0.0 or +/-1.1*epsilon, whichever relaxes the row least.\n\n After return, the terms in the rowprep will be sorted by absolute value of coefficient, in decreasing order.\n Thus, the coefratio can be obtained via `REALABS(rowprep->coefs[0]) / REALABS(rowprep->coefs[rowprep->nvars-1])` (if nvars>0).\n\n `success` is set to TRUE if and only if the rowprep satisfies the following:\n - the coefratio is below separating/maxcoefratiofacrowprep / numerics/feastol\n - the violation is at least `minviol`\n - the violation is reliable or `minviol` = 0\n - the absolute value of coefficients are below SCIPinfinity()\n - the absolute value of the side is below SCIPinfinity()"]
    pub fn SCIPcleanupRowprep(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        minviol: f64,
        viol: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Cleans up and attempts to improve rowprep without regard for violation\n\n Drops small or large coefficients if their ratio is beyond separating/maxcoefratiofacrowprep / numerics/feastol,\n if this can be done by relaxing the row.\n Scales coefficients and side to have maximal coefficient in `[1/maxcoefbound,maxcoefbound]`.\n Rounds coefficients close to integral values to integrals, if this can be done by relaxing the row.\n Rounds side within epsilon of 0 to 0.0 or +/-1.1*epsilon, whichever relaxes the row least.\n\n After return, the terms in the rowprep will be sorted by absolute value of coefficient, in decreasing order.\n Thus, the coefratio can be obtained via `REALABS(rowprep->coefs[0]) / REALABS(rowprep->coefs[rowprep->nvars-1])` (if nvars>0).\n\n `success` is set to TRUE if and only if the rowprep satisfies the following:\n - the coefratio is below separating/maxcoefratiofacrowprep / numerics/feastol\n - the absolute value of coefficients are below SCIPinfinity()\n - the absolute value of the side is below SCIPinfinity()\n\n In difference to SCIPcleanupRowprep(), this function does not scale up the row to increase the absolute violation."]
    pub fn SCIPcleanupRowprep2(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        sol: *mut SCIP_SOL,
        maxcoefbound: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Scales up a rowprep to increase coefficients/sides that are within epsilon to an integer value, if possible.\n\n Computes the minimal fractionality of all fractional coefficients and the side of the rowprep.\n If this fractionality is below epsilon, the rowprep is scaled up such that the fractionality exceeds epsilon,\n if this will not put any coefficient or side above SCIPhugeValue().\n\n This function does not relax the rowprep.\n\n `success` is set to TRUE if the resulting rowprep can be turned into a SCIP_ROW, that is,\n all coefs and the side is below SCIPinfinity() and fractionalities are above epsilon.\n If `success` is set to FALSE, then the rowprep will not have been modified.\n\n @return The applied scaling factor, if `success` is set to TRUE."]
    pub fn SCIPscaleupRowprep(
        scip: *mut SCIP,
        rowprep: *mut SCIP_ROWPREP,
        minscaleup: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " scales a rowprep by given factor (after some rounding)\n\n @return Exponent of actually applied scaling factor, if written as \\f$2^x\\f$."]
    pub fn SCIPscaleRowprep(rowprep: *mut SCIP_ROWPREP, factor: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given constraint handler"]
    pub fn SCIPgetRowprepRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given constraint"]
    pub fn SCIPgetRowprepRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " generates a SCIP_ROW from a rowprep, setting its origin to given separator"]
    pub fn SCIPgetRowprepRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        rowprep: *mut SCIP_ROWPREP,
        sepa: *mut SCIP_SEPA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get critical value of a Student-T distribution for a given number of degrees of freedom at a confidence level"]
    pub fn SCIPstudentTGetCriticalValue(
        clevel: SCIP_CONFIDENCELEVEL,
        df: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " compute a t-value for the hypothesis that x and y are from the same population; Assuming that\n  x and y represent normally distributed random samples with equal variance, the returned value\n  comes from a Student-T distribution with countx + county - 2 degrees of freedom; this\n  value can be compared with a critical value (see also SCIPstudentTGetCriticalValue()) at\n  a predefined confidence level for checking if x and y significantly differ in location"]
    pub fn SCIPcomputeTwoSampleTTestValue(
        meanx: f64,
        meany: f64,
        variancex: f64,
        variancey: f64,
        countx: f64,
        county: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the value of the Gauss error function evaluated at a given point"]
    pub fn SCIPerf(x: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " get critical value of a standard normal distribution  at a given confidence level"]
    pub fn SCIPnormalGetCriticalValue(clevel: SCIP_CONFIDENCELEVEL) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the cumulative distribution P(-infinity <= x <= value) that a normally distributed\n  random variable x takes a value between -infinity and parameter \\p value.\n\n  The distribution is given by the respective mean and deviation. This implementation\n  uses the error function erf()."]
    pub fn SCIPnormalCDF(mean: f64, variance: f64, value: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the number of observations of this regression"]
    pub fn SCIPregressionGetNObservations(
        regression: *mut SCIP_REGRESSION,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return the current slope of the regression"]
    pub fn SCIPregressionGetSlope(regression: *mut SCIP_REGRESSION) -> f64;
}
unsafe extern "C" {
    #[doc = " get the current y-intercept of the regression"]
    pub fn SCIPregressionGetIntercept(regression: *mut SCIP_REGRESSION) -> f64;
}
unsafe extern "C" {
    #[doc = " removes an observation (x,y) from the regression"]
    pub fn SCIPregressionRemoveObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
unsafe extern "C" {
    #[doc = " update regression by a new observation (x,y)"]
    pub fn SCIPregressionAddObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
unsafe extern "C" {
    #[doc = " reset regression data structure"]
    pub fn SCIPregressionReset(regression: *mut SCIP_REGRESSION);
}
unsafe extern "C" {
    #[doc = " creates and resets a regression"]
    pub fn SCIPregressionCreate(regression: *mut *mut SCIP_REGRESSION) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a regression"]
    pub fn SCIPregressionFree(regression: *mut *mut SCIP_REGRESSION);
}
unsafe extern "C" {
    #[doc = " writes a node section to the given graph file"]
    pub fn SCIPgmlWriteNode(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " writes a node section including weight to the given graph file"]
    pub fn SCIPgmlWriteNodeWeight(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
        weight: f64,
    );
}
unsafe extern "C" {
    #[doc = " writes an edge section to the given graph file"]
    pub fn SCIPgmlWriteEdge(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " writes an arc section to the given graph file"]
    pub fn SCIPgmlWriteArc(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " writes the starting line to a GML graph file, does not open a file"]
    pub fn SCIPgmlWriteOpening(file: *mut FILE, directed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " writes the ending lines to a GML graph file, does not close a file"]
    pub fn SCIPgmlWriteClosing(file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " writes the opening line to a dot graph file, does not open a file"]
    pub fn SCIPdotWriteOpening(file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " adds a node to the dot graph"]
    pub fn SCIPdotWriteNode(
        file: *mut FILE,
        node: ::std::os::raw::c_int,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " adds an arc (edge) between two nodes in the dot graph"]
    pub fn SCIPdotWriteArc(
        file: *mut FILE,
        source: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        color: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " writes the closing line to a dot graph file, does not close a file"]
    pub fn SCIPdotWriteClosing(file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " creates a sparse solution"]
    pub fn SCIPsparseSolCreate(
        sparsesol: *mut *mut SCIP_SPARSESOL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cleared: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees sparse solution"]
    pub fn SCIPsparseSolFree(sparsesol: *mut *mut SCIP_SPARSESOL);
}
unsafe extern "C" {
    #[doc = " returns the variables in the given sparse solution"]
    pub fn SCIPsparseSolGetVars(sparsesol: *mut SCIP_SPARSESOL) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the number of variables in the given sparse solution"]
    pub fn SCIPsparseSolGetNVars(sparsesol: *mut SCIP_SPARSESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the the lower bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetLbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the the upper bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetUbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " constructs the first solution of sparse solution (all variables are set to their lower bound value"]
    pub fn SCIPsparseSolGetFirstSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " constructs the next solution of the sparse solution and return whether there was one more or not"]
    pub fn SCIPsparseSolGetNextSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates a (circular) queue, best used if the size will be fixed or will not be increased that much"]
    pub fn SCIPqueueCreate(
        queue: *mut *mut SCIP_QUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees queue, but not the data elements themselves"]
    pub fn SCIPqueueFree(queue: *mut *mut SCIP_QUEUE);
}
unsafe extern "C" {
    #[doc = " clears the queue, but doesn't free the data elements themselves"]
    pub fn SCIPqueueClear(queue: *mut SCIP_QUEUE);
}
unsafe extern "C" {
    #[doc = " inserts pointer element at the end of the queue"]
    pub fn SCIPqueueInsert(
        queue: *mut SCIP_QUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts unsigned integer element at the end of the queue"]
    pub fn SCIPqueueInsertUInt(
        queue: *mut SCIP_QUEUE,
        elem: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes and returns the first element of the queue, or NULL if no element exists"]
    pub fn SCIPqueueRemove(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " removes and returns the first unsigned integer element of the queue, or UNIT_MAX if no element exists"]
    pub fn SCIPqueueRemoveUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the first element of the queue without removing it, or NULL if no element exists"]
    pub fn SCIPqueueFirst(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns the first unsigned integer element of the queue without removing it, or UINT_MAX if no element exists"]
    pub fn SCIPqueueFirstUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the queue is empty"]
    pub fn SCIPqueueIsEmpty(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPqueueNElems(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates priority queue"]
    pub fn SCIPpqueueCreate(
        pqueue: *mut *mut SCIP_PQUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        elemchgpos: ::std::option::Option<
            unsafe extern "C" fn(
                elem: *mut ::std::os::raw::c_void,
                oldpos: ::std::os::raw::c_int,
                newpos: ::std::os::raw::c_int,
            ),
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees priority queue, but not the data elements themselves"]
    pub fn SCIPpqueueFree(pqueue: *mut *mut SCIP_PQUEUE);
}
unsafe extern "C" {
    #[doc = " clears the priority queue, but doesn't free the data elements themselves"]
    pub fn SCIPpqueueClear(pqueue: *mut SCIP_PQUEUE);
}
unsafe extern "C" {
    #[doc = " inserts element into priority queue"]
    pub fn SCIPpqueueInsert(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " delete element at specified position, maintaining the heap property"]
    pub fn SCIPpqueueDelPos(pqueue: *mut SCIP_PQUEUE, pos: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " removes and returns best element from the priority queue"]
    pub fn SCIPpqueueRemove(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns the best element of the queue without removing it"]
    pub fn SCIPpqueueFirst(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPpqueueNElems(pqueue: *mut SCIP_PQUEUE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the elements of the queue; changing the returned array may destroy the queue's ordering!"]
    pub fn SCIPpqueueElems(pqueue: *mut SCIP_PQUEUE) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " return the position of @p elem in the priority queue, or -1 if element is not found"]
    pub fn SCIPpqueueFind(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a hash table"]
    pub fn SCIPhashtableCreate(
        hashtable: *mut *mut SCIP_HASHTABLE,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the hash table"]
    pub fn SCIPhashtableFree(hashtable: *mut *mut SCIP_HASHTABLE);
}
unsafe extern "C" {
    #[doc = " inserts element in hash table (multiple inserts of same element override the previous entry)"]
    pub fn SCIPhashtableInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts element in hash table (multiple insertion of same element is checked and results in an error)"]
    pub fn SCIPhashtableSafeInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retrieve element with key from hash table, returns NULL if not existing"]
    pub fn SCIPhashtableRetrieve(
        hashtable: *mut SCIP_HASHTABLE,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns whether the given element exists in the table"]
    pub fn SCIPhashtableExists(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " removes element from the hash table, if it exists"]
    pub fn SCIPhashtableRemove(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all elements of the hash table"]
    pub fn SCIPhashtableRemoveAll(hashtable: *mut SCIP_HASHTABLE);
}
unsafe extern "C" {
    #[doc = " returns number of hash table elements"]
    pub fn SCIPhashtableGetNElements(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash table"]
    pub fn SCIPhashtableGetNEntries(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the element at the given index or NULL if entry at that index has no element"]
    pub fn SCIPhashtableGetEntry(
        hashtable: *mut SCIP_HASHTABLE,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns the load of the given hash table in percentage"]
    pub fn SCIPhashtableGetLoad(hashtable: *mut SCIP_HASHTABLE) -> f64;
}
unsafe extern "C" {
    #[doc = " prints statistics about hash table usage"]
    pub fn SCIPhashtablePrintStatistics(
        hashtable: *mut SCIP_HASHTABLE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
unsafe extern "C" {
    #[doc = " returns a reasonable hash table size (a prime number) that is at least as large as the specified value"]
    pub fn SCIPcalcMultihashSize(minsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a multihash table"]
    pub fn SCIPmultihashCreate(
        multihash: *mut *mut SCIP_MULTIHASH,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the multihash table"]
    pub fn SCIPmultihashFree(multihash: *mut *mut SCIP_MULTIHASH);
}
unsafe extern "C" {
    #[doc = " inserts element in multihash table (multiple inserts of same element possible)\n\n  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding an element\n        to the hash table, due to dynamic resizing."]
    pub fn SCIPmultihashInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts element in multihash table (multiple insertion of same element is checked and results in an error)\n\n  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding a new\n        element to the multihash table, due to dynamic resizing."]
    pub fn SCIPmultihashSafeInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing"]
    pub fn SCIPmultihashRetrieve(
        multihash: *mut SCIP_MULTIHASH,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing\n  can be used to retrieve all entries with the same key (one-by-one)\n\n  @note The returned multimultihashlist pointer might get invalid when adding a new element to the multihash table."]
    pub fn SCIPmultihashRetrieveNext(
        multihash: *mut SCIP_MULTIHASH,
        multihashlist: *mut *mut SCIP_MULTIHASHLIST,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns whether the given element exists in the multihash table"]
    pub fn SCIPmultihashExists(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " removes element from the multihash table, if it exists"]
    pub fn SCIPmultihashRemove(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all elements of the multihash table\n\n  @note From a performance point of view you should not fill and clear a hash table too often since the clearing can\n        be expensive. Clearing is done by looping over all buckets and removing the hash table lists one-by-one."]
    pub fn SCIPmultihashRemoveAll(multihash: *mut SCIP_MULTIHASH);
}
unsafe extern "C" {
    #[doc = " returns number of multihash table elements"]
    pub fn SCIPmultihashGetNElements(multihash: *mut SCIP_MULTIHASH) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the load of the given multihash table in percentage"]
    pub fn SCIPmultihashGetLoad(multihash: *mut SCIP_MULTIHASH) -> f64;
}
unsafe extern "C" {
    #[doc = " prints statistics about multihash table usage"]
    pub fn SCIPmultihashPrintStatistics(
        multihash: *mut SCIP_MULTIHASH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
unsafe extern "C" {
    #[doc = " standard hash key comparator for string keys"]
    pub fn SCIPhashKeyEqString(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " standard hashing function for string keys"]
    pub fn SCIPhashKeyValString(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " gets the element as the key"]
    pub fn SCIPhashGetKeyStandard(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff both keys(pointer) are equal"]
    pub fn SCIPhashKeyEqPtr(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the hash value of the key"]
    pub fn SCIPhashKeyValPtr(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " creates a hash map mapping pointers to pointers"]
    pub fn SCIPhashmapCreate(
        hashmap: *mut *mut SCIP_HASHMAP,
        blkmem: *mut BMS_BLKMEM,
        mapsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the hash map"]
    pub fn SCIPhashmapFree(hashmap: *mut *mut SCIP_HASHMAP);
}
unsafe extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsert(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertLong(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or NULL if no image exists"]
    pub fn SCIPhashmapGetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or INT_MAX if no image exists"]
    pub fn SCIPhashmapGetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or SCIP_LONGINT_MAX if no image exists"]
    pub fn SCIPhashmapGetImageLong(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or SCIP_INVALID if no image exists"]
    pub fn SCIPhashmapGetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a\n  new origin->image pair"]
    pub fn SCIPhashmapSetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether an image to the given origin exists in the hash map"]
    pub fn SCIPhashmapExists(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " removes origin->image pair from the hash map, if it exists"]
    pub fn SCIPhashmapRemove(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints statistics about hash map usage"]
    pub fn SCIPhashmapPrintStatistics(
        hashmap: *mut SCIP_HASHMAP,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
unsafe extern "C" {
    #[doc = " indicates whether a hash map has no entries"]
    pub fn SCIPhashmapIsEmpty(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives the number of elements in a hash map"]
    pub fn SCIPhashmapGetNElements(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash map"]
    pub fn SCIPhashmapGetNEntries(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the hashmap entry at the given index or NULL if entry has no element"]
    pub fn SCIPhashmapGetEntry(
        hashmap: *mut SCIP_HASHMAP,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut SCIP_HASHMAPENTRY;
}
unsafe extern "C" {
    #[doc = " gives the origin of the hashmap entry"]
    pub fn SCIPhashmapEntryGetOrigin(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImage(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageInt(entry: *mut SCIP_HASHMAPENTRY) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageReal(entry: *mut SCIP_HASHMAPENTRY) -> f64;
}
unsafe extern "C" {
    #[doc = " sets pointer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImage(
        entry: *mut SCIP_HASHMAPENTRY,
        image: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " sets integer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageInt(entry: *mut SCIP_HASHMAPENTRY, image: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sets real image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageReal(entry: *mut SCIP_HASHMAPENTRY, image: f64);
}
unsafe extern "C" {
    #[doc = " removes all entries in a hash map."]
    pub fn SCIPhashmapRemoveAll(hashmap: *mut SCIP_HASHMAP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a hash set of pointers"]
    pub fn SCIPhashsetCreate(
        hashset: *mut *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the hash set"]
    pub fn SCIPhashsetFree(hashset: *mut *mut SCIP_HASHSET, blkmem: *mut BMS_BLKMEM);
}
unsafe extern "C" {
    #[doc = " inserts new element into the hash set"]
    pub fn SCIPhashsetInsert(
        hashset: *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether an element exists in the hash set"]
    pub fn SCIPhashsetExists(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " removes an element from the hash set, if it exists"]
    pub fn SCIPhashsetRemove(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints statistics about hash set usage"]
    pub fn SCIPhashsetPrintStatistics(
        hashset: *mut SCIP_HASHSET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
unsafe extern "C" {
    #[doc = " indicates whether a hash set has no entries"]
    pub fn SCIPhashsetIsEmpty(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives the number of elements in a hash set"]
    pub fn SCIPhashsetGetNElements(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the number of slots of a hash set"]
    pub fn SCIPhashsetGetNSlots(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives the array of hash set slots; contains all elements in indetermined order and may contain NULL values"]
    pub fn SCIPhashsetGetSlots(hashset: *mut SCIP_HASHSET) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " removes all entries in a hash set."]
    pub fn SCIPhashsetRemoveAll(hashset: *mut SCIP_HASHSET);
}
unsafe extern "C" {
    #[doc = " create a resource activity"]
    pub fn SCIPactivityCreate(
        activity: *mut *mut SCIP_RESOURCEACTIVITY,
        var: *mut SCIP_VAR,
        duration: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a resource activity"]
    pub fn SCIPactivityFree(activity: *mut *mut SCIP_RESOURCEACTIVITY);
}
unsafe extern "C" {
    #[doc = " returns the start time variable of the resource activity"]
    pub fn SCIPactivityGetVar(activity: *mut SCIP_RESOURCEACTIVITY) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the duration of the resource activity"]
    pub fn SCIPactivityGetDuration(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the demand of the resource activity"]
    pub fn SCIPactivityGetDemand(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the energy of the resource activity"]
    pub fn SCIPactivityGetEnergy(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates resource profile"]
    pub fn SCIPprofileCreate(
        profile: *mut *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees given resource profile"]
    pub fn SCIPprofileFree(profile: *mut *mut SCIP_PROFILE);
}
unsafe extern "C" {
    #[doc = " output of the given resource profile"]
    pub fn SCIPprofilePrint(
        profile: *mut SCIP_PROFILE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " returns the capacity of the resource profile"]
    pub fn SCIPprofileGetCapacity(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number time points of the resource profile"]
    pub fn SCIPprofileGetNTimepoints(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the time points of the resource profile"]
    pub fn SCIPprofileGetTimepoints(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the loads of the resource profile"]
    pub fn SCIPprofileGetLoads(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the time point for given position of the resource profile"]
    pub fn SCIPprofileGetTime(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the loads of the resource profile at the given position"]
    pub fn SCIPprofileGetLoad(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns if the given time point exists in the resource profile and stores the position of the given time point if it\n  exists; otherwise the position of the next smaller existing time point is stored"]
    pub fn SCIPprofileFindLeft(
        profile: *mut SCIP_PROFILE,
        timepoint: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " insert a core into resource profile; if the core is non-empty the resource profile will be updated otherwise nothing\n  happens"]
    pub fn SCIPprofileInsertCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " subtracts the height from the resource profile during core time"]
    pub fn SCIPprofileDeleteCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the earliest possible starting point within the time interval [lb,ub] for a given core (given by its height\n  and duration)"]
    pub fn SCIPprofileGetEarliestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        est: ::std::os::raw::c_int,
        lst: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return the latest possible starting point within the time interval [lb,ub] for a given core (given by its height and\n  duration)"]
    pub fn SCIPprofileGetLatestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        est: ::std::os::raw::c_int,
        lst: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " resize directed graph structure"]
    pub fn SCIPdigraphResize(
        digraph: *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the sizes of the successor lists for the nodes in a directed graph and allocates memory for the lists"]
    pub fn SCIPdigraphSetSizes(
        digraph: *mut SCIP_DIGRAPH,
        sizes: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees given directed graph structure"]
    pub fn SCIPdigraphFree(digraph: *mut *mut SCIP_DIGRAPH);
}
unsafe extern "C" {
    #[doc = " add (directed) arc and a related data to the directed graph structure\n\n  @note if the arc is already contained, it is added a second time"]
    pub fn SCIPdigraphAddArc(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add (directed) arc to the directed graph structure, if it is not contained, yet\n\n @note if there already exists an arc from startnode to endnode, the new arc is not added,\n       even if its data is different"]
    pub fn SCIPdigraphAddArcSafe(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the number of successors to a given value"]
    pub fn SCIPdigraphSetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
        nsuccessors: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes of the given digraph"]
    pub fn SCIPdigraphGetNNodes(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the node data, or NULL if no data exist"]
    pub fn SCIPdigraphGetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " sets the node data"]
    pub fn SCIPdigraphSetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        dataptr: *mut ::std::os::raw::c_void,
        node: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the total number of arcs in the given digraph"]
    pub fn SCIPdigraphGetNArcs(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of successor nodes of the given node"]
    pub fn SCIPdigraphGetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the array of indices of the successor nodes; this array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the array of data corresponding to the arcs originating at the given node, or NULL if no data exist; this\n  array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessorsData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " identifies the articulation points in a given directed graph\n  uses the helper recursive function findArticulationPointsUtil"]
    pub fn SCIPdigraphGetArticulationPoints(
        digraph: *mut SCIP_DIGRAPH,
        articulations: *mut *mut ::std::os::raw::c_int,
        narticulations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Compute undirected connected components on the given graph.\n\n  @note For each arc, its reverse is added, so the graph does not need to be the directed representation of an\n        undirected graph."]
    pub fn SCIPdigraphComputeUndirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        minsize: ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Computes all strongly connected components of an undirected connected component with Tarjan's Algorithm.\n  The resulting strongly connected components are sorted topologically (starting from the end of the\n  strongcomponents array).\n\n  @note In general a topological sort of the strongly connected components is not unique."]
    pub fn SCIPdigraphComputeDirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        strongcomponents: *mut ::std::os::raw::c_int,
        strongcompstartidx: *mut ::std::os::raw::c_int,
        nstrongcomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Performes an (almost) topological sort on the undirected components of the given directed graph. The undirected\n  components should be computed before using SCIPdigraphComputeUndirectedComponents().\n\n  @note In general a topological sort is not unique.  Note, that there might be directed cycles, that are randomly\n        broken, which is the reason for having only almost topologically sorted arrays."]
    pub fn SCIPdigraphTopoSortComponents(digraph: *mut SCIP_DIGRAPH) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of previously computed undirected components for the given directed graph"]
    pub fn SCIPdigraphGetNComponents(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the previously computed undirected component of the given number for the given directed graph.\n  If the components were sorted using SCIPdigraphTopoSortComponents(), the component is (almost) topologically sorted."]
    pub fn SCIPdigraphGetComponent(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        nodes: *mut *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " frees the component information for the given directed graph"]
    pub fn SCIPdigraphFreeComponents(digraph: *mut SCIP_DIGRAPH);
}
unsafe extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrint(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " prints the given directed graph structure in GML format into the given file"]
    pub fn SCIPdigraphPrintGml(digraph: *mut SCIP_DIGRAPH, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrintComponents(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " creates a binary tree node with sorting value and user data"]
    pub fn SCIPbtnodeCreate(
        tree: *mut SCIP_BT,
        node: *mut *mut SCIP_BTNODE,
        dataptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the binary node including the rooted subtree\n\n  @note The user pointer (object) is not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtnodeFree(tree: *mut SCIP_BT, node: *mut *mut SCIP_BTNODE);
}
unsafe extern "C" {
    #[doc = " returns the user data pointer stored in that node"]
    pub fn SCIPbtnodeGetData(node: *mut SCIP_BTNODE) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns the parent which can be NULL if the given node is the root"]
    pub fn SCIPbtnodeGetParent(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
unsafe extern "C" {
    #[doc = " returns left child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetLeftchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
unsafe extern "C" {
    #[doc = " returns right child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetRightchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
unsafe extern "C" {
    #[doc = " returns the sibling of the node or NULL if does not exist"]
    pub fn SCIPbtnodeGetSibling(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
unsafe extern "C" {
    #[doc = " returns whether the node is a root node"]
    pub fn SCIPbtnodeIsRoot(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the node is a leaf"]
    pub fn SCIPbtnodeIsLeaf(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the given node is left child"]
    pub fn SCIPbtnodeIsLeftchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the given node is right child"]
    pub fn SCIPbtnodeIsRightchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the give node data\n\n  @note The old user pointer is not freed."]
    pub fn SCIPbtnodeSetData(node: *mut SCIP_BTNODE, dataptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " sets parent node\n\n  @note The old parent including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetParent(node: *mut SCIP_BTNODE, parent: *mut SCIP_BTNODE);
}
unsafe extern "C" {
    #[doc = " sets left child\n\n  @note The old left child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetLeftchild(node: *mut SCIP_BTNODE, left: *mut SCIP_BTNODE);
}
unsafe extern "C" {
    #[doc = " sets right child\n\n  @note The old right child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetRightchild(node: *mut SCIP_BTNODE, right: *mut SCIP_BTNODE);
}
unsafe extern "C" {
    #[doc = " creates an binary tree"]
    pub fn SCIPbtCreate(tree: *mut *mut SCIP_BT, blkmem: *mut BMS_BLKMEM) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees binary tree\n\n  @note The user pointers (object) of the search nodes are not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtFree(tree: *mut *mut SCIP_BT);
}
unsafe extern "C" {
    #[doc = " prints the binary tree in GML format into the given file"]
    pub fn SCIPbtPrintGml(tree: *mut SCIP_BT, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " returns whether the binary tree is empty (has no nodes)"]
    pub fn SCIPbtIsEmpty(tree: *mut SCIP_BT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the root node of the binary tree or NULL if the binary tree is empty"]
    pub fn SCIPbtGetRoot(tree: *mut SCIP_BT) -> *mut SCIP_BTNODE;
}
unsafe extern "C" {
    #[doc = " sets root node\n\n  @note The old root including the rooted subtree is not delete."]
    pub fn SCIPbtSetRoot(tree: *mut SCIP_BT, root: *mut SCIP_BTNODE);
}
unsafe extern "C" {
    #[doc = " clears the disjoint set (union find) structure \\p djset"]
    pub fn SCIPdisjointsetClear(djset: *mut SCIP_DISJOINTSET);
}
unsafe extern "C" {
    #[doc = " finds and returns the component identifier of this \\p element"]
    pub fn SCIPdisjointsetFind(
        djset: *mut SCIP_DISJOINTSET,
        element: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " merges the components containing the elements \\p p and \\p q"]
    pub fn SCIPdisjointsetUnion(
        djset: *mut SCIP_DISJOINTSET,
        p: ::std::os::raw::c_int,
        q: ::std::os::raw::c_int,
        forcerepofp: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the number of independent components in this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetComponentCount(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the size (number of nodes) of this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetSize(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the machine epsilon: the smallest number eps > 0, for which 1.0 + eps > 1.0"]
    pub fn SCIPcalcMachineEpsilon() -> f64;
}
unsafe extern "C" {
    #[doc = " returns the next representable value of from in the direction of to"]
    pub fn SCIPnextafter(from: f64, to: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the greatest common divisor of the two given values"]
    pub fn SCIPcalcGreComDiv(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " calculates the smallest common multiple of the two given values"]
    pub fn SCIPcalcSmaComMul(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " calculates a binomial coefficient n over m, choose m elements out of n, maximal value will be 33 over 16 (because\n  the n=33 is the last line in the Pascal's triangle where each entry fits in a 4 byte value), an error occurs due to\n  big numbers or an negative value m (and m < n) and -1 will be returned"]
    pub fn SCIPcalcBinomCoef(
        n: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " calculates hash for floating-point number by using Fibonacci hashing"]
    pub fn SCIPcalcFibHash(v: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " converts a real number into a (approximate) rational representation, and returns TRUE iff the conversion was\n  successful"]
    pub fn SCIPrealToRational(
        val: f64,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        numerator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks, if value is integral without any tolerances"]
    pub fn SCIPrealIsExactlyIntegral(val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " tries to find a value, such that all given values, if scaled with this value become integral in relative allowed\n  difference in between mindelta and maxdelta"]
    pub fn SCIPcalcIntegralScalar(
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to find a value, such that all given values, if scaled with this value become integral"]
    pub fn SCIPcalcIntegralScalarExact(
        buffer: *mut BMS_BUFMEM,
        vals: *mut *mut SCIP_RATIONAL,
        nvals: ::std::os::raw::c_int,
        maxscale: f64,
        intscalar: *mut SCIP_RATIONAL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " given a (usually very small) interval, tries to find a rational number with simple denominator (i.e. a small\n  number, probably multiplied with powers of 10) out of this interval; returns TRUE iff a valid rational\n  number inside the interval was found"]
    pub fn SCIPfindSimpleRational(
        lb: f64,
        ub: f64,
        maxdnom: ::std::os::raw::c_longlong,
        numerator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " given a (usually very small) interval, selects a value inside this interval; it is tried to select a rational number\n  with simple denominator (i.e. a small number, probably multiplied with powers of 10);\n  if no valid rational number inside the interval was found, selects the central value of the interval"]
    pub fn SCIPselectSimpleValue(lb: f64, ub: f64, maxdnom: ::std::os::raw::c_longlong) -> f64;
}
unsafe extern "C" {
    #[doc = " Performs the Newton Procedure from a given starting point to compute a root of the given function with\n  specified precision and maximum number of iterations. If the procedure fails, SCIP_INVALID is returned."]
    pub fn SCIPcalcRootNewton(
        function: ::std::option::Option<
            unsafe extern "C" fn(
                point: f64,
                params: *mut f64,
                nparams: ::std::os::raw::c_int,
            ) -> f64,
        >,
        derivative: ::std::option::Option<
            unsafe extern "C" fn(
                point: f64,
                params: *mut f64,
                nparams: ::std::os::raw::c_int,
            ) -> f64,
        >,
        params: *mut f64,
        nparams: ::std::os::raw::c_int,
        x: f64,
        eps: f64,
        k: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the relative difference: (val1-val2)/max(|val1|,|val2|,1.0)"]
    pub fn SCIPrelDiff(val1: f64, val2: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " computes the gap from the primal and the dual bound"]
    pub fn SCIPcomputeGap(eps: f64, inf: f64, primalbound: f64, dualbound: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns a random integer between minrandval and maxrandval"]
    pub fn SCIPrandomGetInt(
        randnumgen: *mut SCIP_RANDNUMGEN,
        minrandval: ::std::os::raw::c_int,
        maxrandval: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " draws a random subset of disjoint elements from a given set of disjoint elements;\n  this implementation is suited for the case that nsubelems is considerably smaller then nelems"]
    pub fn SCIPrandomGetSubset(
        randnumgen: *mut SCIP_RANDNUMGEN,
        set: *mut *mut ::std::os::raw::c_void,
        nelems: ::std::os::raw::c_int,
        subset: *mut *mut ::std::os::raw::c_void,
        nsubelems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns a random real between minrandval and maxrandval"]
    pub fn SCIPrandomGetReal(
        randnumgen: *mut SCIP_RANDNUMGEN,
        minrandval: f64,
        maxrandval: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " swaps two ints"]
    pub fn SCIPswapInts(value1: *mut ::std::os::raw::c_int, value2: *mut ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " swaps two real values"]
    pub fn SCIPswapReals(value1: *mut f64, value2: *mut f64);
}
unsafe extern "C" {
    #[doc = " swaps the addresses of two pointers"]
    pub fn SCIPswapPointers(
        pointer1: *mut *mut ::std::os::raw::c_void,
        pointer2: *mut *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " randomly shuffles parts of an integer array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteIntArray(
        randnumgen: *mut SCIP_RANDNUMGEN,
        array: *mut ::std::os::raw::c_int,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " randomly shuffles parts of an array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteArray(
        randnumgen: *mut SCIP_RANDNUMGEN,
        array: *mut *mut ::std::os::raw::c_void,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two integer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysIntersectionInt(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        intersectarray: *mut ::std::os::raw::c_int,
        nintersectarray: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two void-pointer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysIntersectionPtr(
        array1: *mut *mut ::std::os::raw::c_void,
        narray1: ::std::os::raw::c_int,
        array2: *mut *mut ::std::os::raw::c_void,
        narray2: ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        intersectarray: *mut *mut ::std::os::raw::c_void,
        nintersectarray: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " computes set difference (duplicates removed) of two integer arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysSetminusInt(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        setminusarray: *mut ::std::os::raw::c_int,
        nsetminusarray: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " copies characters from 'src' to 'dest', copying is stopped when either the 'stop' character is reached or after\n  'cnt' characters have been copied, whichever comes first.\n\n  @note undefined behaviuor on overlapping arrays"]
    pub fn SCIPmemccpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
        cnt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " prints an error message containing of the given string followed by a string describing the current system error;\n  prefers to use the strerror_r method, which is threadsafe; on systems where this method does not exist,\n  NO_STRERROR_R should be defined (see INSTALL), in this case, srerror is used which is not guaranteed to be\n  threadsafe (on SUN-systems, it actually is)"]
    pub fn SCIPprintSysError(message: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " extracts tokens from strings - wrapper method for strtok_r()"]
    pub fn SCIPstrtok(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        ptrptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " translates the given string into a string where symbols \", ', and spaces are escaped with a \\ prefix"]
    pub fn SCIPescapeString(
        t: *mut ::std::os::raw::c_char,
        bufsize: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " increases string pointer as long as it refers to a space character or an explicit space control sequence"]
    pub fn SCIPskipSpace(s: *mut *mut ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " safe version of snprintf"]
    pub fn SCIPsnprintf(
        t: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " safe version of strncpy\n\n  Copies string in s to t using at most @a size-1 nonzero characters (strncpy copies size characters). It always adds\n  a terminating zero char. Does not pad the remaining string with zero characters (unlike strncpy). Returns the number\n  of copied nonzero characters, if the length of s is at most size - 1, and returns size otherwise. Thus, the original\n  string was truncated if the return value is size."]
    pub fn SCIPstrncpy(
        t: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " portable version of strcasecmp for case-insensitive comparison of two strings"]
    pub fn SCIPstrcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " portable version of strncasecmp for case-insensitive comparison of two strings up to a given number of characters"]
    pub fn SCIPstrncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " extract the next token as a integer value if it is one; in case no value is parsed the endptr is set to @p str\n\n  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToIntValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " extract the next token as a double value if it is one; in case a value is parsed the endptr is set to @p str\n\n  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToRealValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " copies the first size characters between a start and end character of str into token, if no error occurred endptr\n  will point to the position after the read part, otherwise it will point to @p str"]
    pub fn SCIPstrCopySection(
        str_: *const ::std::os::raw::c_char,
        startchar: ::std::os::raw::c_char,
        endchar: ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " checks whether a given string t appears at the beginning of the string s (up to spaces at beginning)"]
    pub fn SCIPstrAtStart(
        s: *const ::std::os::raw::c_char,
        t: *const ::std::os::raw::c_char,
        tlen: usize,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the given file exists"]
    pub fn SCIPfileExists(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " splits filename into path, name, and extension"]
    pub fn SCIPsplitFilename(
        filename: *mut ::std::os::raw::c_char,
        path: *mut *mut ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        extension: *mut *mut ::std::os::raw::c_char,
        compression: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " gets name of node selector"]
    pub fn SCIPnodeselGetName(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of node selector"]
    pub fn SCIPnodeselGetDesc(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of node selector in standard mode"]
    pub fn SCIPnodeselGetStdPriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets priority of node selector in memory saving mode"]
    pub fn SCIPnodeselGetMemsavePriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of node selector"]
    pub fn SCIPnodeselGetData(nodesel: *mut SCIP_NODESEL) -> *mut SCIP_NODESELDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of node selector; user has to free old data in advance!"]
    pub fn SCIPnodeselSetData(nodesel: *mut SCIP_NODESEL, nodeseldata: *mut SCIP_NODESELDATA);
}
unsafe extern "C" {
    #[doc = " is node selector initialized?"]
    pub fn SCIPnodeselIsInitialized(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this node selector for setting up for next stages"]
    pub fn SCIPnodeselGetSetupTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this node selector"]
    pub fn SCIPnodeselGetTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
unsafe extern "C" {
    #[doc = " returns type of parameter"]
    pub fn SCIPparamGetType(param: *mut SCIP_PARAM) -> SCIP_PARAMTYPE;
}
unsafe extern "C" {
    #[doc = " returns name of parameter"]
    pub fn SCIPparamGetName(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns description of parameter"]
    pub fn SCIPparamGetDesc(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns locally defined parameter specific data"]
    pub fn SCIPparamGetData(param: *mut SCIP_PARAM) -> *mut SCIP_PARAMDATA;
}
unsafe extern "C" {
    #[doc = " returns whether parameter is advanced"]
    pub fn SCIPparamIsAdvanced(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether parameter is fixed"]
    pub fn SCIPparamIsFixed(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets fixing status of given parameter"]
    pub fn SCIPparamSetFixed(param: *mut SCIP_PARAM, fixed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " returns value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBool(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns default value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBoolDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns value of int parameter"]
    pub fn SCIPparamGetInt(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns minimal value of int parameter"]
    pub fn SCIPparamGetIntMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns maximal value of int parameter"]
    pub fn SCIPparamGetIntMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns default value of int parameter"]
    pub fn SCIPparamGetIntDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongint(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns minimal value of longint parameter"]
    pub fn SCIPparamGetLongintMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns maximal value of longint parameter"]
    pub fn SCIPparamGetLongintMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns default value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongintDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns value of SCIP_Real parameter"]
    pub fn SCIPparamGetReal(param: *mut SCIP_PARAM) -> f64;
}
unsafe extern "C" {
    #[doc = " returns minimal value of real parameter"]
    pub fn SCIPparamGetRealMin(param: *mut SCIP_PARAM) -> f64;
}
unsafe extern "C" {
    #[doc = " returns maximal value of real parameter"]
    pub fn SCIPparamGetRealMax(param: *mut SCIP_PARAM) -> f64;
}
unsafe extern "C" {
    #[doc = " returns default value of SCIP_Real parameter"]
    pub fn SCIPparamGetRealDefault(param: *mut SCIP_PARAM) -> f64;
}
unsafe extern "C" {
    #[doc = " returns value of char parameter"]
    pub fn SCIPparamGetChar(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns allowed values of char parameter, or NULL if everything is allowed"]
    pub fn SCIPparamGetCharAllowedValues(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns default value of char parameter"]
    pub fn SCIPparamGetCharDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns value of string parameter"]
    pub fn SCIPparamGetString(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns default value of String parameter"]
    pub fn SCIPparamGetStringDefault(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether the parameter is on its default setting"]
    pub fn SCIPparamIsDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two presolvers w. r. to their priority"]
    pub fn SCIPpresolComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting presolvers w.r.t. to their name"]
    pub fn SCIPpresolCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of presolver"]
    pub fn SCIPpresolGetData(presol: *mut SCIP_PRESOL) -> *mut SCIP_PRESOLDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of presolver; user has to free old data in advance!"]
    pub fn SCIPpresolSetData(presol: *mut SCIP_PRESOL, presoldata: *mut SCIP_PRESOLDATA);
}
unsafe extern "C" {
    #[doc = " marks the presolver as safe to use in exact solving mode"]
    pub fn SCIPpresolMarkExact(presol: *mut SCIP_PRESOL);
}
unsafe extern "C" {
    #[doc = " gets name of presolver"]
    pub fn SCIPpresolGetName(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of presolver"]
    pub fn SCIPpresolGetDesc(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of presolver"]
    pub fn SCIPpresolGetPriority(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets round limit of presolver"]
    pub fn SCIPpresolGetMaxrounds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the timing mask of the presolver"]
    pub fn SCIPpresolGetTiming(presol: *mut SCIP_PRESOL) -> SCIP_PRESOLTIMING;
}
unsafe extern "C" {
    #[doc = " sets the timing mask of the presolver"]
    pub fn SCIPpresolSetTiming(presol: *mut SCIP_PRESOL, timing: SCIP_PRESOLTIMING);
}
unsafe extern "C" {
    #[doc = " is presolver initialized?"]
    pub fn SCIPpresolIsInitialized(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this presolver for setting up for next stages"]
    pub fn SCIPpresolGetSetupTime(presol: *mut SCIP_PRESOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this presolver"]
    pub fn SCIPpresolGetTime(presol: *mut SCIP_PRESOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of variables fixed in presolver"]
    pub fn SCIPpresolGetNFixedVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variables aggregated in presolver"]
    pub fn SCIPpresolGetNAggrVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variable types changed in presolver"]
    pub fn SCIPpresolGetNChgVarTypes(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of bounds changed in presolver"]
    pub fn SCIPpresolGetNChgBds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolver"]
    pub fn SCIPpresolGetNAddHoles(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints deleted in presolver"]
    pub fn SCIPpresolGetNDelConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints added in presolver"]
    pub fn SCIPpresolGetNAddConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints upgraded in presolver"]
    pub fn SCIPpresolGetNUpgdConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of coefficients changed in presolver"]
    pub fn SCIPpresolGetNChgCoefs(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraint sides changed in presolver"]
    pub fn SCIPpresolGetNChgSides(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of times the presolver was called and tried to find reductions"]
    pub fn SCIPpresolGetNCalls(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two pricers w. r. to their priority"]
    pub fn SCIPpricerComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting pricers w.r.t. to their name"]
    pub fn SCIPpricerCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of variable pricer"]
    pub fn SCIPpricerGetData(pricer: *mut SCIP_PRICER) -> *mut SCIP_PRICERDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of variable pricer; user has to free old data in advance!"]
    pub fn SCIPpricerSetData(pricer: *mut SCIP_PRICER, pricerdata: *mut SCIP_PRICERDATA);
}
unsafe extern "C" {
    #[doc = " marks the variable pricer as safe to use in exact solving mode"]
    pub fn SCIPpricerMarkExact(pricer: *mut SCIP_PRICER);
}
unsafe extern "C" {
    #[doc = " gets name of variable pricer"]
    pub fn SCIPpricerGetName(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of variable pricer"]
    pub fn SCIPpricerGetDesc(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of variable pricer"]
    pub fn SCIPpricerGetPriority(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the pricer was called and tried to find a variable with negative reduced costs"]
    pub fn SCIPpricerGetNCalls(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of variables with negative reduced costs found by this pricer"]
    pub fn SCIPpricerGetNVarsFound(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this pricer for setting up for next stages"]
    pub fn SCIPpricerGetSetupTime(pricer: *mut SCIP_PRICER) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this pricer"]
    pub fn SCIPpricerGetTime(pricer: *mut SCIP_PRICER) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the given pricer is in use in the current problem"]
    pub fn SCIPpricerIsActive(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the pricer should be delayed until no other pricer finds a new variable"]
    pub fn SCIPpricerIsDelayed(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is variable pricer initialized?"]
    pub fn SCIPpricerIsInitialized(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets user data of reader"]
    pub fn SCIPreaderGetData(reader: *mut SCIP_READER) -> *mut SCIP_READERDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of reader; user has to free old data in advance!"]
    pub fn SCIPreaderSetData(reader: *mut SCIP_READER, readerdata: *mut SCIP_READERDATA);
}
unsafe extern "C" {
    #[doc = " marks the reader as safe to use in exact solving mode"]
    pub fn SCIPreaderMarkExact(reader: *mut SCIP_READER);
}
unsafe extern "C" {
    #[doc = " gets name of reader"]
    pub fn SCIPreaderGetName(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of reader"]
    pub fn SCIPreaderGetDesc(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets file extension of reader"]
    pub fn SCIPreaderGetExtension(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " return whether the reader can read files"]
    pub fn SCIPreaderCanRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " return whether the reader can write files"]
    pub fn SCIPreaderCanWrite(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two relaxation handlers w. r. to their priority"]
    pub fn SCIPrelaxComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting relaxators w.r.t. to their name"]
    pub fn SCIPrelaxCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of relaxation handler"]
    pub fn SCIPrelaxGetData(relax: *mut SCIP_RELAX) -> *mut SCIP_RELAXDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of relaxation handler; user has to free old data in advance!"]
    pub fn SCIPrelaxSetData(relax: *mut SCIP_RELAX, relaxdata: *mut SCIP_RELAXDATA);
}
unsafe extern "C" {
    #[doc = " marks the relaxator as safe to use in exact solving mode"]
    pub fn SCIPrelaxMarkExact(relax: *mut SCIP_RELAX);
}
unsafe extern "C" {
    #[doc = " gets name of relaxation handler"]
    pub fn SCIPrelaxGetName(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of relaxation handler"]
    pub fn SCIPrelaxGetDesc(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of relaxation handler"]
    pub fn SCIPrelaxGetPriority(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets frequency of relaxation handler"]
    pub fn SCIPrelaxGetFreq(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this relaxator for setting up for next stages"]
    pub fn SCIPrelaxGetSetupTime(relax: *mut SCIP_RELAX) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this relaxation handler"]
    pub fn SCIPrelaxGetTime(relax: *mut SCIP_RELAX) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler was called"]
    pub fn SCIPrelaxGetNCalls(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler cut off a node"]
    pub fn SCIPrelaxGetNCutoffs(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler improved a node's lower bound"]
    pub fn SCIPrelaxGetNImprovedLowerbound(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the time in seconds spent for the execution of the relaxation handler when a node's lower bound could be improved (or a cutoff was found)"]
    pub fn SCIPrelaxGetImprovedLowerboundTime(relax: *mut SCIP_RELAX) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler added constraints"]
    pub fn SCIPrelaxGetNAddedConss(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler reduced variable domains"]
    pub fn SCIPrelaxGetNReducedDomains(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the relaxation handler separated cutting planes"]
    pub fn SCIPrelaxGetNSeparatedCuts(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " is relaxation handler initialized?"]
    pub fn SCIPrelaxIsInitialized(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the current relaxation unsolved, s.t. the relaxation handler is called again in the next solving round"]
    pub fn SCIPrelaxMarkUnsolved(relax: *mut SCIP_RELAX);
}
unsafe extern "C" {
    #[doc = " returns the number of bound changes stored in the reoptnode"]
    pub fn SCIPreoptnodeGetNVars(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of bound changes at the node stored at ID id"]
    pub fn SCIPreoptnodeGetNConss(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of stored bound changes based on dual information in the reopttree at ID id"]
    pub fn SCIPreoptnodeGetNDualBoundChgs(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of child nodes of @p reoptnode"]
    pub fn SCIPreoptnodeGetNChildren(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPreoptnodeGetLowerbound(reoptnode: *mut SCIP_REOPTNODE) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the type of the @p reoptnode"]
    pub fn SCIPreoptnodeGetType(reoptnode: *mut SCIP_REOPTNODE) -> SCIP_REOPTTYPE;
}
unsafe extern "C" {
    #[doc = " returns all added constraints at ID id"]
    pub fn SCIPreoptnodeGetConss(
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut *mut SCIP_VAR,
        bounds: *mut *mut f64,
        boundtypes: *mut *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nconss: *mut ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " set the parent id"]
    pub fn SCIPreoptnodeSetParentID(
        reoptnode: *mut SCIP_REOPTNODE,
        parentid: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the number of global restarts"]
    pub fn SCIPreoptGetNRestartsGlobal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of local restarts in the current run"]
    pub fn SCIPreoptGetNRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of local restarts over all runs"]
    pub fn SCIPreoptGetNTotalRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of iteration with the first global restarts"]
    pub fn SCIPreoptGetFirstRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of iteration with the last global restarts"]
    pub fn SCIPreoptGetLastRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution in the current run"]
    pub fn SCIPreoptGetNFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution over all runs"]
    pub fn SCIPreoptGetNTotalFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound in the current run"]
    pub fn SCIPreoptGetNPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound over all runs"]
    pub fn SCIPreoptGetNTotalPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off in the current run"]
    pub fn SCIPreoptGetNCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off over all runs"]
    pub fn SCIPreoptGetNTotalCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP in the current run"]
    pub fn SCIPreoptGetNInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP over all runs"]
    pub fn SCIPreoptGetNTotalInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two separators w. r. to their priority"]
    pub fn SCIPsepaComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting separators w.r.t. to their name"]
    pub fn SCIPsepaCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of separator"]
    pub fn SCIPsepaGetData(sepa: *mut SCIP_SEPA) -> *mut SCIP_SEPADATA;
}
unsafe extern "C" {
    #[doc = " sets user data of separator; user has to free old data in advance!"]
    pub fn SCIPsepaSetData(sepa: *mut SCIP_SEPA, sepadata: *mut SCIP_SEPADATA);
}
unsafe extern "C" {
    #[doc = " gets name of separator"]
    pub fn SCIPsepaGetName(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of separator"]
    pub fn SCIPsepaGetDesc(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of separator"]
    pub fn SCIPsepaGetPriority(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets frequency of separator"]
    pub fn SCIPsepaGetFreq(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets frequency of separator"]
    pub fn SCIPsepaSetFreq(sepa: *mut SCIP_SEPA, freq: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " marks the separator as safe to use in exact solving mode"]
    pub fn SCIPsepaMarkExact(sepa: *mut SCIP_SEPA);
}
unsafe extern "C" {
    #[doc = " get maximal bound distance at which the separator is called"]
    pub fn SCIPsepaGetMaxbounddist(sepa: *mut SCIP_SEPA) -> f64;
}
unsafe extern "C" {
    #[doc = " does the separator use a secondary SCIP instance?"]
    pub fn SCIPsepaUsesSubscip(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this separator for setting up for next stages"]
    pub fn SCIPsepaGetSetupTime(sepa: *mut SCIP_SEPA) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this separator"]
    pub fn SCIPsepaGetTime(sepa: *mut SCIP_SEPA) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the separator was called"]
    pub fn SCIPsepaGetNCalls(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times the separator was called at the root"]
    pub fn SCIPsepaGetNRootCalls(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of times, the separator was called at the current node"]
    pub fn SCIPsepaGetNCallsAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets total number of times, the separator detected a cutoff"]
    pub fn SCIPsepaGetNCutoffs(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cutting planes added from the separator to the cut pool\n  and to the sepastore directly"]
    pub fn SCIPsepaGetNCutsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cutting planes added from the separator to the sepastore;\n  equal to the sum of added cuts directly and via the pool."]
    pub fn SCIPsepaGetNCutsAdded(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of cutting planes from the separator added from the cut pool"]
    pub fn SCIPsepaGetNCutsAddedViaPool(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of cutting planes from the separator added directly to the sepastore"]
    pub fn SCIPsepaGetNCutsAddedDirect(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied to the LP"]
    pub fn SCIPsepaGetNCutsApplied(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied to the LP from the cutpool"]
    pub fn SCIPsepaGetNCutsAppliedViaPool(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of cutting planes from the separator applied directly to the LP"]
    pub fn SCIPsepaGetNCutsAppliedDirect(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the number of cutting planes found by this separator at the current node"]
    pub fn SCIPsepaGetNCutsFoundAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of additional constraints added by this separator"]
    pub fn SCIPsepaGetNConssFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of domain reductions found by this separator"]
    pub fn SCIPsepaGetNDomredsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " should separator be delayed, if other separators found cuts?"]
    pub fn SCIPsepaIsDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was separation of the LP solution delayed at the last call?"]
    pub fn SCIPsepaWasLPDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was separation of the primal solution delayed at the last call?"]
    pub fn SCIPsepaWasSolDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is separator initialized?"]
    pub fn SCIPsepaIsInitialized(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets whether separator is a parent separator"]
    pub fn SCIPsepaIsParentsepa(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets parent separator (or NULL)"]
    pub fn SCIPsepaGetParentsepa(sepa: *mut SCIP_SEPA) -> *mut SCIP_SEPA;
}
unsafe extern "C" {
    #[doc = " gets name of cut selector"]
    pub fn SCIPcutselGetName(cutsel: *mut SCIP_CUTSEL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets user data of cut selector"]
    pub fn SCIPcutselGetData(cutsel: *mut SCIP_CUTSEL) -> *mut SCIP_CUTSELDATA;
}
unsafe extern "C" {
    #[doc = " gets description of cut selector"]
    pub fn SCIPcutselGetDesc(cutsel: *mut SCIP_CUTSEL) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of cut selector"]
    pub fn SCIPcutselGetPriority(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets user data of cut selector; user has to free old data in advance!"]
    pub fn SCIPcutselSetData(cutsel: *mut SCIP_CUTSEL, cutseldata: *mut SCIP_CUTSELDATA);
}
unsafe extern "C" {
    #[doc = " is cut selector initialized?"]
    pub fn SCIPcutselIsInitialized(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this cut selector for setting up for next stages"]
    pub fn SCIPcutselGetSetupTime(cutsel: *mut SCIP_CUTSEL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this cut selector"]
    pub fn SCIPcutselGetTime(cutsel: *mut SCIP_CUTSEL) -> f64;
}
unsafe extern "C" {
    #[doc = " get number of times the cutselector was called"]
    pub fn SCIPcutselGetNCalls(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get number of times the cutselector was called at the root"]
    pub fn SCIPcutselGetNRootCalls(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of cuts that were selected at the root"]
    pub fn SCIPcutselGetNRootCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of forced cuts that were selected at the root"]
    pub fn SCIPcutselGetNRootForcedCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of root cuts that were filtered"]
    pub fn SCIPcutselGetNRootCutsFiltered(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of local cuts that were selected"]
    pub fn SCIPcutselGetNLocalCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of forced local cuts that were selected"]
    pub fn SCIPcutselGetNLocalForcedCuts(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of local cuts that were filtered"]
    pub fn SCIPcutselGetNLocalCutsFiltered(cutsel: *mut SCIP_CUTSEL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " compares two cut selectors w. r. to their priority"]
    pub fn SCIPcutselComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two propagators w. r. to their priority"]
    pub fn SCIPpropComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares two propagators w. r. to their presolving priority"]
    pub fn SCIPpropCompPresol(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting propagators w.r.t. to their name"]
    pub fn SCIPpropCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of propagator"]
    pub fn SCIPpropGetData(prop: *mut SCIP_PROP) -> *mut SCIP_PROPDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of propagator; user has to free old data in advance!"]
    pub fn SCIPpropSetData(prop: *mut SCIP_PROP, propdata: *mut SCIP_PROPDATA);
}
unsafe extern "C" {
    #[doc = " marks the propagator as safe to use in exact solving mode"]
    pub fn SCIPpropMarkExact(prop: *mut SCIP_PROP);
}
unsafe extern "C" {
    #[doc = " gets name of propagator"]
    pub fn SCIPpropGetName(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of propagator"]
    pub fn SCIPpropGetDesc(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets priority of propagator"]
    pub fn SCIPpropGetPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets presolving priority of propagator"]
    pub fn SCIPpropGetPresolPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets frequency of propagator"]
    pub fn SCIPpropGetFreq(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used for setting up this propagator for new stages"]
    pub fn SCIPpropGetSetupTime(prop: *mut SCIP_PROP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets frequency of propagator"]
    pub fn SCIPpropSetFreq(prop: *mut SCIP_PROP, freq: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this propagator"]
    pub fn SCIPpropGetTime(prop: *mut SCIP_PROP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this propagator during strong branching"]
    pub fn SCIPpropGetStrongBranchPropTime(prop: *mut SCIP_PROP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this propagator for resolve propagation"]
    pub fn SCIPpropGetRespropTime(prop: *mut SCIP_PROP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets time in seconds used in this propagator for presolving"]
    pub fn SCIPpropGetPresolTime(prop: *mut SCIP_PROP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the propagator was called"]
    pub fn SCIPpropGetNCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the total number of times, the propagator was called for resolving a propagation"]
    pub fn SCIPpropGetNRespropCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of times, this propagator detected a cutoff"]
    pub fn SCIPpropGetNCutoffs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of domain reductions found by this propagator"]
    pub fn SCIPpropGetNDomredsFound(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " should propagator be delayed, if other propagators found reductions?"]
    pub fn SCIPpropIsDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " was propagator delayed at the last call?"]
    pub fn SCIPpropWasDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is propagator initialized?"]
    pub fn SCIPpropIsInitialized(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets number of variables fixed during presolving of propagator"]
    pub fn SCIPpropGetNFixedVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variables aggregated during presolving of propagator"]
    pub fn SCIPpropGetNAggrVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of variable types changed during presolving of propagator"]
    pub fn SCIPpropGetNChgVarTypes(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of bounds changed during presolving of propagator"]
    pub fn SCIPpropGetNChgBds(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of holes added to domains of variables during presolving of propagator"]
    pub fn SCIPpropGetNAddHoles(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints deleted during presolving of propagator"]
    pub fn SCIPpropGetNDelConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints added during presolving of propagator"]
    pub fn SCIPpropGetNAddConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraints upgraded during presolving of propagator"]
    pub fn SCIPpropGetNUpgdConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of coefficients changed during presolving of propagator"]
    pub fn SCIPpropGetNChgCoefs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of constraint sides changed during presolving of propagator"]
    pub fn SCIPpropGetNChgSides(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of times the propagator was called in presolving and tried to find reductions"]
    pub fn SCIPpropGetNPresolCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the timing mask of the propagator"]
    pub fn SCIPpropGetTimingmask(prop: *mut SCIP_PROP) -> SCIP_PROPTIMING;
}
unsafe extern "C" {
    #[doc = " sets new timing mask for propagator"]
    pub fn SCIPpropSetTimingmask(prop: *mut SCIP_PROP, timingmask: SCIP_PROPTIMING);
}
unsafe extern "C" {
    #[doc = " does the propagator perform presolving?"]
    pub fn SCIPpropDoesPresolve(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropGetPresolTiming(prop: *mut SCIP_PROP) -> SCIP_PRESOLTIMING;
}
unsafe extern "C" {
    #[doc = " sets the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropSetPresolTiming(prop: *mut SCIP_PROP, presoltiming: SCIP_PRESOLTIMING);
}
unsafe extern "C" {
    #[doc = " gets origin of solution"]
    pub fn SCIPsolGetOrigin(sol: *mut SCIP_SOL) -> SCIP_SOLORIGIN;
}
unsafe extern "C" {
    #[doc = " returns whether the given solution is defined on original variables"]
    pub fn SCIPsolIsOriginal(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether a solution is an exact rational solution"]
    pub fn SCIPsolIsExact(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the given solution is partial"]
    pub fn SCIPsolIsPartial(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets objective value of primal CIP solution which lives in the original problem space"]
    pub fn SCIPsolGetOrigObj(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " adds value to the objective value of a given original primal CIP solution"]
    pub fn SCIPsolOrigAddObjvalExact(sol: *mut SCIP_SOL, addval: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets clock time, when this solution was found"]
    pub fn SCIPsolGetTime(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found"]
    pub fn SCIPsolGetRunnum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found"]
    pub fn SCIPsolGetNodenum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets node's depth, where this solution was found"]
    pub fn SCIPsolGetDepth(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets information if solution was found by the LP, a primal heuristic, or a custom relaxator"]
    pub fn SCIPsolGetType(sol: *mut SCIP_SOL) -> SCIP_SOLTYPE;
}
unsafe extern "C" {
    #[doc = " gets heuristic that found this solution, or NULL if solution has type different than SCIP_SOLTYPE_HEUR"]
    pub fn SCIPsolGetHeur(sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " gets relaxation handler that found this solution, or NULL if solution has different type than SCIP_SOLTYPE_RELAX"]
    pub fn SCIPsolGetRelax(sol: *mut SCIP_SOL) -> *mut SCIP_RELAX;
}
unsafe extern "C" {
    #[doc = " informs the solution that it now belongs to the given primal heuristic. For convenience and backwards compatibility,\n  the method accepts NULL as input for \\p heur, in which case the solution type is set to SCIP_SOLTYPE_LPRELAX.\n\n  @note Relaxation handlers should use SCIPsolSetRelax() instead."]
    pub fn SCIPsolSetHeur(sol: *mut SCIP_SOL, heur: *mut SCIP_HEUR);
}
unsafe extern "C" {
    #[doc = " informs the solution that it now belongs to the given relaxation handler"]
    pub fn SCIPsolSetRelax(sol: *mut SCIP_SOL, relax: *mut SCIP_RELAX);
}
unsafe extern "C" {
    #[doc = " informs the solution that it is an LP relaxation solution"]
    pub fn SCIPsolSetLPRelaxation(sol: *mut SCIP_SOL);
}
unsafe extern "C" {
    #[doc = " informs the solution that it is a solution found during strong branching"]
    pub fn SCIPsolSetStrongbranching(sol: *mut SCIP_SOL);
}
unsafe extern "C" {
    #[doc = " informs the solution that it originates from a pseudo solution"]
    pub fn SCIPsolSetPseudo(sol: *mut SCIP_SOL);
}
unsafe extern "C" {
    #[doc = " returns unique index of given solution"]
    pub fn SCIPsolGetIndex(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get maximum absolute bound violation of solution"]
    pub fn SCIPsolGetAbsBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum relative bound violation of solution"]
    pub fn SCIPsolGetRelBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum absolute integrality violation of solution"]
    pub fn SCIPsolGetAbsIntegralityViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum absolute LP row violation of solution"]
    pub fn SCIPsolGetAbsLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum relative LP row violation of solution"]
    pub fn SCIPsolGetRelLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum absolute constraint violation of solution"]
    pub fn SCIPsolGetAbsConsViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " get maximum relative constraint violation of solution"]
    pub fn SCIPsolGetRelConsViolation(sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting solution by decreasing objective value (best solution will be sorted to the end)"]
    pub fn SCIPsolComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets user data of statistics table"]
    pub fn SCIPtableGetData(table: *mut SCIP_TABLE) -> *mut SCIP_TABLEDATA;
}
unsafe extern "C" {
    #[doc = " sets user data of statistics table; user has to free old data in advance!"]
    pub fn SCIPtableSetData(table: *mut SCIP_TABLE, tabledata: *mut SCIP_TABLEDATA);
}
unsafe extern "C" {
    #[doc = " gets name of statistics table"]
    pub fn SCIPtableGetName(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of statistics table"]
    pub fn SCIPtableGetDesc(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets position of statistics table"]
    pub fn SCIPtableGetPosition(table: *mut SCIP_TABLE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets earliest stage of statistics table"]
    pub fn SCIPtableGetEarliestStage(table: *mut SCIP_TABLE) -> SCIP_STAGE;
}
unsafe extern "C" {
    #[doc = " is statistics table currently active?"]
    pub fn SCIPtableIsActive(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is statistics table initialized?"]
    pub fn SCIPtableIsInitialized(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " node comparator for best lower bound"]
    pub fn SCIPnodeCompLowerbound(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the set of variable branchings that were performed in the parent node to create this node"]
    pub fn SCIPnodeGetParentBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node"]
    pub fn SCIPnodeGetAncestorBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the set of variable branchings that were performed between the given @p node and the given @p parent node."]
    pub fn SCIPnodeGetAncestorBranchingsPart(
        node: *mut SCIP_NODE,
        parent: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " outputs the path into given file stream in GML format"]
    pub fn SCIPnodePrintAncestorBranchings(node: *mut SCIP_NODE, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node\n  sorted by the nodes, starting from the current node going up to the root"]
    pub fn SCIPnodeGetAncestorBranchingPath(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
        nodeswitches: *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
        nodeswitchsize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " checks for two nodes whether they share the same root path, i.e., whether one is an ancestor of the other"]
    pub fn SCIPnodesSharePath(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " finds the common ancestor node of two given nodes"]
    pub fn SCIPnodesGetCommonAncestor(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the type of the node"]
    pub fn SCIPnodeGetType(node: *mut SCIP_NODE) -> SCIP_NODETYPE;
}
unsafe extern "C" {
    #[doc = " gets successively assigned number of the node"]
    pub fn SCIPnodeGetNumber(node: *mut SCIP_NODE) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the depth of the node"]
    pub fn SCIPnodeGetDepth(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the lower bound of the node"]
    pub fn SCIPnodeGetLowerbound(node: *mut SCIP_NODE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the rational lower bound of the node"]
    pub fn SCIPnodeGetLowerboundExact(node: *mut SCIP_NODE) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the estimated value of the best feasible solution in subtree of the node"]
    pub fn SCIPnodeGetEstimate(node: *mut SCIP_NODE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the reoptimization type of a node"]
    pub fn SCIPnodeGetReopttype(node: *mut SCIP_NODE) -> SCIP_REOPTTYPE;
}
unsafe extern "C" {
    #[doc = " gets the unique id to identify the node during reoptimization; id is 0 if the node is the root or not part of the\n reoptimization tree"]
    pub fn SCIPnodeGetReoptID(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets the reoptimization type of the node"]
    pub fn SCIPnodeSetReopttype(node: *mut SCIP_NODE, reopttype: SCIP_REOPTTYPE);
}
unsafe extern "C" {
    #[doc = " sets a unique id to identify the node during reoptimization"]
    pub fn SCIPnodeSetReoptID(node: *mut SCIP_NODE, id: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " counts the number of bound changes due to branching, constraint propagation, and propagation"]
    pub fn SCIPnodeGetNDomchg(
        node: *mut SCIP_NODE,
        nbranchings: *mut ::std::os::raw::c_int,
        nconsprop: *mut ::std::os::raw::c_int,
        nprop: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " gets the domain change information of the node, i.e., the information about the differences in the\n  variables domains to the parent node"]
    pub fn SCIPnodeGetDomchg(node: *mut SCIP_NODE) -> *mut SCIP_DOMCHG;
}
unsafe extern "C" {
    #[doc = " gets the parent node of a node in the branch-and-bound tree, if any"]
    pub fn SCIPnodeGetParent(node: *mut SCIP_NODE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " returns all constraints added to a given node"]
    pub fn SCIPnodeGetAddedConss(
        node: *mut SCIP_NODE,
        addedconss: *mut *mut SCIP_CONS,
        naddedconss: *mut ::std::os::raw::c_int,
        addedconsssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the number of added constraints to the given node"]
    pub fn SCIPnodeGetNAddedConss(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether node is in the path to the current node"]
    pub fn SCIPnodeIsActive(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the node is marked to be propagated again"]
    pub fn SCIPnodeIsPropagatedAgain(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn SCIPnodeGetConssetchg(node: *mut SCIP_NODE) -> *mut SCIP_CONSSETCHG;
}
unsafe extern "C" {
    #[doc = " gets number of locks for rounding down\n\n  @note This method will always return variable locks of type model\n\n  @note It is recommented to use SCIPvarGetNLocksDownType()"]
    pub fn SCIPvarGetNLocksDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of locks for rounding up\n\n  @note This method will always return variable locks of type model\n\n  @note It is recommented to use SCIPvarGetNLocksUpType()"]
    pub fn SCIPvarGetNLocksUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of locks for rounding up of a special type"]
    pub fn SCIPvarGetNLocksUpType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of locks for rounding down of a special type"]
    pub fn SCIPvarGetNLocksDownType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " is it possible, to round variable down and stay feasible?\n\n  @note This method will always check w.r.t variable locks of type model"]
    pub fn SCIPvarMayRoundDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " is it possible, to round variable up and stay feasible?\n\n  @note This method will always check w.r.t. variable locks of type model"]
    pub fn SCIPvarMayRoundUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares the index of two variables, only active or negated variables are allowed, if a variable\n  is negated then the index of the corresponding active variable is taken, returns -1 if first is\n  smaller than, and +1 if first is greater than second variable index; returns 0 if both indices\n  are equal, which means both variables are equal"]
    pub fn SCIPvarCompareActiveAndNegated(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting active and negated variables by non-decreasing index, active and negated\n  variables are handled as the same variables"]
    pub fn SCIPvarCompActiveAndNegated(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compares the index of two variables, returns -1 if first is smaller than, and +1 if first is greater than second\n  variable index; returns 0 if both indices are equal, which means both variables are equal"]
    pub fn SCIPvarCompare(var1: *mut SCIP_VAR, var2: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting variables by non-decreasing index"]
    pub fn SCIPvarComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " comparison method for sorting variables by non-decreasing objective coefficient"]
    pub fn SCIPvarCompObj(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " hash key retrieval function for variables"]
    pub fn SCIPvarGetHashkey(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff the indices of both variables are equal"]
    pub fn SCIPvarIsHashkeyEq(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the hash value of the key"]
    pub fn SCIPvarGetHashkeyVal(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of given variables,\n  @note the content of the given array will/might change"]
    pub fn SCIPvarsGetProbvar(vars: *mut *mut SCIP_VAR, nvars: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a variable"]
    pub fn SCIPvarGetProbvar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of binary variables and\n  updates the given negation status of each variable"]
    pub fn SCIPvarsGetProbvarBinary(
        vars: *mut *mut *mut SCIP_VAR,
        negatedarr: *mut *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a binary variable and\n  updates the given negation status"]
    pub fn SCIPvarGetProbvarBinary(
        var: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms given variable, boundtype and bound to the corresponding active, fixed, or multi-aggregated variable\n  values"]
    pub fn SCIPvarGetProbvarBound(
        var: *mut *mut SCIP_VAR,
        bound: *mut f64,
        boundtype: *mut SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms given variable, boundtype and exact bound to the corresponding active, fixed, or multi-aggregated variable\n  values"]
    pub fn SCIPvarGetProbvarBoundExact(
        var: *mut *mut SCIP_VAR,
        bound: *mut SCIP_RATIONAL,
        boundtype: *mut SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms given variable and domain hole to the corresponding active, fixed, or multi-aggregated variable\n  values"]
    pub fn SCIPvarGetProbvarHole(
        var: *mut *mut SCIP_VAR,
        left: *mut f64,
        right: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retransforms given variable, scalar and constant to the corresponding original variable, scalar\n  and constant, if possible; if the retransformation is impossible, NULL is returned as variable"]
    pub fn SCIPvarGetOrigvarSum(
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retransforms given variable, scalar and constant to the corresponding original variable, scalar\n  and constant, if possible; if the retransformation is impossible, NULL is returned as variable"]
    pub fn SCIPvarGetOrigvarSumExact(
        var: *mut *mut SCIP_VAR,
        scalar: *mut SCIP_RATIONAL,
        constant: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the given variable is the direct counterpart of an original problem variable"]
    pub fn SCIPvarIsTransformedOrigvar(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching"]
    pub fn SCIPvarGetNBranchings(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching\n  in the current run"]
    pub fn SCIPvarGetNBranchingsCurrentRun(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered"]
    pub fn SCIPvarGetInferenceSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered\n  in the current run"]
    pub fn SCIPvarGetInferenceSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced"]
    pub fn SCIPvarGetCutoffSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced in the current run"]
    pub fn SCIPvarGetCutoffSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable"]
    pub fn SCIPvarGetAvgBranchdepth(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable\n  in the current run"]
    pub fn SCIPvarGetAvgBranchdepthCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y <= b or y >= b in the implication graph;\n  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());\n  both variables must be active, variable x must be binary"]
    pub fn SCIPvarHasImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y == implvarfixing in the implication graph;\n  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());\n  both variables must be active binary variables"]
    pub fn SCIPvarHasBinaryImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        implvarfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the values of b in implications x == varfixing -> y <= b or y >= b in the implication graph;\n  the values are set to SCIP_INVALID if there is no implied bound"]
    pub fn SCIPvarGetImplicVarBounds(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        lb: *mut f64,
        ub: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;\n  the variables must be active binary variables;\n  if regardimplics is FALSE, only the cliques in the clique table are looked at;\n  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded"]
    pub fn SCIPvarsHaveCommonClique(
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets corresponding objective value of active, fixed, or multi-aggregated problem variable of given variable\n  e.g. obj(x) = 1 this method returns for ~x the value -1"]
    pub fn SCIPvarGetAggregatedObj(var: *mut SCIP_VAR, aggrobj: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the initial flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetInitial(var: *mut SCIP_VAR, initial: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the removable flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetRemovable(
        var: *mut SCIP_VAR,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the name of the variable\n\n  @note to change the name of a variable, use SCIPchgVarName() from scip.h"]
    pub fn SCIPvarGetName(var: *mut SCIP_VAR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets number of times, the variable is currently captured"]
    pub fn SCIPvarGetNUses(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the user data of the variable"]
    pub fn SCIPvarGetData(var: *mut SCIP_VAR) -> *mut SCIP_VARDATA;
}
unsafe extern "C" {
    #[doc = " sets the user data for the variable"]
    pub fn SCIPvarSetData(var: *mut SCIP_VAR, vardata: *mut SCIP_VARDATA);
}
unsafe extern "C" {
    #[doc = " sets method to free user data for the original variable"]
    pub fn SCIPvarSetDelorigData(
        var: *mut SCIP_VAR,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets method to transform user data of the variable"]
    pub fn SCIPvarSetTransData(
        var: *mut SCIP_VAR,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets method to free transformed user data for the variable"]
    pub fn SCIPvarSetDeltransData(
        var: *mut SCIP_VAR,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets method to copy this variable into sub-SCIPs"]
    pub fn SCIPvarSetCopyData(
        var: *mut SCIP_VAR,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " gets status of variable"]
    pub fn SCIPvarGetStatus(var: *mut SCIP_VAR) -> SCIP_VARSTATUS;
}
unsafe extern "C" {
    #[doc = " returns the status of the exact variable data"]
    pub fn SCIPvarGetStatusExact(var: *mut SCIP_VAR) -> SCIP_VARSTATUS;
}
unsafe extern "C" {
    #[doc = " returns whether the variable has exact variable data"]
    pub fn SCIPvarIsExact(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the variable belongs to the original problem"]
    pub fn SCIPvarIsOriginal(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the variable belongs to the transformed problem"]
    pub fn SCIPvarIsTransformed(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the variable was created by negation of a different variable"]
    pub fn SCIPvarIsNegated(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets type of variable"]
    pub fn SCIPvarGetType(var: *mut SCIP_VAR) -> SCIP_VARTYPE;
}
unsafe extern "C" {
    #[doc = " gets the implied integral type of the variable"]
    pub fn SCIPvarGetImplType(var: *mut SCIP_VAR) -> SCIP_IMPLINTTYPE;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the variable is of binary type; this is the case if:\n  (1) variable type is binary\n  (2) variable type is integer or implicit integer and\n      (i)  the global lower bound is greater than or equal to zero\n      (ii) the global upper bound is less than or equal to one"]
    pub fn SCIPvarIsBinary(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable is of integral type (binary, integer, or implied integral of any type)"]
    pub fn SCIPvarIsIntegral(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable is implied integral (weakly or strongly)"]
    pub fn SCIPvarIsImpliedIntegral(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the variable is integral, but not implied integral."]
    pub fn SCIPvarIsNonimpliedIntegral(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable's column should be present in the initial root LP"]
    pub fn SCIPvarIsInitial(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable's column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPvarIsRemovable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the variable was deleted from the problem"]
    pub fn SCIPvarIsDeleted(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the variable to be deletable, i.e., it may be deleted completely from the problem;\n  method can only be called before the variable is added to the problem by SCIPaddVar() or SCIPaddPricedVar()"]
    pub fn SCIPvarMarkDeletable(var: *mut SCIP_VAR);
}
unsafe extern "C" {
    #[doc = " marks the variable to be not deletable from the problem"]
    pub fn SCIPvarMarkNotDeletable(var: *mut SCIP_VAR);
}
unsafe extern "C" {
    #[doc = " returns whether variable is allowed to be deleted completely from the problem"]
    pub fn SCIPvarIsDeletable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks variable to be deleted from global structures (cliques etc.) when cleaning up\n\n  @note: this is not equivalent to marking the variable itself for deletion, this is done by using SCIPvarMarkDeletable()"]
    pub fn SCIPvarMarkDeleteGlobalStructures(var: *mut SCIP_VAR);
}
unsafe extern "C" {
    #[doc = " returns whether variable is an active (neither fixed nor aggregated) variable"]
    pub fn SCIPvarIsActive(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets unique index of variable"]
    pub fn SCIPvarGetIndex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets position of variable in problem, or -1 if variable is not active"]
    pub fn SCIPvarGetProbindex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns position of variable in certificate"]
    pub fn SCIPvarGetCertificateIndex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets index of variable in certificate"]
    pub fn SCIPvarSetCertificateIndex(var: *mut SCIP_VAR, certidx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " sets index of variable in certificate"]
    pub fn SCIPvarSetUbCertificateIndexGlobal(
        var: *mut SCIP_VAR,
        certidx: ::std::os::raw::c_longlong,
    );
}
unsafe extern "C" {
    #[doc = " sets index of variable in certificate"]
    pub fn SCIPvarSetLbCertificateIndexGlobal(
        var: *mut SCIP_VAR,
        certidx: ::std::os::raw::c_longlong,
    );
}
unsafe extern "C" {
    #[doc = " returns index of variable bound in vipr certificate"]
    pub fn SCIPvarGetLbCertificateIndexLocal(var: *mut SCIP_VAR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns index of variable bound in vipr certificate"]
    pub fn SCIPvarGetUbCertificateIndexLocal(var: *mut SCIP_VAR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns index of variable bound in vipr certificate"]
    pub fn SCIPvarGetLbCertificateIndexGlobal(var: *mut SCIP_VAR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns index of variable bound in vipr certificate"]
    pub fn SCIPvarGetUbCertificateIndexGlobal(var: *mut SCIP_VAR) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets transformed variable of ORIGINAL variable"]
    pub fn SCIPvarGetTransVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets column of COLUMN variable"]
    pub fn SCIPvarGetCol(var: *mut SCIP_VAR) -> *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets column of COLUMN variable"]
    pub fn SCIPvarGetColExact(var: *mut SCIP_VAR) -> *mut SCIP_COLEXACT;
}
unsafe extern "C" {
    #[doc = " returns whether the variable is a COLUMN variable that is member of the current LP"]
    pub fn SCIPvarIsInLP(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets lower bound on absolute coefficient of a loose variable in (multi)aggregations of other variables"]
    pub fn SCIPvarGetMinAggrCoef(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets upper bound on absolute coefficient of a loose variable in (multi)aggregations of other variables"]
    pub fn SCIPvarGetMaxAggrCoef(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets aggregation variable y of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets aggregation scalar a of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrScalar(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets aggregation scalar a of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrScalarExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets aggregation constant c of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrConstant(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets aggregation constant c of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrConstantExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets number n of aggregation variables of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrNVars(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets vector of aggregation variables y of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets vector of aggregation scalars a of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrScalars(var: *mut SCIP_VAR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets vector of exact aggregation scalars a of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrScalarsExact(var: *mut SCIP_VAR) -> *mut *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets aggregation constant c of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrConstant(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets exact aggregation constant c of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrConstantExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the negation of the given variable; may return NULL, if no negation is existing yet"]
    pub fn SCIPvarGetNegatedVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the negation variable x of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the negation offset of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationConstant(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets objective function value of variable"]
    pub fn SCIPvarGetObj(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets objective function value of variable"]
    pub fn SCIPvarGetObjExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets exact objective function value of variable"]
    pub fn SCIPvarGetObjInterval(var: *mut SCIP_VAR) -> SCIP_INTERVAL;
}
unsafe extern "C" {
    #[doc = " gets the unchanged objective function value of variable (ignoring temproray changes performed in probing mode)"]
    pub fn SCIPvarGetUnchangedObj(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets original lower bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetLbOriginal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets original lower bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetLbOriginalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets original upper bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetUbOriginal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets original upper bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetUbOriginalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the original hole list of an original variable"]
    pub fn SCIPvarGetHolelistOriginal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
unsafe extern "C" {
    #[doc = " gets global lower bound of variable"]
    pub fn SCIPvarGetLbGlobal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global lower bound of variable"]
    pub fn SCIPvarGetLbGlobalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets global upper bound of variable"]
    pub fn SCIPvarGetUbGlobal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global upper bound of variable"]
    pub fn SCIPvarGetUbGlobalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the global hole list of an active variable"]
    pub fn SCIPvarGetHolelistGlobal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
unsafe extern "C" {
    #[doc = " gets best global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets best global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundGlobalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets worst global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets worst global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundGlobalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets current lower bound of variable"]
    pub fn SCIPvarGetLbLocal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets current lower bound of variable"]
    pub fn SCIPvarGetLbLocalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets current upper bound of variable"]
    pub fn SCIPvarGetUbLocal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets current upper bound of variable"]
    pub fn SCIPvarGetUbLocalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the current hole list of an active variable"]
    pub fn SCIPvarGetHolelistLocal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
unsafe extern "C" {
    #[doc = " gets best local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundLocal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets best local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundLocalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets worst local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundLocal(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets worst local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundLocalExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets type (lower or upper) of best bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets type (lower or upper) of best bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundTypeExact(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets type (lower or upper) of worst bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets type (lower or upper) of worst bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundTypeExact(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets lazy lower bound of variable"]
    pub fn SCIPvarGetLbLazy(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lazy upper bound of variable"]
    pub fn SCIPvarGetUbLazy(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the branch factor of the variable; this value can be used in the branching methods to scale the score\n  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching"]
    pub fn SCIPvarGetBranchFactor(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the branch priority of the variable; variables with higher priority should always be preferred to variables\n  with lower priority"]
    pub fn SCIPvarGetBranchPriority(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the preferred branch direction of the variable (downwards, upwards, or auto)"]
    pub fn SCIPvarGetBranchDirection(var: *mut SCIP_VAR) -> SCIP_BRANCHDIR;
}
unsafe extern "C" {
    #[doc = " gets number of variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVlbs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with bounding variables z_i in variable lower bounds x >= b_i*z_i + d_i of given variable x;\n  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVlbVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets array with bounding constants d_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbConstants(var: *mut SCIP_VAR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets number of variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVubs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with bounding variables z_i in variable upper bounds x <= b_i*z_i + d_i of given variable x;\n  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVubVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets array with bounding constants d_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubConstants(var: *mut SCIP_VAR) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets number of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,\n  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetNImpls(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with implication variables y of implications  y <= b or y >= b for x == 0 or x == 1 of given active\n  problem variable x, there are no implications for nonbinary variable x;\n  the implications are sorted such that implications with binary implied variables precede the ones with non-binary\n  implied variables, and as a second criteria, the implied variables are sorted by increasing variable index\n  (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetImplVars(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array with implication types of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem\n  variable x (SCIP_BOUNDTYPE_UPPER if y <= b, SCIP_BOUNDTYPE_LOWER if y >= b),\n  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplTypes(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets array with implication bounds b of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem\n  variable x, there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplBounds(var: *mut SCIP_VAR, varfixing: ::std::os::raw::c_uint) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Gets array with unique ids of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,\n  there are no implications for nonbinary variable x.\n  If an implication is a shortcut, i.e., it was added as part of the transitive closure of another implication,\n  its id is negative, otherwise it is nonnegative."]
    pub fn SCIPvarGetImplIds(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of cliques, the active variable is contained in"]
    pub fn SCIPvarGetNCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of cliques, the active variable is contained in"]
    pub fn SCIPvarGetCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_CLIQUE;
}
unsafe extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSolExact(var: *mut SCIP_VAR, res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " return lower bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoLb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
unsafe extern "C" {
    #[doc = " gets the number of lower bound change info array"]
    pub fn SCIPvarGetNBdchgInfosLb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return upper bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoUb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
unsafe extern "C" {
    #[doc = " gets the number upper bound change info array"]
    pub fn SCIPvarGetNBdchgInfosUb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the value based history for the variable"]
    pub fn SCIPvarGetValuehistory(var: *mut SCIP_VAR) -> *mut SCIP_VALUEHISTORY;
}
unsafe extern "C" {
    #[doc = " returns whether a variable has been introduced to define a relaxation\n\n These variables are only valid for the current SCIP solve round,\n they are not contained in any (checked) constraints, but may be used\n in cutting planes, for example.\n Relaxation-only variables are not copied by SCIPcopyVars and cuts\n that contain these variables are not added as linear constraints when\n restarting or transferring information from a copied SCIP to a SCIP.\n Also conflicts with relaxation-only variables are not generated at\n the moment.\n Relaxation-only variables do not appear in the objective."]
    pub fn SCIPvarIsRelaxationOnly(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks that this variable has only been introduced to define a relaxation\n\n The variable must not have a coefficient in the objective and must be deletable.\n If it is not marked deletable, it will be marked as deletable, which is only possible\n before the variable is added to a problem.\n\n @see SCIPvarIsRelaxationOnly\n @see SCIPvarMarkDeletable"]
    pub fn SCIPvarMarkRelaxationOnly(var: *mut SCIP_VAR);
}
unsafe extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSolExact_rec(var: *mut SCIP_VAR, res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets pseudo solution value of variable at current node"]
    pub fn SCIPvarGetPseudoSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets pseudo solution value of variable"]
    pub fn SCIPvarGetPseudoSolExact(var: *mut SCIP_VAR) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets current LP or pseudo solution value of variable"]
    pub fn SCIPvarGetSol(var: *mut SCIP_VAR, getlpval: ::std::os::raw::c_uint) -> f64;
}
unsafe extern "C" {
    #[doc = " gets current LP or pseudo solution value of variable"]
    pub fn SCIPvarGetSolExact(
        var: *mut SCIP_VAR,
        res: *mut SCIP_RATIONAL,
        getlpval: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the solution of the variable in the last root node's relaxation, if the root relaxation is not yet\n  completely solved, zero is returned"]
    pub fn SCIPvarGetRootSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the best solution (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation, if\n  the root relaxation is not yet completely solved, zero is returned"]
    pub fn SCIPvarGetBestRootSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the best reduced costs (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation,\n  if the root relaxation is not yet completely solved, or the variable was no column of the root LP, SCIP_INVALID is\n  returned"]
    pub fn SCIPvarGetBestRootRedcost(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the best objective value (w.r.t. root reduced cost propagation) of the root LP which belongs the root\n  reduced cost which is accessible via SCIPvarGetRootRedcost() or the variable was no column of the root LP,\n  SCIP_INVALID is returned"]
    pub fn SCIPvarGetBestRootLPObjval(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " set the given solution as the best root solution w.r.t. root reduced cost propagation in the variables"]
    pub fn SCIPvarSetBestRootSol(
        var: *mut SCIP_VAR,
        rootsol: f64,
        rootredcost: f64,
        rootlpobjval: f64,
    );
}
unsafe extern "C" {
    #[doc = " returns a weighted average solution value of the variable in all feasible primal solutions found so far"]
    pub fn SCIPvarGetAvgSol(var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the bound change information for the last lower bound change on given active problem variable before or\n  after the bound change with the given index was applied;\n  returns NULL, if no change to the lower bound was applied up to this point of time"]
    pub fn SCIPvarGetLbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
unsafe extern "C" {
    #[doc = " returns the bound change information for the last upper bound change on given active problem variable before or\n  after the bound change with the given index was applied;\n  returns NULL, if no change to the upper bound was applied up to this point of time"]
    pub fn SCIPvarGetUbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
unsafe extern "C" {
    #[doc = " returns the bound change information for the last lower or upper bound change on given active problem variable\n  before or after the bound change with the given index was applied;\n  returns NULL, if no change to the lower/upper bound was applied up to this point of time"]
    pub fn SCIPvarGetBdchgInfo(
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
unsafe extern "C" {
    #[doc = " returns the last bound change index, at which the bounds of the given variable were tightened"]
    pub fn SCIPvarGetLastBdchgIndex(var: *mut SCIP_VAR) -> *mut SCIP_BDCHGIDX;
}
unsafe extern "C" {
    #[doc = " returns the last depth level, at which the bounds of the given variable were tightened;\n  returns -2, if the variable's bounds are still the global bounds\n  returns -1, if the variable was fixed in presolving"]
    pub fn SCIPvarGetLastBdchgDepth(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the first binary variable was fixed earlier than the second one;\n  returns FALSE, if the first variable is not fixed, and returns TRUE, if the first variable is fixed, but the\n  second one is not fixed"]
    pub fn SCIPvarWasFixedEarlier(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " for a given array of variables, this function counts the numbers of variables for each variable and implied type combination"]
    pub fn SCIPvarsCountTypes(
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nbinimplvars: *mut ::std::os::raw::c_int,
        nintimplvars: *mut ::std::os::raw::c_int,
        ncontimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one;\n  if a bound change index is NULL, the bound change index represents the current time, i.e. the time after the\n  last bound change was applied to the current node"]
    pub fn SCIPbdchgidxIsEarlier(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one"]
    pub fn SCIPbdchgidxIsEarlierNonNull(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns old bound that was overwritten for given bound change information"]
    pub fn SCIPbdchginfoGetOldbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
unsafe extern "C" {
    #[doc = " returns new bound installed for given bound change information"]
    pub fn SCIPbdchginfoGetNewbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
unsafe extern "C" {
    #[doc = " returns variable that belongs to the given bound change information"]
    pub fn SCIPbdchginfoGetVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns whether the bound change information belongs to a branching decision or a deduction"]
    pub fn SCIPbdchginfoGetChgtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDCHGTYPE;
}
unsafe extern "C" {
    #[doc = " returns whether the bound change information belongs to a lower or upper bound change"]
    pub fn SCIPbdchginfoGetBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " returns depth level of given bound change information"]
    pub fn SCIPbdchginfoGetDepth(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns bound change position in its depth level of given bound change information"]
    pub fn SCIPbdchginfoGetPos(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns bound change index of given bound change information"]
    pub fn SCIPbdchginfoGetIdx(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_BDCHGIDX;
}
unsafe extern "C" {
    #[doc = " returns inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns inference constraint of given bound change information"]
    pub fn SCIPbdchginfoGetInferCons(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " returns inference propagator of given bound change information, or NULL if no propagator was responsible"]
    pub fn SCIPbdchginfoGetInferProp(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_PROP;
}
unsafe extern "C" {
    #[doc = " returns inference user information of given bound change information"]
    pub fn SCIPbdchginfoGetInferInfo(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns inference bound of inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " returns whether the bound change information belongs to a redundant bound change"]
    pub fn SCIPbdchginfoIsRedundant(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the bound change has an inference reason (constraint or propagator), that can be resolved"]
    pub fn SCIPbdchginfoHasInferenceReason(
        bdchginfo: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " for two bound change informations belonging to the same variable and bound, returns whether the first bound change\n  has a tighter new bound as the second bound change"]
    pub fn SCIPbdchginfoIsTighter(
        bdchginfo1: *mut SCIP_BDCHGINFO,
        bdchginfo2: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the new value of the bound in the bound change data"]
    pub fn SCIPboundchgGetNewbound(boundchg: *mut SCIP_BOUNDCHG) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the lp solution value in the branching data of the bound change data"]
    pub fn SCIPboundchgGetLPSolVal(boundchg: *mut SCIP_BOUNDCHG) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable of the bound change in the bound change data"]
    pub fn SCIPboundchgGetVar(boundchg: *mut SCIP_BOUNDCHG) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the bound change type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundchgtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDCHGTYPE;
}
unsafe extern "C" {
    #[doc = " returns the bound type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " returns whether the bound change is redundant due to a more global bound that is at least as strong"]
    pub fn SCIPboundchgIsRedundant(boundchg: *mut SCIP_BOUNDCHG) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of bound changes in the domain change data"]
    pub fn SCIPdomchgGetNBoundchgs(domchg: *mut SCIP_DOMCHG) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns a particular bound change in the domain change data"]
    pub fn SCIPdomchgGetBoundchg(
        domchg: *mut SCIP_DOMCHG,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BOUNDCHG;
}
unsafe extern "C" {
    #[doc = " returns left bound of open interval in hole"]
    pub fn SCIPholelistGetLeft(holelist: *mut SCIP_HOLELIST) -> f64;
}
unsafe extern "C" {
    #[doc = " returns right bound of open interval in hole"]
    pub fn SCIPholelistGetRight(holelist: *mut SCIP_HOLELIST) -> f64;
}
unsafe extern "C" {
    #[doc = " returns next hole in list or NULL"]
    pub fn SCIPholelistGetNext(holelist: *mut SCIP_HOLELIST) -> *mut SCIP_HOLELIST;
}
unsafe extern "C" {
    #[doc = " gets a SCIP_Bool value from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetBool(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a long value from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetLong(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a SCIP_Real value from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetReal(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a string value from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetString(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a SCIP_Bool array from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetBoolArray(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *mut *mut ::std::os::raw::c_uint,
        nvalues: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a SCIP_Longint array from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetLongArray(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *mut *mut ::std::os::raw::c_longlong,
        nvalues: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a SCIP_Real array from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetRealArray(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *mut *mut f64,
        nvalues: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a string array from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetStringArray(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *mut *mut *mut ::std::os::raw::c_char,
        nvalues: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a data tree value from a SCIP_DATATREE object"]
    pub fn SCIPdatatreeGetTree(
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets name and version of LP solver"]
    pub fn SCIPlpiGetSolverName() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets description of LP solver (developer, webpage, ...)"]
    pub fn SCIPlpiGetSolverDesc() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets pointer for LP solver - use only with great care\n\n  The behavior of this function depends on the solver and its use is\n  therefore only recommended if you really know what you are\n  doing. In general, it returns a pointer to the LP solver object."]
    pub fn SCIPlpiGetSolverPointer(lpi: *mut SCIP_LPI) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " pass integrality information about variables to the solver"]
    pub fn SCIPlpiSetIntegralityInformation(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        intInfo: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs about availability of a primal simplex solving method"]
    pub fn SCIPlpiHasPrimalSolve() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " informs about availability of a dual simplex solving method"]
    pub fn SCIPlpiHasDualSolve() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " informs about availability of a barrier solving method"]
    pub fn SCIPlpiHasBarrierSolve() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates an LP problem object"]
    pub fn SCIPlpiCreate(
        lpi: *mut *mut SCIP_LPI,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        objsen: SCIP_OBJSEN,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes an LP problem object"]
    pub fn SCIPlpiFree(lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies LP data with column matrix into LP solver"]
    pub fn SCIPlpiLoadColLP(
        lpi: *mut SCIP_LPI,
        objsen: SCIP_OBJSEN,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds columns to the LP\n\n  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddCols(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes all columns in the given range from LP"]
    pub fn SCIPlpiDelCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes columns from SCIP_LPI; the new position of a column must not be greater that its old position"]
    pub fn SCIPlpiDelColset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds rows to the LP\n\n  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddRows(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes all rows in the given range from LP"]
    pub fn SCIPlpiDelRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes rows from SCIP_LPI; the new position of a row must not be greater that its old position"]
    pub fn SCIPlpiDelRowset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears the whole LP"]
    pub fn SCIPlpiClear(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower and upper bounds of columns"]
    pub fn SCIPlpiChgBounds(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lb: *const f64,
        ub: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left and right hand sides of rows"]
    pub fn SCIPlpiChgSides(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes a single coefficient"]
    pub fn SCIPlpiChgCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        newval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the objective sense"]
    pub fn SCIPlpiChgObjsen(lpi: *mut SCIP_LPI, objsen: SCIP_OBJSEN) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes objective values of columns in the LP"]
    pub fn SCIPlpiChgObj(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        obj: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " multiplies a row with a non-zero scalar; for negative scalars, the row's sense is switched accordingly"]
    pub fn SCIPlpiScaleRow(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " multiplies a column with a non-zero scalar; the objective value is multiplied with the scalar, and the bounds\n  are divided by the scalar; for negative scalars, the column's bounds are switched"]
    pub fn SCIPlpiScaleCol(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of rows in the LP"]
    pub fn SCIPlpiGetNRows(lpi: *mut SCIP_LPI, nrows: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of columns in the LP"]
    pub fn SCIPlpiGetNCols(lpi: *mut SCIP_LPI, ncols: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the objective sense of the LP"]
    pub fn SCIPlpiGetObjsen(lpi: *mut SCIP_LPI, objsen: *mut SCIP_OBJSEN) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of nonzero elements in the LP constraint matrix"]
    pub fn SCIPlpiGetNNonz(lpi: *mut SCIP_LPI, nnonz: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets columns from LP problem object; the arrays have to be large enough to store all values;\n  Either both, lb and ub, have to be NULL, or both have to be non-NULL,\n  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lb: *mut f64,
        ub: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets rows from LP problem object; the arrays have to be large enough to store all values.\n  Either both, lhs and rhs, have to be NULL, or both have to be non-NULL,\n  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhs: *mut f64,
        rhs: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets column names"]
    pub fn SCIPlpiGetColNames(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        colnames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets row names"]
    pub fn SCIPlpiGetRowNames(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        rownames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets objective coefficients from LP problem object"]
    pub fn SCIPlpiGetObj(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current bounds from LP problem object"]
    pub fn SCIPlpiGetBounds(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current row sides from LP problem object"]
    pub fn SCIPlpiGetSides(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhss: *mut f64,
        rhss: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a single coefficient"]
    pub fn SCIPlpiGetCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls primal simplex to solve the LP"]
    pub fn SCIPlpiSolvePrimal(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls dual simplex to solve the LP"]
    pub fn SCIPlpiSolveDual(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls barrier or interior point algorithm to solve the LP with crossover to simplex basis"]
    pub fn SCIPlpiSolveBarrier(
        lpi: *mut SCIP_LPI,
        crossover: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " start strong branching - call before any strong branching"]
    pub fn SCIPlpiStartStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " end strong branching - call after any strong branching"]
    pub fn SCIPlpiEndStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs strong branching iterations on one @b fractional candidate"]
    pub fn SCIPlpiStrongbranchFrac(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs strong branching iterations on given @b fractional candidates"]
    pub fn SCIPlpiStrongbranchesFrac(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs strong branching iterations on one candidate with @b integral value"]
    pub fn SCIPlpiStrongbranchInt(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs strong branching iterations on given candidates with @b integral values"]
    pub fn SCIPlpiStrongbranchesInt(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether a solve method was called after the last modification of the LP"]
    pub fn SCIPlpiWasSolved(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets information about primal and dual feasibility of the current LP solution\n\n  The feasibility information is with respect to the last solving call and it is only relevant if SCIPlpiWasSolved()\n  returns true. If the LP is changed, this information might be invalidated.\n\n  Note that @p primalfeasible and @p dualfeasible should only return true if the solver has proved the respective LP to\n  be feasible. Thus, the return values should be equal to the values of SCIPlpiIsPrimalFeasible() and\n  SCIPlpiIsDualFeasible(), respectively. Note that if feasibility cannot be proved, they should return false (even if\n  the problem might actually be feasible)."]
    pub fn SCIPlpiGetSolFeasibility(
        lpi: *mut SCIP_LPI,
        primalfeasible: *mut ::std::os::raw::c_uint,
        dualfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point);\n  this does not necessarily mean, that the solver knows and can return the primal ray"]
    pub fn SCIPlpiExistsPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point),\n  and the solver knows and can return the primal ray"]
    pub fn SCIPlpiHasPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal unbounded"]
    pub fn SCIPlpiIsPrimalUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal infeasible"]
    pub fn SCIPlpiIsPrimalInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal feasible"]
    pub fn SCIPlpiIsPrimalFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point);\n  this does not necessarily mean, that the solver knows and can return the dual ray"]
    pub fn SCIPlpiExistsDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point),\n  and the solver knows and can return the dual ray"]
    pub fn SCIPlpiHasDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual unbounded"]
    pub fn SCIPlpiIsDualUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual infeasible"]
    pub fn SCIPlpiIsDualInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual feasible"]
    pub fn SCIPlpiIsDualFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff LP was solved to optimality"]
    pub fn SCIPlpiIsOptimal(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff current LP solution is stable\n\n  This function should return true if the solution is reliable, i.e., feasible and optimal (or proven\n  infeasible/unbounded) with respect to the original problem. The optimality status might be with respect to a scaled\n  version of the problem, but the solution might not be feasible to the unscaled original problem; in this case,\n  SCIPlpiIsStable() should return false."]
    pub fn SCIPlpiIsStable(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff the objective limit was reached"]
    pub fn SCIPlpiIsObjlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff the iteration limit was reached"]
    pub fn SCIPlpiIsIterlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff the time limit was reached"]
    pub fn SCIPlpiIsTimelimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the internal solution status of the solver"]
    pub fn SCIPlpiGetInternalStatus(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " tries to reset the internal status of the LP solver in order to ignore an instability of the last solving call"]
    pub fn SCIPlpiIgnoreInstability(
        lpi: *mut SCIP_LPI,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets objective value of solution"]
    pub fn SCIPlpiGetObjval(lpi: *mut SCIP_LPI, objval: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets primal and dual solution vectors for feasible LPs\n\n  Before calling this function, the caller must ensure that the LP has been solved to optimality, i.e., that\n  SCIPlpiIsOptimal() returns true."]
    pub fn SCIPlpiGetSol(
        lpi: *mut SCIP_LPI,
        objval: *mut f64,
        primsol: *mut f64,
        dualsol: *mut f64,
        activity: *mut f64,
        redcost: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets primal ray for unbounded LPs"]
    pub fn SCIPlpiGetPrimalRay(lpi: *mut SCIP_LPI, ray: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets dual Farkas proof for infeasibility"]
    pub fn SCIPlpiGetDualfarkas(lpi: *mut SCIP_LPI, dualfarkas: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of LP iterations of the last solve call"]
    pub fn SCIPlpiGetIterations(
        lpi: *mut SCIP_LPI,
        iterations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets information about the quality of an LP solution\n\n  Such information is usually only available, if also a (maybe not optimal) solution is available.\n  The LPI should return SCIP_INVALID for @p quality, if the requested quantity is not available."]
    pub fn SCIPlpiGetRealSolQuality(
        lpi: *mut SCIP_LPI,
        qualityindicator: SCIP_LPSOLQUALITY,
        quality: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current basis status for columns and rows; arrays must be large enough to store the basis status"]
    pub fn SCIPlpiGetBase(
        lpi: *mut SCIP_LPI,
        cstat: *mut ::std::os::raw::c_int,
        rstat: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets current basis status for columns and rows"]
    pub fn SCIPlpiSetBase(
        lpi: *mut SCIP_LPI,
        cstat: *const ::std::os::raw::c_int,
        rstat: *const ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the indices of the basic columns and rows; basic column n gives value n, basic row m gives value -1-m"]
    pub fn SCIPlpiGetBasisInd(lpi: *mut SCIP_LPI, bind: *mut ::std::os::raw::c_int)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get row of inverse basis matrix B^-1\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvRow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get column of inverse basis matrix B^-1\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvCol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get row of inverse basis matrix times constraint matrix B^-1 * A\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvARow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        binvrow: *const f64,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get column of inverse basis matrix times constraint matrix B^-1 * A\n\n  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver\n        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;\n        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvACol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores LPi state (like basis information) into lpistate object"]
    pub fn SCIPlpiGetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads LPi state (like basis information) into solver; note that the LP might have been extended with additional\n  columns and rows since the state was stored with SCIPlpiGetState()"]
    pub fn SCIPlpiSetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *const SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears current LPi state (like basis information) of the solver"]
    pub fn SCIPlpiClearState(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees LPi state information"]
    pub fn SCIPlpiFreeState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether the given LPi state contains simplex basis information"]
    pub fn SCIPlpiHasStateBasis(
        lpi: *mut SCIP_LPI,
        lpistate: *mut SCIP_LPISTATE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " reads LPi state (like basis information from a file"]
    pub fn SCIPlpiReadState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes LPi state (i.e. basis information) to a file"]
    pub fn SCIPlpiWriteState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores LPi pricing norms into lpinorms object"]
    pub fn SCIPlpiGetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads LPi pricing norms into solver; note that the LP might have been extended with additional\n  columns and rows since the norms were stored with SCIPlpiGetNorms()"]
    pub fn SCIPlpiSetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *const SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees LPi pricing norms information"]
    pub fn SCIPlpiFreeNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets integer parameter of LP"]
    pub fn SCIPlpiGetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets integer parameter of LP"]
    pub fn SCIPlpiSetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets floating point parameter of LP"]
    pub fn SCIPlpiGetRealpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        dval: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets floating point parameter of LP"]
    pub fn SCIPlpiSetRealpar(lpi: *mut SCIP_LPI, type_: SCIP_LPPARAM, dval: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " interrupts the currently ongoing lp solve or disables the interrupt"]
    pub fn SCIPlpiInterrupt(lpi: *mut SCIP_LPI, interrupt: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns value treated as infinity in the LP solver"]
    pub fn SCIPlpiInfinity(lpi: *mut SCIP_LPI) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if given value is treated as infinity in the LP solver"]
    pub fn SCIPlpiIsInfinity(lpi: *mut SCIP_LPI, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " reads LP from a file"]
    pub fn SCIPlpiReadLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes LP to a file"]
    pub fn SCIPlpiWriteLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = "@defgroup PublicSpecialPresolveMethods Special Methods\n @ingroup PublicPresolverMethods\n @brief methods commonly used for presolving\n\n @{\n/\n/** try to reduce the necessary variable in a set of variables with corresponding bounds and boundtypes for which one\n  must be fulfilled\n\n  e.g. a set of logicor or bounddisjunctive constraint variables would be such a set\n\n  consider the following set:\n\n  x1 >= 1, x2 >= 3, x3 >= 1, x4 <= 0\n\n  by (global) implication data (cliques, implications, and variable bounds) we have also the following implications\n  given:\n\n  x1 >= 1 => x3 >= 1\n  x2 >= 2 => x3 >= 1\n  x4 <= 0 => x1 >= 1\n\n  Because of the last implication x4 is redundant, because x1 >= 1 would also be fulfilled in the variable set, so we\n  can reduce the set by x4.\n  Also, the both other implications and x3 >= 1 (in the given variable set) all imply exactly x3 >= 1, so we tighten\n  the global lower bound of x3 to 1 and the set of variables gets redundant."]
    pub fn SCIPshrinkDisjunctiveVarSet(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        bounds: *mut f64,
        boundtypes: *mut ::std::os::raw::c_uint,
        redundants: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        nredvars: *mut ::std::os::raw::c_int,
        nglobalred: *mut ::std::os::raw::c_int,
        setredundant: *mut ::std::os::raw::c_uint,
        glbinfeas: *mut ::std::os::raw::c_uint,
        fullshortening: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_AggrRow {
    #[doc = "< non-zero coefficients of the cut row"]
    pub vals: *mut f64,
    #[doc = "< problem indices of variables with a non-zero coefficient in the cut row"]
    pub inds: *mut ::std::os::raw::c_int,
    #[doc = "< lpposition of rows that have been added to the cutrow"]
    pub rowsinds: *mut ::std::os::raw::c_int,
    #[doc = "< slacksign of rows that have been added to the cutrow"]
    pub slacksign: *mut ::std::os::raw::c_int,
    #[doc = "< weights of rows that have been added to the cutrow"]
    pub rowweights: *mut f64,
    #[doc = "< right hand side of the cut row"]
    pub rhshi: f64,
    #[doc = "< right hand side of the cut row"]
    pub rhslo: f64,
    #[doc = "< number of non-zeros in the cut row"]
    pub nnz: ::std::os::raw::c_int,
    #[doc = "< number of rows that have been added to the cutrow"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< size of the row and slacksign array"]
    pub rowssize: ::std::os::raw::c_int,
    #[doc = "< rank of the cut row"]
    pub rank: ::std::os::raw::c_int,
    #[doc = "< is the cut row only valid locally?"]
    pub local: ::std::os::raw::c_uint,
    #[doc = "< proof index in certificate or SCIP_LONGINT_MAX"]
    pub certificateline: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_AggrRow"][::std::mem::size_of::<SCIP_AggrRow>() - 88usize];
    ["Alignment of SCIP_AggrRow"][::std::mem::align_of::<SCIP_AggrRow>() - 8usize];
    ["Offset of field: SCIP_AggrRow::vals"][::std::mem::offset_of!(SCIP_AggrRow, vals) - 0usize];
    ["Offset of field: SCIP_AggrRow::inds"][::std::mem::offset_of!(SCIP_AggrRow, inds) - 8usize];
    ["Offset of field: SCIP_AggrRow::rowsinds"]
        [::std::mem::offset_of!(SCIP_AggrRow, rowsinds) - 16usize];
    ["Offset of field: SCIP_AggrRow::slacksign"]
        [::std::mem::offset_of!(SCIP_AggrRow, slacksign) - 24usize];
    ["Offset of field: SCIP_AggrRow::rowweights"]
        [::std::mem::offset_of!(SCIP_AggrRow, rowweights) - 32usize];
    ["Offset of field: SCIP_AggrRow::rhshi"][::std::mem::offset_of!(SCIP_AggrRow, rhshi) - 40usize];
    ["Offset of field: SCIP_AggrRow::rhslo"][::std::mem::offset_of!(SCIP_AggrRow, rhslo) - 48usize];
    ["Offset of field: SCIP_AggrRow::nnz"][::std::mem::offset_of!(SCIP_AggrRow, nnz) - 56usize];
    ["Offset of field: SCIP_AggrRow::nrows"][::std::mem::offset_of!(SCIP_AggrRow, nrows) - 60usize];
    ["Offset of field: SCIP_AggrRow::rowssize"]
        [::std::mem::offset_of!(SCIP_AggrRow, rowssize) - 64usize];
    ["Offset of field: SCIP_AggrRow::rank"][::std::mem::offset_of!(SCIP_AggrRow, rank) - 68usize];
    ["Offset of field: SCIP_AggrRow::local"][::std::mem::offset_of!(SCIP_AggrRow, local) - 72usize];
    ["Offset of field: SCIP_AggrRow::certificateline"]
        [::std::mem::offset_of!(SCIP_AggrRow, certificateline) - 80usize];
};
pub type SCIP_AGGRROW = SCIP_AggrRow;
unsafe extern "C" {
    #[doc = " perform activity based coefficient tigthening on the given cut; returns TRUE if the cut was detected\n  to be redundant due to acitivity bounds\n\n  See also cons_linear.c:consdataTightenCoefs()."]
    pub fn SCIPcutsTightenCoefficients(
        scip: *mut SCIP,
        cutislocal: ::std::os::raw::c_uint,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " create an empty aggregation row\n\n  @note By default, this data structure uses quad precision via double-double arithmetic, i.e., it allocates a\n        SCIP_Real array of length two times SCIPgetNVars() for storing the coefficients.  In exact solving mode, we\n        cannot use quad precision because we need to control the ronding mode, hence only the first SCIPgetNVars()\n        entries are used."]
    pub fn SCIPaggrRowCreate(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " free a the aggregation row"]
    pub fn SCIPaggrRowFree(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW);
}
unsafe extern "C" {
    #[doc = " output aggregation row to file stream"]
    pub fn SCIPaggrRowPrint(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " copy the aggregation row"]
    pub fn SCIPaggrRowCopy(
        scip: *mut SCIP,
        aggrrow: *mut *mut SCIP_AGGRROW,
        source: *mut SCIP_AGGRROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add weighted row to the aggregation row"]
    pub fn SCIPaggrRowAddRow(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
        weight: f64,
        sidetype: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add weighted row to aggregation row\n @note this method is the variant of SCIPaggrRowAddRow that is safe to use in exact solving mode"]
    pub fn SCIPaggrRowAddRowSafely(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
        weight: f64,
        sidetype: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Removes a given variable @p var from position @p pos the aggregation row and updates the right-hand side according\n  to sign of the coefficient, i.e., rhs -= coef * bound, where bound = lb if coef >= 0 and bound = ub, otherwise.\n\n  @note: The choice of global or local bounds depend on the validity (global or local) of the aggregation row.\n\n  @note: The list of non-zero indices will be updated by swapping the last non-zero index to @p pos."]
    pub fn SCIPaggrRowCancelVarWithBound(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " add the objective function with right-hand side @p rhs and scaled by @p scale to the aggregation row"]
    pub fn SCIPaggrRowAddObjectiveFunction(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        rhs: f64,
        scale: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add the objective function with right-hand side @p rhs and scaled by @p scale to the aggregation row\n  variant of SCIPaggrRowAddObjectiveFunction that is safe to use in exact mode"]
    pub fn SCIPaggrRowAddObjectiveFunctionSafely(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        rhs: f64,
        scale: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add weighted constraint to the aggregation row"]
    pub fn SCIPaggrRowAddCustomCons(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        inds: *mut ::std::os::raw::c_int,
        vals: *mut f64,
        len: ::std::os::raw::c_int,
        rhs: f64,
        weight: f64,
        rank: ::std::os::raw::c_int,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter\n\n  @return the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPaggrRowCalcEfficacyNorm(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW) -> f64;
}
unsafe extern "C" {
    #[doc = " clear all entries in the aggregation row but do not free the internal memory"]
    pub fn SCIPaggrRowClear(aggrrow: *mut SCIP_AGGRROW);
}
unsafe extern "C" {
    #[doc = " version for use in exact solving mode of SCIPaggrRowClear()"]
    pub fn SCIPaggrRowClearSafely(aggrrow: *mut SCIP_AGGRROW);
}
unsafe extern "C" {
    #[doc = " aggregate rows using the given weights; the current content of the aggregation row, \\p aggrrow, is overwritten\n\n  @note this method is safe for usage in exact solving mode"]
    pub fn SCIPaggrRowSumRows(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        weights: *mut f64,
        rowinds: *mut ::std::os::raw::c_int,
        nrowinds: ::std::os::raw::c_int,
        sidetypebasis: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        negslack: ::std::os::raw::c_int,
        maxaggrlen: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all (close enough to) zero entries in the aggregation row"]
    pub fn SCIPaggrRowRemoveZeros(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        useglbbounds: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " get array with lp positions of aggregated rows"]
    pub fn SCIPaggrRowGetRowInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get array with weights of aggregated rows"]
    pub fn SCIPaggrRowGetRowWeights(aggrrow: *mut SCIP_AGGRROW) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " checks whether a given row has been added to the aggregation row"]
    pub fn SCIPaggrRowHasRowBeenAdded(
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the min and max absolute value of the weights used to aggregate the rows;\n  must not be called for empty aggregation rows"]
    pub fn SCIPaggrRowGetAbsWeightRange(
        aggrrow: *mut SCIP_AGGRROW,
        minabsrowweight: *mut f64,
        maxabsrowweight: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " gets the array of corresponding variable problem indices for each non-zero in the aggregation row"]
    pub fn SCIPaggrRowGetInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of non-zeros in the aggregation row"]
    pub fn SCIPaggrRowGetNNz(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the rank of the aggregation row"]
    pub fn SCIPaggrRowGetRank(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " checks if the aggregation row is only valid locally"]
    pub fn SCIPaggrRowIsLocal(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the right hand side of the aggregation row"]
    pub fn SCIPaggrRowGetRhs(aggrrow: *mut SCIP_AGGRROW) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the number of row aggregations"]
    pub fn SCIPaggrRowGetNRows(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in an MIR cut.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        vartypeusevbds: ::std::os::raw::c_int,
        allowlocal: ::std::os::raw::c_uint,
        fixintegralrhs: ::std::os::raw::c_uint,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in an MIR cut. The function uses a cut generation heuristic which tries different scaling\n  factors and complementations of the variables to improve the cut's efficacy.\n  For further details we refer to:\n\n  Marchand, H., & Wolsey, L. A. (2001). Aggregation and mixed integer rounding to solve MIPs.\n  Operations research, 49(3), 363-371.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcutGenerationHeuristicCMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        vartypeusevbds: ::std::os::raw::c_int,
        allowlocal: ::std::os::raw::c_uint,
        maxtestdelta: ::std::os::raw::c_int,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a lifted simple generalized flow cover cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in the cut.\n  For further details we refer to:\n\n  Gu, Z., Nemhauser, G. L., & Savelsbergh, M. W. (1999). Lifted flow cover inequalities for mixed 0-1 integer programs.\n  Mathematical Programming, 85(3), 439-467.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcFlowCover(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        allowlocal: ::std::os::raw::c_uint,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a lifted knapsack cover cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in the cut.\n  For further details we refer to:\n\n  Letchford, A. N., & Souli, G. (2019). On lifted cover inequalities: A new lifting procedure with unusual properties.\n  Operations Research Letters, 47(2), 83-87.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcKnapsackCover(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        allowlocal: ::std::os::raw::c_uint,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a strong CG cut out of the weighted sum of LP rows given by an aggregation row; the\n  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot\n  participate in a strongcg cut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcStrongCG(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        vartypeusevbds: ::std::os::raw::c_int,
        allowlocal: ::std::os::raw::c_uint,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs a diving within the limits of the @p diveset parameters\n\n  This method performs a diving according to the settings defined by the diving settings @p diveset; Contrary to the\n  name, SCIP enters probing mode (not diving mode) and dives along a path into the tree. Domain propagation\n  is applied at every node in the tree, whereas probing LPs might be solved less frequently.\n\n  Starting from the current LP solution, the algorithm selects candidates which maximize the\n  score defined by the @p diveset and whose solution value has not yet been rendered infeasible by propagation,\n  and propagates the bound change on this candidate.\n\n  The algorithm iteratively selects the the next (unfixed) candidate in the list, until either enough domain changes\n  or the resolve frequency of the LP trigger an LP resolve (and hence, the set of potential candidates changes),\n  or the last node is proven to be infeasible. It optionally backtracks and tries the\n  other branching direction.\n\n  After the set of remaining candidates is empty or the targeted depth is reached, the node LP is\n  solved, and the old candidates are replaced by the new LP candidates.\n\n  @see heur_guideddiving.c for an example implementation of a dive set controlling the diving algorithm.\n\n  @note the node from where the algorithm is called is checked for a basic LP solution. If the solution\n        is non-basic, e.g., when barrier without crossover is used, the method returns without performing a dive.\n\n  @note currently, when multiple diving heuristics call this method and solve an LP at the same node, only the first\n        call will be executed, @see SCIPgetLastDiveNode()."]
    pub fn SCIPperformGenericDivingAlgorithm(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        worksol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        nodeinfeasible: ::std::os::raw::c_uint,
        iterlim: ::std::os::raw::c_longlong,
        nodelimit: ::std::os::raw::c_int,
        lpresolvedomchgquot: f64,
        divecontext: SCIP_DIVECONTEXT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get a sub-SCIP copy of the transformed problem"]
    pub fn SCIPcopyLargeNeighborhoodSearch(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        uselprows: ::std::os::raw::c_uint,
        copycuts: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a trust region neighborhood constraint to the @p targetscip\n\n  a trust region constraint measures the deviation from the current incumbent solution \\f$x^*\\f$ by an auxiliary\n  continuous variable \\f$v \\geq 0\\f$:\n  \\f[\n    \\sum\\limits_{j\\in B} |x_j^* - x_j| = v\n  \\f]\n  Only binary variables are taken into account. The deviation is penalized in the objective function using\n  a positive \\p violpenalty.\n\n  @note: the trust region constraint creates an auxiliary variable to penalize the deviation from\n  the current incumbent solution. This variable can afterwards be accessed using SCIPfindVar() by its name\n  'trustregion_violationvar'"]
    pub fn SCIPaddTrustregionNeighborhoodConstraint(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        subvars: *mut *mut SCIP_VAR,
        violpenalty: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes a bandit algorithm virtual function table"]
    pub fn SCIPincludeBanditvtable(
        scip: *mut SCIP,
        banditvtable: *mut *mut SCIP_BANDITVTABLE,
        name: *const ::std::os::raw::c_char,
        banditfree: ::std::option::Option<
            unsafe extern "C" fn(blkmem: *mut BMS_BLKMEM, bandit: *mut SCIP_BANDIT) -> SCIP_RETCODE,
        >,
        banditselect: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        banditupdate: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: ::std::os::raw::c_int,
                score: f64,
            ) -> SCIP_RETCODE,
        >,
        banditreset: ::std::option::Option<
            unsafe extern "C" fn(
                bufmem: *mut BMS_BUFMEM,
                bandit: *mut SCIP_BANDIT,
                priorities: *mut f64,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the bandit virtual function table of the given name, or NULL if not existing"]
    pub fn SCIPfindBanditvtable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BANDITVTABLE;
}
unsafe extern "C" {
    #[doc = " calls destructor and frees memory of bandit algorithm"]
    pub fn SCIPfreeBandit(scip: *mut SCIP, bandit: *mut *mut SCIP_BANDIT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reset the bandit algorithm"]
    pub fn SCIPresetBandit(
        scip: *mut SCIP,
        bandit: *mut SCIP_BANDIT,
        priorities: *mut f64,
        seed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP\n\n  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is\n        added in future releases; consider using SCIPincludeBendersBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP with all non-fundamental callbacks set to NULL\n\n  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBendersCopy(),\n  SCIPsetBendersFree(), SCIPsetBendersInity(), SCIPsetBendersExit(), SCIPsetBendersInitsol(), SCIPsetBendersExitsol(),\n  SCIPsetBendersFarkas().\n\n  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBendersBasic(
        scip: *mut SCIP,
        bendersptr: *mut *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersCopy(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersFree(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the method called prior to solving the subproblems for benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPresubsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the subproblem solving and freeing methods for Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSolveAndFreesub(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the post solving methods for benders\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPostsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the subproblem comparison method for determining the solving order in Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSubproblemComp(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssubcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the Benders' decomposition of the given name, or NULL if not existing"]
    pub fn SCIPfindBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERS;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available Benders' decomposition; active Benders' decomposition are in the first\n slots of the array"]
    pub fn SCIPgetBenders(scip: *mut SCIP) -> *mut *mut SCIP_BENDERS;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available Benders' decomposition"]
    pub fn SCIPgetNBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of currently active Benders' decomposition"]
    pub fn SCIPgetNActiveBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " activates the Benders' decomposition to be used for the current problem\n\n  This method should be called during the problem creation stage for all pricers that are necessary to solve\n  the problem model.\n\n  @note The Benders' decompositions are automatically deactivated when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivateBenders(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        nsubproblems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deactivates the Benders' decomposition\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivateBenders(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPsetBendersPriority(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        priority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets the objective type for the aggregation of the Benders' decomposition subproblem objectives. This is either the\n summation of the objective values or a minimax of the objective values (such as for a makespan objective)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersObjectiveType(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        objectivetype: SCIP_BENDERSOBJTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the exec method of Benders' decomposition to solve the subproblems\n\n  The checkint flag indicates whether integer feasibility can be assumed. If it is not assumed, i.e. checkint ==\n  FALSE, then only the convex relaxations of the subproblems are solved. If integer feasibility is assumed, i.e.\n  checkint == TRUE, then the convex relaxations and the full CIP are solved to generate Benders' cuts and check\n  solution feasibility.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
        infeasible: *mut ::std::os::raw::c_uint,
        auxviol: *mut ::std::os::raw::c_uint,
        type_: SCIP_BENDERSENFOTYPE,
        checkint: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the master problem variable for the given subproblem variable\n\n  This function is used as part of the cut generation process.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersMasterVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the subproblem problem variable for the given master variable\n\n  This function is used as part of the cut generation process.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersSubproblemVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of subproblems that are stored in the given Benders' decomposition\n\n  @return the number of subproblems in the Benders' decomposition"]
    pub fn SCIPgetBendersNSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " registers the Benders' decomposition subproblem with the Benders' decomposition struct.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        subproblem: *mut SCIP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the generic subproblem setup method for a Benders' decomposition subproblem\n\n  This is called if the user requires to solve the Benders' decomposition subproblem separately from the main Benders'\n  solving loop. This could be in the case of enhancement techniques.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsetupBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        type_: SCIP_BENDERSENFOTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the solving method for a single Benders' decomposition subproblem\n\n  The method either calls the users solve subproblem method or calls the generic method. In the case of the generic\n  method, the user must set up the subproblem prior to calling this method.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        solvecip: ::std::os::raw::c_uint,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the subproblem after calling the solve subproblem method\n\n  This will either call the user defined free\n  subproblem callback for Benders' decomposition or the default freeing methods. In the default case, if the\n  subproblem is an LP, then SCIPendProbing is called. If the subproblem is a MIP, then SCIPfreeTransform is called.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks the optimality of a Benders' decomposition subproblem by comparing the objective function value against the\n  value of the corresponding auxiliary variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if requested subproblem is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckBendersSubproblemOptimality(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        optimal: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the value of the auxiliary variable for a given subproblem"]
    pub fn SCIPgetBendersAuxiliaryVarVal(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " solves an independent subproblem to identify its lower bound and updates the lower bound of the corresponding\n  auxiliary variable\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcomputeBendersSubproblemLowerbound(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: *mut f64,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " merges a subproblem into the master problem.\n\n  This process just adds a copy of the subproblem variables and constraints to the master problem, but keeps the\n  subproblem stored in the Benders' decomposition data structure.  The reason for keeping the subproblem available is\n  for when it is queried for solutions after the problem is solved.\n\n  Once the subproblem is merged into the master problem, then the subproblem is flagged as disabled. This means that\n  it will not be solved in the subsequent subproblem solving loops.\n\n  The associated auxiliary variables are kept in the master problem. The objective function of the merged subproblem\n  is added as an underestimator constraint.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPmergeBendersSubproblemIntoMaster(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a Benders' cut algorithms and includes it in the associated Benders' decomposition\n\n  This should be called from the SCIPincludeBendersXyz for the associated Benders' decomposition. It is only possible\n  to include a Benders' cut algorithm if a Benders' decomposition has already been included\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is\n        added in future releases; consider using SCIPincludeBendersBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenderscut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a Benders' cut and includes it an associated Benders' decomposition with all non-fundamental callbacks set to NULL\n\n  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBenderscutCopy(),\n  SCIPsetBenderscutFree(), SCIPsetBenderscutInit(), SCIPsetBenderscutExit(), SCIPsetBenderscutInitsol(),\n  SCIPsetBenderscutExitsol().\n\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBenderscutBasic(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscutptr: *mut *mut SCIP_BENDERSCUT,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of Benders' decomposition cut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutCopy(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutFree(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of benderscut\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the priority of a Benders' decomposition cut algorithm\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutPriority(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds the generated cuts to the Benders' cut storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstoreBendersCut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " applies the Benders' decomposition cuts in storage to the input SCIP instance\n\n  When calling the function, the user must be sure that the variables are associated with the input SCIP instance.\n  The main use of this method is to transfer Benders' cuts between solvers in ParaSCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyBendersStoredCuts(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP\n  @pre This method can be called if SCIP is in one of the following stages:\n      - \\ref SCIP_STAGE_INIT\n      - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all branching rule callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeBranchruleBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetBranchruleInit(), SCIPsetBranchruleExit(),\n  SCIPsetBranchruleCopy(), SCIPsetBranchruleFree(), SCIPsetBranchruleInitsol(), SCIPsetBranchruleExitsol(),\n  SCIPsetBranchruleExecLp(), SCIPsetBranchruleExecExt(), and SCIPsetBranchruleExecPs().\n\n  @pre This method can be called if SCIP is in one of the following stages:\n     - \\ref SCIP_STAGE_INIT\n     - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBranchrule() instead"]
    pub fn SCIPincludeBranchruleBasic(
        scip: *mut SCIP,
        branchruleptr: *mut *mut SCIP_BRANCHRULE,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of branching rule"]
    pub fn SCIPsetBranchruleCopy(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of branching rule"]
    pub fn SCIPsetBranchruleFree(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of branching rule"]
    pub fn SCIPsetBranchruleInit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of branching rule"]
    pub fn SCIPsetBranchruleInitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets branching execution method for fractional LP solutions"]
    pub fn SCIPsetBranchruleExecLp(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets branching execution method for external candidates"]
    pub fn SCIPsetBranchruleExecExt(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets branching execution method for not completely fixed pseudo solutions"]
    pub fn SCIPsetBranchruleExecPs(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the branching rule of the given name, or NULL if not existing"]
    pub fn SCIPfindBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BRANCHRULE;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available branching rules"]
    pub fn SCIPgetBranchrules(scip: *mut SCIP) -> *mut *mut SCIP_BRANCHRULE;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available branching rules"]
    pub fn SCIPgetNBranchrules(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a branching rule"]
    pub fn SCIPsetBranchrulePriority(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPsetBranchruleMaxdepth(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPsetBranchruleMaxbounddist(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxbounddist: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets branching candidates for LP solution branching (fractional variables) along with solution values,\n  fractionalities, and number of branching candidates; the number of branching candidates does not\n  account for fractional continuous implied integral variables, which should not be used for branching\n\n  fractional continuous implied integral variables are stored from *nlpcands to *nlpcands + *nfracimplvars - 1\n\n  branching rules should always select the branching candidate among the first npriolpcands of the candidate\n  list\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBranchCands(
        scip: *mut SCIP,
        lpcands: *mut *mut *mut SCIP_VAR,
        lpcandssol: *mut *mut f64,
        lpcandsfrac: *mut *mut f64,
        nlpcands: *mut ::std::os::raw::c_int,
        npriolpcands: *mut ::std::os::raw::c_int,
        nfracimplvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of branching candidates for LP solution branching (number of fractional variables); implied integral\n  variables with integrality constraints are included\n\n  @return the number of branching candidates for LP solution branching (number of fractional variables).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of branching candidates with maximal priority for LP solution branching\n\n  @return the number of branching candidates with maximal priority for LP solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets external branching candidates along with solution values, scores, and number of branching candidates;\n  these branching candidates can be used by relaxations or nonlinear constraint handlers;\n  branching rules should always select the branching candidate among the first nprioexterncands of the candidate\n  list\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note Candidate variables with maximal priority are ordered: binaries first, then integers, implicit integers and\n        continuous last."]
    pub fn SCIPgetExternBranchCands(
        scip: *mut SCIP,
        externcands: *mut *mut *mut SCIP_VAR,
        externcandssol: *mut *mut f64,
        externcandsscore: *mut *mut f64,
        nexterncands: *mut ::std::os::raw::c_int,
        nprioexterncands: *mut ::std::os::raw::c_int,
        nprioexternbins: *mut ::std::os::raw::c_int,
        nprioexternints: *mut ::std::os::raw::c_int,
        nprioexternimpls: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of external branching candidates\n\n  @return the number of external branching candidates.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of external branching candidates with maximal branch priority\n\n  @return the number of external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary external branching candidates with maximal branch priority\n\n  @return the number of binary external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integer external branching candidates with maximal branch priority\n\n  @return the number of integer external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of implicit integer external branching candidates with maximal branch priority\n\n  @return the number of implicit integer external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of continuous external branching candidates with maximal branch priority\n\n  @return the number of continuous external branching candidates with maximal branch priority.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchConts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " insert variable, its score and its solution value into the external branching candidate storage\n the relative difference of the current lower and upper bounds of a continuous variable must be at least epsilon\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        score: f64,
        solval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all external candidates from the storage for external branching\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearExternBranchCands(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " checks whether the given variable is contained in the candidate storage for external branching\n\n  @return whether the given variable is contained in the candidate storage for external branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcontainsExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets branching candidates for pseudo solution branching (non-fixed variables) along with the number of candidates\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoBranchCands(
        scip: *mut SCIP,
        pseudocands: *mut *mut *mut SCIP_VAR,
        npseudocands: *mut ::std::os::raw::c_int,
        npriopseudocands: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of branching candidates for pseudo solution branching (non-fixed variables)\n\n  @return the number branching candidates for pseudo solution branching (non-fixed variables).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of binary branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integer branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of integer branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of implicit integer branching candidates with maximal branch priority for pseudo solution branching\n\n  @return the number of implicit integer branching candidates with maximal branch priority for pseudo solution branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a binary branching\n\n  @return the branching score out of the gain predictions for a binary branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downgain: f64,
        upgain: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a branching with arbitrary many children\n\n  @return the branching score out of the gain predictions for a branching with arbitrary many children.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScoreMultiple(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nchildren: ::std::os::raw::c_int,
        gains: *mut f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " computes a branching point for a continuous or discrete variable\n\n  @see SCIPbranchGetBranchingPoint\n\n  @return the branching point for a continuous or discrete variable.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchingPoint(scip: *mut SCIP, var: *mut SCIP_VAR, suggestion: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the node selection priority for moving the given variable's LP value to the given target value;\n  this node selection priority can be given to the SCIPcreateChild() call\n\n  @return the node selection priority for moving the given variable's LP value to the given target value.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcNodeselPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdir: SCIP_BRANCHDIR,
        targetvalue: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates an estimate for the objective of the best feasible solution contained in the subtree after applying the given\n  branching; this estimate can be given to the SCIPcreateChild() call\n\n  @return the estimate for the objective of the best feasible solution contained in the subtree after applying the given\n  branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimate(scip: *mut SCIP, var: *mut SCIP_VAR, targetvalue: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the increase of the estimate for the objective of the best feasible solution contained in the subtree\n  after applying the given branching\n\n  @return the increase of the estimate for the objective of the best feasible solution contained in the subtree after\n          applying the given branching.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimateIncrease(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varsol: f64,
        targetvalue: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a child node of the focus node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreateChild(
        scip: *mut SCIP,
        node: *mut *mut SCIP_NODE,
        nodeselprio: f64,
        estimate: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " branches on a non-continuous variable v using the current LP or pseudo solution;\n  if solution value x' is fractional, two child nodes will be created\n  (x <= floor(x'), x >= ceil(x')),\n  if solution value is integral, the x' is equal to lower or upper bound of the branching\n  variable and the bounds of v are finite, then two child nodes will be created\n  (x <= x'', x >= x''+1 with x'' = floor((lb + ub)/2)),\n  otherwise (up to) three child nodes will be created\n  (x <= x'-1, x == x', x >= x'+1)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " branches a variable x using a given domain hole; two child nodes (x <= left, x >= right) are created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarHole(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        downchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " branches on a variable x using a given value x';\n  for continuous variables with relative domain width larger epsilon, x' must not be one of the bounds;\n  two child nodes (x <= x', x >= x') are created;\n  for integer variables, if solution value x' is fractional, two child nodes are created\n  (x <= floor(x'), x >= ceil(x')),\n  if x' is integral, three child nodes are created\n  (x <= x'-1, x == x', x >= x'+1)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarVal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " n-ary branching on a variable x using a given value\n\n  Branches on variable x such that up to n/2 children are created on each side of the usual branching value.\n  The branching value is selected as in SCIPbranchVarVal().\n  The parameters minwidth and widthfactor determine the domain width of the branching variable in the child nodes.\n  If n is odd, one child with domain width 'width' and having the branching value in the middle is created.\n  Otherwise, two children with domain width 'width' and being left and right of the branching value are created.\n  Next further nodes to the left and right are created, where width is multiplied by widthfactor with increasing distance\n  from the first nodes.\n  The initial width is calculated such that n/2 nodes are created to the left and to the right of the branching value.\n  If this value is below minwidth, the initial width is set to minwidth, which may result in creating less than n nodes.\n\n  Giving a large value for widthfactor results in creating children with small domain when close to the branching value\n  and large domain when closer to the current variable bounds. That is, setting widthfactor to a very large value and n to 3\n  results in a ternary branching where the branching variable is mostly fixed in the middle child.\n  Setting widthfactor to 1.0 results in children where the branching variable always has the same domain width\n  (except for one child if the branching value is not in the middle).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarValNary(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        n: ::std::os::raw::c_int,
        minwidth: f64,
        widthfactor: f64,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls branching rules to branch on an LP solution; if no fractional variables exist, the result is SCIP_DIDNOTRUN;\n  if the branch priority of an unfixed variable is larger than the maximal branch priority of the fractional\n  variables, pseudo solution branching is applied on the unfixed variables with maximal branch priority\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchLP(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls branching rules to branch on a external candidates; if no such candidates exist, the result is SCIP_DIDNOTRUN\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchExtern(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls branching rules to branch on a pseudo solution; if no unfixed variables exist, the result is SCIP_DIDNOTRUN\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchPseudo(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a new SCIP_DATATREE"]
    pub fn SCIPcreateDatatree(
        scip: *mut SCIP,
        datatree: *mut *mut SCIP_DATATREE,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a new SCIP_DATATREE and inserts it into a SCIP_DATATREE object"]
    pub fn SCIPcreateDatatreeInTree(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        newtree: *mut *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a bool value into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeBool(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts an int value into a SCIP_DATATREE object\n\n  The value will be stored as SCIP_Longint."]
    pub fn SCIPinsertDatatreeInt(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a long value into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeLong(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a SCIP_Real value into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeReal(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a string value into a SCIP_DATATREE object\n\n  The string value will be copied."]
    pub fn SCIPinsertDatatreeString(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a SCIP_Bool array into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeBoolArray(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *const ::std::os::raw::c_uint,
        nvalues: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts an int array into a SCIP_DATATREE object\n\n  The value will be stored as array of SCIP_Longint."]
    pub fn SCIPinsertDatatreeIntArray(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *const ::std::os::raw::c_int,
        nvalues: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a SCIP_Longint array into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeLongArray(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *const ::std::os::raw::c_longlong,
        nvalues: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a SCIP_Real array into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeRealArray(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *const f64,
        nvalues: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a string array into a SCIP_DATATREE object"]
    pub fn SCIPinsertDatatreeStringArray(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        values: *const *const ::std::os::raw::c_char,
        nvalues: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts a data tree value into a SCIP_DATATREE object\n\n  The data tree assumes ownership of value."]
    pub fn SCIPinsertDatatreeTree(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        name: *const ::std::os::raw::c_char,
        value: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a SCIP_DATATREE object"]
    pub fn SCIPfreeDatatree(scip: *mut SCIP, datatree: *mut *mut SCIP_DATATREE);
}
unsafe extern "C" {
    #[doc = " writes a SCIP_DATATREE object as JSON to a file"]
    pub fn SCIPwriteDatatreeJson(
        scip: *mut SCIP,
        file: *mut FILE,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints a generic table from a data store"]
    pub fn SCIPprintDatatreeAsTable(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
        file: *mut FILE,
        sectionname: *const ::std::os::raw::c_char,
        tablename: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Certnodedata {
    _unused: [u8; 0],
}
pub type SCIP_CERTNODEDATA = SCIP_Certnodedata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_AggregationInfo {
    _unused: [u8; 0],
}
pub type SCIP_AGGREGATIONINFO = SCIP_AggregationInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MirInfo {
    _unused: [u8; 0],
}
pub type SCIP_MIRINFO = SCIP_MirInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Certificate {
    _unused: [u8; 0],
}
pub type SCIP_CERTIFICATE = SCIP_Certificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CertificateBound {
    _unused: [u8; 0],
}
pub type SCIP_CERTIFICATEBOUND = SCIP_CertificateBound;
unsafe extern "C" {
    #[doc = " returns whether certificate output is activated"]
    pub fn SCIPisCertified(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " should the certificate track bound changes?\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPshouldCertificateTrackBounds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " prints constraint to certificate\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcertifyCons(
        scip: *mut SCIP,
        isorigfile: ::std::os::raw::c_uint,
        consname: *const ::std::os::raw::c_char,
        sense: ::std::os::raw::c_char,
        side: *mut SCIP_RATIONAL,
        len: ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints activity bound to proof section\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcertifyActivityVarBound(
        scip: *mut SCIP,
        linename: *const ::std::os::raw::c_char,
        boundtype: SCIP_BOUNDTYPE,
        newbound: f64,
        ismaxactivity: ::std::os::raw::c_uint,
        constraint: *mut SCIP_CONS,
        variable: *mut SCIP_VAR,
        row: *mut SCIP_ROWEXACT,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints activity bound to proof section\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcertifyActivityVarBoundExact(
        scip: *mut SCIP,
        linename: *const ::std::os::raw::c_char,
        boundtype: SCIP_BOUNDTYPE,
        newbound: *mut SCIP_RATIONAL,
        ismaxactivity: ::std::os::raw::c_uint,
        constraint: *mut SCIP_CONS,
        variable: *mut SCIP_VAR,
        row: *mut SCIP_ROWEXACT,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints activity conflict to  certificate file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcertifyActivityConflict(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        row: *mut SCIP_ROWEXACT,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        nvals: ::std::os::raw::c_int,
        vals: *mut *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        diff: *mut SCIP_RATIONAL,
        userhs: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds aggregation information to certificate for one row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddCertificateAggrInfo(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        aggrrows: *mut *mut SCIP_ROW,
        weights: *mut f64,
        naggrrows: ::std::os::raw::c_int,
        negslackrows: *mut *mut SCIP_ROW,
        negslackweights: *mut f64,
        nnegslackrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores the active aggregation information in the certificate data structures for a row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstoreCertificateActiveAggrInfo(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the active aggregation information\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeCertificateActiveAggrInfo(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds mir information (split, etc) to certificate for one row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddCertificateMirInfo(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores the active mir information in the certificate data structures for a row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstoreCertificateActiveMirInfo(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print MIR cut to certificate file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcertifyMirCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the active mir information\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeCertificateActiveMirInfo(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = "@addtogroup PublicCompressionMethods\n\n @{\n/\n/** creates a tree compression and includes it in SCIP.\n\n  @note method has all compression callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeComprBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeCompr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a tree compression and includes it in SCIP with its most fundamental callbacks.\n  All non-fundamental (or optional) callbacks\n  as, e. g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetComprCopy(), SCIPsetComprFree(),\n  SCIPsetComprInit(), SCIPsetComprExit(), SCIPsetComprInitsol(), and SCIPsetComprExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeCompr() instead"]
    pub fn SCIPincludeComprBasic(
        scip: *mut SCIP,
        compr: *mut *mut SCIP_COMPR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of tree compression"]
    pub fn SCIPsetComprCopy(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of tree compression"]
    pub fn SCIPsetComprFree(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of tree compression"]
    pub fn SCIPsetComprInit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of tree compression"]
    pub fn SCIPsetComprExit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of tree compression"]
    pub fn SCIPsetComprInitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of tree compression"]
    pub fn SCIPsetComprExitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the tree compression of the given name, or NULL if not existing"]
    pub fn SCIPfindCompr(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_COMPR;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available tree compression"]
    pub fn SCIPgetComprs(scip: *mut SCIP) -> *mut *mut SCIP_COMPR;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available tree compression"]
    pub fn SCIPgetNCompr(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " set the priority of a tree compression method"]
    pub fn SCIPsetComprPriority(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a concurrent solver type and includes it in SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        prefpriodefault: f64,
        concsolvercreateinst: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                concsolvertype: *mut SCIP_CONCSOLVERTYPE,
                concsolver: *mut SCIP_CONCSOLVER,
            ) -> SCIP_RETCODE,
        >,
        concsolverdestroyinst: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolverinitseeds: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                seed: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        concsolverexec: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                solvingtime: *mut f64,
                nlpiterations: *mut ::std::os::raw::c_longlong,
                nnodes: *mut ::std::os::raw::c_longlong,
            ) -> SCIP_RETCODE,
        >,
        concsolvercopysolvdata: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER, scip: *mut SCIP) -> SCIP_RETCODE,
        >,
        concsolverstop: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolversyncwrite: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                maxcandsols: ::std::os::raw::c_int,
                maxsharedsols: ::std::os::raw::c_int,
                nsolsshared: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolversyncread: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                nsolsrecvd: *mut ::std::os::raw::c_int,
                ntighterbnds: *mut ::std::os::raw::c_int,
                ntighterintbnds: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolvertypefreedata: ::std::option::Option<
            unsafe extern "C" fn(data: *mut *mut SCIP_CONCSOLVERTYPEDATA),
        >,
        data: *mut SCIP_CONCSOLVERTYPEDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the concurrent solver type with the given name, or NULL if not existing"]
    pub fn SCIPfindConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONCSOLVERTYPE;
}
unsafe extern "C" {
    #[doc = " returns the array of included concurrent solver types"]
    pub fn SCIPgetConcsolverTypes(scip: *mut SCIP) -> *mut *mut SCIP_CONCSOLVERTYPE;
}
unsafe extern "C" {
    #[doc = " returns the number of included concurrent solver types"]
    pub fn SCIPgetNConcsolverTypes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Constructs the parallel interface to execute processes concurrently.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " releases the current synchronization store\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n       - \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Gets the synchronization store.\n\n  @return the \\ref SCIP_SYNCSTORE parallel interface pointer to submit jobs for concurrent processing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSyncstore(scip: *mut SCIP) -> *mut SCIP_SYNCSTORE;
}
unsafe extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP\n\n  @note method has all conflict handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeConflicthdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions SCIPsetConflicthdlrCopy(), SCIPsetConflicthdlrFree(),\n  SCIPsetConflicthdlrInit(), SCIPsetConflicthdlrExit(), SCIPsetConflicthdlrInitsol(),\n  and SCIPsetConflicthdlrExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConflicthdlr() instead"]
    pub fn SCIPincludeConflicthdlrBasic(
        scip: *mut SCIP,
        conflicthdlrptr: *mut *mut SCIP_CONFLICTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set copy method of conflict handler"]
    pub fn SCIPsetConflicthdlrCopy(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set destructor of conflict handler"]
    pub fn SCIPsetConflicthdlrFree(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set solving process initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set solving process deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the conflict handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONFLICTHDLR;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available conflict handlers"]
    pub fn SCIPgetConflicthdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONFLICTHDLR;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available conflict handlers"]
    pub fn SCIPgetNConflicthdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a conflict handler"]
    pub fn SCIPsetConflicthdlrPriority(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the\n  conflict analysis since it will not be applied\n\n  @return return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the\n          conflict analysis since it will not be applied\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictAnalysisApplicable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " initializes the conflict analysis by clearing the conflict candidate queue; this method must be called before you\n  enter the conflict variables by calling SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),\n  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar();\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPinitConflictAnalysis(
        scip: *mut SCIP,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictLb() should be called for each lower bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictLb() should be called\n      for each lower bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage\n  with the additional information of a relaxed lower bound; this relaxed lower bound is the one which would be enough\n  to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedLb() should be called for each (relaxed) lower bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelexedLb() should be called\n      for each (relaxed) lower bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedlb: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictUb() should be called for each upper bound that\n      led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictUb() should be called for\n      each upper bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage\n  with the additional information of a relaxed upper bound; this relaxed upper bound is the one which would be enough\n  to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedUb() should be called for each (relaxed) upper\n      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedUb() should be\n      called for each (relaxed) upper bound, whose current assignment led to the deduction of the given conflict\n      bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedub: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis' candidate\n  storage; this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBd() should be called for each bound\n      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBd() should be called\n      for each bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis'\n  candidate storage; with the additional information of a relaxed upper bound; this relaxed upper bound is the one\n  which would be enough to explain a certain bound change;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedBd() should be called for each (relaxed)\n      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedBd() should be\n      called for each (relaxed) bound, whose current assignment led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds changed bound of fixed binary variable to the conflict analysis' candidate storage;\n  this method should be called in one of the following two cases:\n   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBinvar() should be called for each fixed binary\n      variable that led to the conflict (e.g. the infeasibility of globally or locally valid constraint).\n   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBinvar() should be called\n      for each binary variable, whose current fixing led to the deduction of the given conflict bound.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBinvar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks if the given variable is already part of the current conflict set or queued for resolving with the same or\n  even stronger bound\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictVarUsed(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        used: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower\n  bound\n\n  @return returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower\n          bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarLb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global\n  upper bound\n\n  @return returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global\n          upper bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarUb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " analyzes conflict bounds that were added after a call to SCIPinitConflictAnalysis() with calls to\n  SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(),\n  SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar(); on success, calls the conflict\n  handlers to create a conflict constraint out of the resulting conflict set; the given valid depth must be a depth\n  level, at which the conflict set defined by calls to SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),\n  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar() is\n  valid for the whole subtree; if the conflict was found by a violated constraint, use SCIPanalyzeConflictCons()\n  instead of SCIPanalyzeConflict() to make sure, that the correct valid depth is used\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflict(
        scip: *mut SCIP,
        validdepth: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " analyzes conflict bounds that were added with calls to SCIPaddConflictLb(), SCIPaddConflictUb(),\n  SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or\n  SCIPaddConflictBinvar(); on success, calls the conflict handlers to create a conflict constraint out of the\n  resulting conflict set; the given constraint must be the constraint that detected the conflict, i.e. the constraint\n  that is infeasible in the local bounds of the initial conflict set (defined by calls to SCIPaddConflictLb(),\n  SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(),\n  SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar())\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflictCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all constraint handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeConshdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        sepapriority: ::std::os::raw::c_int,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        sepafreq: ::std::os::raw::c_int,
        propfreq: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        maxprerounds: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
        delayprop: ::std::os::raw::c_uint,
        needscons: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
        presoltiming: SCIP_PRESOLTIMING,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetsignedpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetConshdlrInit(), SCIPsetConshdlrExit(),\n  SCIPsetConshdlrCopy(), SCIPsetConshdlrFree(), SCIPsetConshdlrInitsol(), SCIPsetConshdlrExitsol(),\n  SCIPsetConshdlrInitpre(), SCIPsetConshdlrExitpre(), SCIPsetConshdlrPresol(), SCIPsetConshdlrDelete(),\n  SCIPsetConshdlrDelvars(), SCIPsetConshdlrInitlp(), SCIPsetConshdlrActive(), SCIPsetConshdlrDeactive(),\n  SCIPsetConshdlrEnable(), SCIPsetConshdlrDisable(), SCIPsetConshdlrResprop(), SCIPsetConshdlrTrans(),\n  SCIPsetConshdlrPrint(), SCIPsetConshdlrParse(), SCIPsetConshdlrGetVars(), SCIPsetConshdlrGetNVars(), and\n  SCIPsetConshdlrGetDiveBdChgs().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConshdlr() instead"]
    pub fn SCIPincludeConshdlrBasic(
        scip: *mut SCIP,
        conshdlrptr: *mut *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        needscons: ::std::os::raw::c_uint,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets all separation related callbacks/parameters of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrSepa(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrProp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets relaxation enforcement method of the constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnforelax(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of both the constraint handler and each associated constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrCopy(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrFree(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets preprocessing initialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets preprocessing deinitialization method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPresol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        maxprerounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets method of constraint handler to free specific constraint data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelete(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets method of constraint handler to transform constraint data into data belonging to the transformed problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrTrans(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets method of constraint handler to initialize LP with relaxations of \"initial\" constraints\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitlp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets propagation conflict resolving method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrResprop(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets activation notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrActive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deactivation notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDeactive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets enabling notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets disabling notification method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDisable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets variable deletion method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelvars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets constraint display method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPrint(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets constraint parsing method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrParse(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets constraint variable getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets constraint variable number getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetNVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets diving enforcement method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetDiveBdChgs(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets permutation symmetry detection graph getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConshdlrGetPermsymGraph(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets signed permutation symmetry detection graph getter method of constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConshdlrGetSignedPermsymGraph(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetsignedpermsymgraph: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                graph: *mut SYM_GRAPH,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the constraint handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONSHDLR;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available constraint handlers"]
    pub fn SCIPgetConshdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONSHDLR;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available constraint handlers"]
    pub fn SCIPgetNConshdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates and captures a constraint of the given constraint handler\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        conshdlr: *mut SCIP_CONSHDLR,
        consdata: *mut SCIP_CONSDATA,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parses constraint information (in cip format) out of a string; if the parsing process was successful a constraint is\n  creates and captures;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds."]
    pub fn SCIPparseCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcaptureCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of constraint, if the usage pointer reaches zero the constraint gets freed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the pointer of the constraint will be NULLed"]
    pub fn SCIPreleaseCons(scip: *mut SCIP, cons: *mut *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change constraint name\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note to get the current name of a constraint, use SCIPconsGetName() from pub_cons.h"]
    pub fn SCIPchgConsName(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the initial flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsInitial(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the separate flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsSeparated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        separate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the enforce flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsEnforced(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        enforce: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the check flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsChecked(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        check: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the propagate flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsPropagated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        propagate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the local flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the modifiable flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPsetConsModifiable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        modifiable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the dynamic flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsDynamic(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the removable flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsRemovable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the stickingatnode flag of the given constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsStickingAtNode(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates the flags of the first constraint according to the ones of the second constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateConsFlags(
        scip: *mut SCIP,
        cons0: *mut SCIP_CONS,
        cons1: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets and captures transformed constraint of a given constraint; if the constraint is not yet transformed,\n  a new transformed constraint for this constraint is created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets and captures transformed constraints for an array of constraints;\n  if a constraint in the array is not yet transformed, a new transformed constraint for this constraint is created;\n  it is possible to call this method with conss == transconss\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets corresponding transformed constraint of a given constraint;\n  returns NULL as transcons, if transformed constraint is not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets corresponding transformed constraints for an array of constraints;\n  stores NULL in a transconss slot, if the transformed constraint is not yet existing;\n  it is possible to call this method with conss == transconss, but remember that constraints that are not\n  yet transformed will be replaced with NULL\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds given value to age of constraint, but age can never become negative;\n  should be called\n   - in constraint separation, if no cut was found for this constraint,\n   - in constraint enforcing, if constraint was feasible, and\n   - in constraint propagation, if no domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS, deltaage: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases age of constraint by 1.0;\n  should be called\n   - in constraint separation, if no cut was found for this constraint,\n   - in constraint enforcing, if constraint was feasible, and\n   - in constraint propagation, if no domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets age of constraint to zero;\n  should be called\n   - in constraint separation, if a cut was found for this constraint,\n   - in constraint enforcing, if the constraint was violated, and\n   - in constraint propagation, if a domain reduction was deduced;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables constraint's separation, propagation, and enforcing capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " disables constraint's separation, propagation, and enforcing capabilities, s.t. the constraint is not propagated,\n  separated, and enforced anymore until it is enabled again with a call to SCIPenableCons();\n  in contrast to SCIPdelConsLocal() and SCIPdelConsNode(), the disabling is not associated to a node in the tree and\n  does not consume memory; therefore, the constraint is neither automatically enabled on leaving the node nor\n  automatically disabled again on entering the node again;\n  note that the constraints enforcing capabilities are necessary for the solution's feasibility, if the constraint\n  is a model constraint; that means, you must be sure that the constraint cannot be violated in the current subtree,\n  and you have to enable it again manually by calling SCIPenableCons(), if this subtree is left (e.g. by using\n  an appropriate event handler that watches the corresponding variables' domain changes)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables constraint's separation capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " disables constraint's separation capabilities s.t. the constraint is not propagated anymore until the separation\n  is enabled again with a call to SCIPenableConsSeparation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),\n  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint\n  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables constraint's propagation capabilities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " disables constraint's propagation capabilities s.t. the constraint is not propagated anymore until the propagation\n  is enabled again with a call to SCIPenableConsPropagation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),\n  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint\n  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks constraint to be propagated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @note if a constraint is marked to be propagated, the age of the constraint will be ignored for propagation"]
    pub fn SCIPmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " unmarks the constraint to be propagated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPunmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds given values to lock status of type @p locktype of the constraint and updates the rounding locks of the involved variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddConsLocksType(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds given values to lock status of the constraint and updates the rounding locks of the involved variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note This methods always adds locks of type model"]
    pub fn SCIPaddConsLocks(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks single constraint for feasibility of the given solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enforces single constraint for a given pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenfopsCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        objinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enforces single constraint for a given LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenfolpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enforces single constraint for a given relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPenforelaxCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls LP initialization method for single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPinitlpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls separation method of single constraint for LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepalpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls separation method of single constraint for given primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepasolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls domain propagation method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        proptiming: SCIP_PROPTIMING,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolves propagation conflict of single constraint\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPrespropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infervar: *mut SCIP_VAR,
        inferinfo: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " presolves of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n\n  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpresolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        nnewfixedvars: ::std::os::raw::c_int,
        nnewaggrvars: ::std::os::raw::c_int,
        nnewchgvartypes: ::std::os::raw::c_int,
        nnewchgbds: ::std::os::raw::c_int,
        nnewholes: ::std::os::raw::c_int,
        nnewdelconss: ::std::os::raw::c_int,
        nnewaddconss: ::std::os::raw::c_int,
        nnewupgdconss: ::std::os::raw::c_int,
        nnewchgcoefs: ::std::os::raw::c_int,
        nnewchgsides: ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
        naggrvars: *mut ::std::os::raw::c_int,
        nchgvartypes: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        naddholes: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        naddconss: *mut ::std::os::raw::c_int,
        nupgdconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls constraint activation notification method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n\n  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not\n      added to SCIP beforehand."]
    pub fn SCIPactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls constraint deactivation notification method of single constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This is an advanced method and should be used with caution. It may only be called for constraints that were not\n        added to SCIP beforehand."]
    pub fn SCIPdeactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs constraint information to file stream via the message handler system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note If the message handler is set to a NULL pointer nothing will be printed.\n  @note The file stream will not be flushed directly, this can be achieved by calling SCIPinfoMessage() printing a\n        newline character."]
    pub fn SCIPprintCons(scip: *mut SCIP, cons: *mut SCIP_CONS, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " method to collect the variables of a constraint\n\n  If the number of variables is greater than the available slots in the variable array, nothing happens except that\n  the success point is set to FALSE. With the method SCIPgetConsNVars() it is possible to get the number of variables\n  a constraint has in its scope.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The success pointer indicates if all variables were copied into the vars arrray.\n\n  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is\n        set to FALSE."]
    pub fn SCIPgetConsVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vars: *mut *mut SCIP_VAR,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " method to collect the number of variables of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The success pointer indicates if the contraint handler was able to return the number of variables\n\n  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is\n        set to FALSE"]
    pub fn SCIPgetConsNVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nvars: *mut ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " method to get the permutation symmetry detection graph of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetConsPermsymGraph(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        graph: *mut SYM_GRAPH,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " method to get the signed permutation symmetry detection graph of a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetConsSignedPermsymGraph(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        graph: *mut SYM_GRAPH,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies plugins from sourcescip to targetscip; in case that a constraint handler which does not need constraints\n  cannot be copied, valid will return FALSE. All plugins can declare that, if their copy process failed, the\n  copied SCIP instance might not represent the same problem semantics as the original.\n  Note that in this case dual reductions might be invalid.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n\n  @note Do not change the source SCIP environment during the copying process.\n\n  @note This method does not copy Benders' plugins. To this end, the method SCIPcopyBenders() must be called\n        separately.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyPlugins(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        copyreaders: ::std::os::raw::c_uint,
        copypricers: ::std::os::raw::c_uint,
        copyconshdlrs: ::std::os::raw::c_uint,
        copyconflicthdlrs: ::std::os::raw::c_uint,
        copypresolvers: ::std::os::raw::c_uint,
        copyrelaxators: ::std::os::raw::c_uint,
        copyseparators: ::std::os::raw::c_uint,
        copycutselectors: ::std::os::raw::c_uint,
        copypropagators: ::std::os::raw::c_uint,
        copyheuristics: ::std::os::raw::c_uint,
        copyeventhdlrs: ::std::os::raw::c_uint,
        copynodeselectors: ::std::os::raw::c_uint,
        copybranchrules: ::std::os::raw::c_uint,
        copyiisfinders: ::std::os::raw::c_uint,
        copydisplays: ::std::os::raw::c_uint,
        copydialogs: ::std::os::raw::c_uint,
        copytables: ::std::os::raw::c_uint,
        copyexprhdlrs: ::std::os::raw::c_uint,
        copynlpis: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies all Benders' decomposition plugins\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note the 'threadsafe' parameter must be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyBenders(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        threadsafe: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " create a problem by copying the problem data of the source SCIP\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " create a problem by copying the original problem data of the source SCIP\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables constraint compression.\n\n  If constraint compression is enabled, fixed variables will be treated as constants\n  by all constraints that are copied after calling this method.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableConsCompression(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " is constraint compression enabled?\n\n  If constraint compression is enabled, fixed variables can be treated as constants\n  by all constraints that are copied after calling this method.\n\n  @return TRUE if problem constraint compression is enabled, otherwise FALSE\n\n  @pre This method can be called if scip is in one of the following stages:\n      - \\ref SCIP_STAGE_PROBLEM\n      - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisConsCompressionEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns copy of the source variable; if there already is a copy of the source variable in the variable hash map,\n  it is just returned as target variable; otherwise, if the variables it not marked as relaxation-only, a new variable\n  will be created and added to the target SCIP; this created variable is added to the variable hash map and returned as target variable;\n  relaxation-only variables are not copied and FALSE is returned in *success\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n  @note if a new variable was created, this variable will be added to the target-SCIP, but it is not captured\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note targetscip stage does not get changed\n\n  @note sourcescip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevar: *mut SCIP_VAR,
        targetvar: *mut *mut SCIP_VAR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Copies all active (thus unfixed) variables from source-SCIP, except those that are marked as relaxation only,\n  and adds these variable to the target-SCIP.\n\n  The mapping between these variables are stored in the variable hashmap.\n\n  The target-SCIP has to be in problem creation stage.\n\n  @note the variables are added to the target-SCIP but not captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies all original variables from source-SCIP and adds these variable to the target-SCIP; the mapping between these\n  variables are stored in the variable hashmap, target-SCIP has to be in problem creation stage, fixed and aggregated\n  variables do not get copied\n\n  @note the variables are added to the target-SCIP but not captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " merges the histories of variables from a source SCIP into a target SCIP. The two data structures should point to\n  different SCIP instances.\n\n  @note the notion of source and target is inverted here; \\p sourcescip usually denotes a copied SCIP instance, whereas\n        \\p targetscip denotes the original instance"]
    pub fn SCIPmergeVariableStatistics(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevars: *mut *mut SCIP_VAR,
        targetvars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " merges the statistics of NLPIs from a source SCIP into a target SCIP\n\n The two SCIP instances should point to different SCIP instances.\n\n  @note the notion of source and target is inverted here; \\p sourcescip usually denotes a copied SCIP instance, whereas\n        \\p targetscip denotes the original instance"]
    pub fn SCIPmergeNLPIStatistics(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        reset: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " translates a solution from a subscip to the main scip\n\n Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables\n are represented as NULL entry in the subvars array.\n\n @note This method allocates a new solution of the main scip that needs to be freed by the user."]
    pub fn SCIPtranslateSubSol(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        subsol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        newsol: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks the solutions from the subscip and adds the first one that is found feasible to the master SCIP\n\n Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables\n are represented as NULL entry in the subvars array."]
    pub fn SCIPtranslateSubSols(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        success: *mut ::std::os::raw::c_uint,
        solindex: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns copy of the source constraint; if there already is a copy of the source constraint in the constraint hash\n  map, it is just returned as target constraint; elsewise a new constraint will be created; this created constraint is\n  added to the constraint hash map and returned as target constraint; the variable map is used to map the variables of\n  the source SCIP to the variables of the target SCIP\n\n  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may\n           be declared feasible even if it violates this particular constraint.  This constellation should only be\n           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due\n           to the variable's local bounds.\n\n  @note The constraint is not added to the target SCIP. You can check whether a constraint is added by calling\n        SCIPconsIsAdded(). (If you mix SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add\n        explicitly and what is already added.)\n\n  @note The constraint is always captured, either during the creation of the copy or after finding the copy of the\n        constraint in the constraint hash map\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetConsCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcecons: *mut SCIP_CONS,
        targetcons: *mut *mut SCIP_CONS,
        sourceconshdlr: *mut SCIP_CONSHDLR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies constraints from the source-SCIP and adds these to the target-SCIP; for mapping the\n  variables between the source and the target SCIP a hash map can be given; if the variable hash\n  map is NULL or necessary variable mapping is missing, the required variables are created in the\n  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to\n  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping\n  between the constraints of the source and target-SCIP is stored\n\n  *valid is set to TRUE iff all constraints that are marked as checked or enforced were copied successfully.\n  If other constraints could not be copied, *valid can still be set to TRUE.\n\n  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix\n        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already\n        added.) You can check whether a constraint is added by calling SCIPconsIsAdded().\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies all original constraints from the source-SCIP and adds these to the target-SCIP; for mapping the\n  variables between the source and the target SCIP a hash map can be given; if the variable hash\n  map is NULL or necessary variable mapping is missing, the required variables are created in the\n  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to\n  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping\n  between the constraints of the source and target-SCIP is stored\n\n  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix\n        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already\n        added.) You can check whether a constraint is added by calling SCIPconsIsAdded().\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " convert all active cuts from cutpool to linear constraints\n\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconvertCutsToConss(
        scip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies all active cuts from cutpool of sourcescip to linear constraints in targetscip\n\n  Cuts that contain variables that are marked as relaxation-only are skipped.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyCuts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies all active conflicts from the conflict pool of sourcescip and adds them as linear constraints to targetscip\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note sourcescip stage does not change\n\n  @note targetscip stage does not change\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConflicts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies implications and cliques of sourcescip to targetscip\n\n  This function should be called for a targetscip in transformed stage. It can save time in presolving of the\n  targetscip, since implications and cliques are copied.\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyImplicationsCliques(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
        ncopied: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies parameter settings from sourcescip to targetscip\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n  @note Do not change the source SCIP environment during the copying process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyParamSettings(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets depth of current scip instance (increased by each copy call)\n\n  @return Depth of subscip of SCIP is returned.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSubscipDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets depth of scip instance\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note SCIP stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsetSubscipDepth(scip: *mut SCIP, newdepth: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " copies source SCIP to target SCIP; the copying process is done in the following order:\n  1) copy those plugins that have copy callbacks\n  2) copy the settings for the present parameters\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all active variables except those that are marked as relaxation-only\n  5) copy all constraints\n\n  The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,\n  otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrig().\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @note Reoptimization and exact solving are explicitly disabled in the target-SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies source SCIP to target SCIP but compresses constraints\n\n  constraint compression is performed by removing fixed variables immediately\n  during constraint creation if the involved constraint handlers support\n  compression\n\n  the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all active variables except those are marked as relaxation-only\n     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars\n     b) enable constraint compression\n  5) copy all constraints\n\n The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,\n otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrigConsCompression().\n\n  @note: in case that a combination of local bounds and explicit fixing values should be used,\n         the fixing value of a variable is preferred if local bounds and fixing value disagree.\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @note Reoptimization and exact solving are explicitly disabled in the target-SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP; the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the original problem data of the source-SCIP\n  4) copy all original variables\n  5) copy all original constraints\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @note Reoptimization and exact solving are explicitly disabled in the target-SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrig(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP but compresses constraints\n\n  constraint compression is performed by removing fixed variables immediately\n  during constraint creation if the involved constraint handlers support\n  compression\n\n  the copying process is done in the following order:\n  1) copy the plugins\n  2) copy the settings\n  3) create problem data in target-SCIP and copy the problem data of the source-SCIP\n  4) copy all original variables\n     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars\n     b) enable constraint compression\n  5) copy all constraints\n\n  @note all variables and constraints which are created in the target-SCIP are not (user) captured\n\n  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex.\n        Also, 'passmessagehdlr' should be set to FALSE.\n  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target\n        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety\n        typically incurs a performance cost.\n  @note Do not change the source SCIP environment during the copying process\n\n  @note Reoptimization and exact solving are explicitly disabled in the target-SCIP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @pre This method can be called if targetscip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @note sourcescip stage does not get changed\n\n  @note targetscip stage does not get changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks if there is enough time and memory left for copying the sourcescip into a sub-SCIP and solve the sub-SCIP\n\n  This is the case if the time and memory limit that would be passed to the sub-SCIP are larger than 0.0\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcheckCopyLimits(
        sourcescip: *mut SCIP,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies limits from source SCIP to target SCIP\n\n  @note time and memory limit are reduced by the amount already spent in the source SCIP before installing the limit\n        in the target SCIP\n  @note all other limits are disabled and need to be enabled afterwards, if needed\n\n  @see SCIPsetCommonSubscipParams() to set further working limits and other parameters commonly used for auxiliary problems\n\n  @pre This method can be called if sourcescip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyLimits(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the working limits as well as common search parameters for the auxiliary problem\n\n  @note memory and time limits are not affected, and must be set using SCIPcopyLimits() instead"]
    pub fn SCIPsetCommonSubscipParams(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        nsubnodes: ::std::os::raw::c_longlong,
        nstallnodes: ::std::os::raw::c_longlong,
        bestsollimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns row's cutoff distance in the direction of the given primal solution\n\n  @return the cutoff distance of the cut with respect to the LP solution in the direction of the given primal solution\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutLPSolCutoffDistance(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns efficacy of the cut with respect to the given primal solution or the current LP solution:\n  e = -feasibility/norm\n\n  @return the efficacy of the cut with respect to the given primal solution or the current LP solution:\n          e = -feasibility/norm\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutEfficacy(scip: *mut SCIP, sol: *mut SCIP_SOL, cut: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the cut's efficacy with respect to the given primal solution or the current LP solution is greater\n  than the minimal cut efficacy\n\n  @return TRUE if the cut's efficacy with respect to the given primal solution or the current LP solution is greater\n          than the minimal cut efficacy, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutEfficacious(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if the given cut's efficacy is larger than the minimal cut efficacy\n\n  @return TRUE if the given cut's efficacy is larger than the minimal cut efficacy, otherwise FALSE"]
    pub fn SCIPisEfficacious(scip: *mut SCIP, efficacy: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " calculates the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter\n\n  @return the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPgetVectorEfficacyNorm(
        scip: *mut SCIP,
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " indicates whether a cut is applicable\n\n  If the cut has only one variable and this method returns FALSE, it may\n  still be possible that the cut can be added to the LP (as a row instead\n  of a boundchange), but it will be a very weak cut. The user is asked\n  to avoid such cuts.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return whether the cut is modifiable, not a bound change, or a bound change that changes bounds by at least epsilon"]
    pub fn SCIPisCutApplicable(scip: *mut SCIP, cut: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " adds row to separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        forcecut: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks if cut is already existing in global cutpool\n\n  @return TRUE is returned if the cut is not already existing in the global cutpool, FALSE otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutNew(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " if not already existing, adds row to global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes the row from the global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current cuts in the global cut pool\n\n  @return the current cuts in the global cut pool\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
unsafe extern "C" {
    #[doc = " gets current number of rows in the global cut pool\n\n  @return the current number of rows in the global cut pool\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the global cut pool used by SCIP\n\n  @return the global cut pool used by SCIP\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
unsafe extern "C" {
    #[doc = " creates a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCutpool(
        scip: *mut SCIP,
        cutpool: *mut *mut SCIP_CUTPOOL,
        agelimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeCutpool(scip: *mut SCIP, cutpool: *mut *mut SCIP_CUTPOOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if not already existing, adds row to a cut pool and captures it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds row to a cut pool and captures it; doesn't check for multiple cuts\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNewRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes the LP row from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdelRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " separates cuts from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " separates cuts w.r.t. given solution from a cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSolCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        sol: *mut SCIP_SOL,
        pretendroot: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if not already existing, adds row to the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes the row from the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current cuts in the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
unsafe extern "C" {
    #[doc = " gets current number of rows in the delayed global cut pool\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNDelayedPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the delayed global cut pool used by SCIP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
unsafe extern "C" {
    #[doc = " separates the given primal solution or the current LP solution by calling the separators and constraint handlers'\n  separation methods;\n  the generated cuts are stored in the separation storage and can be accessed with the methods SCIPgetCuts() and\n  SCIPgetNCuts();\n  after evaluating the cuts, you have to call SCIPclearCuts() in order to remove the cuts from the\n  separation storage;\n  it is possible to call SCIPseparateSol() multiple times with different solutions and evaluate the found cuts\n  afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        pretendroot: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        onlydelayed: ::std::os::raw::c_uint,
        delayed: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the array of cuts currently stored in the separation storage\n\n  @return the array of cuts currently stored in the separation storage\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetCuts(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " get current number of cuts in the separation storage\n\n  @return the current number of cuts in the separation storage\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " clears the separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes cuts that are inefficacious w.r.t. the current LP solution from separation storage without adding the cuts to the LP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPremoveInefficaciousCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a dynamic array of real values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateRealarray(
        scip: *mut SCIP,
        realarray: *mut *mut SCIP_REALARRAY,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a dynamic array of real values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeRealarray(scip: *mut SCIP, realarray: *mut *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendRealarray(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears a dynamic real array\n\n  @return clears a dynamic real array"]
    pub fn SCIPclearRealarray(scip: *mut SCIP, realarray: *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        incval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMinIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMaxIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a dynamic array of int values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a dynamic array of int values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendIntarray(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears a dynamic int array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearIntarray(scip: *mut SCIP, intarray: *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets value of entry in dynamic array\n\n  @return value of entry in dynamic array"]
    pub fn SCIPgetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        incval: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMinIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMaxIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a dynamic array of bool values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateBoolarray(
        scip: *mut SCIP,
        boolarray: *mut *mut SCIP_BOOLARRAY,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a dynamic array of bool values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeBoolarray(scip: *mut SCIP, boolarray: *mut *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendBoolarray(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears a dynamic bool array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearBoolarray(scip: *mut SCIP, boolarray: *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets value of entry in dynamic array\n\n  @return value of entry in dynamic array at position idx"]
    pub fn SCIPgetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMinIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMaxIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a dynamic array of pointers\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreatePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a dynamic array of pointers\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendPtrarray(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears a dynamic pointer array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearPtrarray(scip: *mut SCIP, ptrarray: *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " sets value of entry in dynamic array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements\n\n  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMinIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements\n\n  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMaxIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a disjoint set (union find) structure \\p djset for \\p ncomponents many components (of size one)"]
    pub fn SCIPcreateDisjointset(
        scip: *mut SCIP,
        djset: *mut *mut SCIP_DISJOINTSET,
        ncomponents: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the disjoint set (union find) data structure"]
    pub fn SCIPfreeDisjointset(scip: *mut SCIP, djset: *mut *mut SCIP_DISJOINTSET);
}
unsafe extern "C" {
    #[doc = " creates directed graph structure"]
    pub fn SCIPcreateDigraph(
        scip: *mut SCIP,
        digraph: *mut *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies directed graph structure\n\n  The copying procedure uses the memory of the passed SCIP instance. The user must ensure that the digraph lives\n  as most as long as the SCIP instance.\n\n  @note The data in nodedata is copied verbatim. This possibly has to be adapted by the user."]
    pub fn SCIPcopyDigraph(
        scip: *mut SCIP,
        targetdigraph: *mut *mut SCIP_DIGRAPH,
        sourcedigraph: *mut SCIP_DIGRAPH,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enable debug solution mechanism\n\n  the debug solution mechanism allows to trace back the invalidation of\n  a debug solution during the solution process of SCIP. It must be explicitly\n  enabled for the SCIP data structure.\n\n  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPenableDebugSol(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " disable solution debugging mechanism\n\n  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPdisableDebugSol(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPcreateDecomp(
        scip: *mut SCIP,
        decomp: *mut *mut SCIP_DECOMP,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPfreeDecomp(scip: *mut SCIP, decomp: *mut *mut SCIP_DECOMP);
}
unsafe extern "C" {
    #[doc = " adds decomposition to SCIP"]
    pub fn SCIPaddDecomp(scip: *mut SCIP, decomp: *mut SCIP_DECOMP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets available user decompositions for either the original or transformed problem"]
    pub fn SCIPgetDecomps(
        scip: *mut SCIP,
        decomps: *mut *mut *mut SCIP_DECOMP,
        ndecomps: *mut ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns TRUE if the constraint \\p cons contains only linking variables in decomposition \\p decomp"]
    pub fn SCIPhasConsOnlyLinkVars(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        cons: *mut SCIP_CONS,
        hasonlylinkvars: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes constraint labels from variable labels\n\n  Existing labels for the constraints are simply overridden\n\n  The computed labels depend on the flag SCIPdecompUseBendersLabels() of the decomposition. If the flag is set\n  to FALSE, the labeling assigns\n\n  - label i, if only variables labeled i are present in the constraint (and optionally linking variables)\n  - SCIP_DECOMP_LINKCONS, if there are either only variables labeled with SCIP_DECOMP_LINKVAR present, or\n    if there are variables with more than one block label.\n\n  If the flag is set to TRUE, the assignment is the same, unless variables from 2 named blocks occur in the same\n  constraint, which is an invalid labeling for the Benders case."]
    pub fn SCIPcomputeDecompConsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a decomposition of the variables from a labeling of the constraints\n\n  NOTE: by default, the variable labeling is based on a Dantzig-Wolfe decomposition. This means that constraints in named\n  blocks have have precedence over linking constraints. If a variable exists in constraints from\n  two or more named blocks, then this variable is marked as a linking variable.\n  If a variable occurs in exactly one named block i>=0, it is assigned label i.\n  Variables which are only in linking constraints are unlabeled. However, SCIPdecompGetVarsLabels() will\n  label them as linking variables.\n\n  If the variables should be labeled for the application of Benders' decomposition, the decomposition must be\n  flagged explicitly via SCIPdecompSetUseBendersLabels().\n  With this setting, the presence in linking constraints takes precedence over the presence in named blocks.\n  Now, a variable is considered linking if it is present in at least one linking constraint and an arbitrary\n  number of constraints from named blocks."]
    pub fn SCIPcomputeDecompVarsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " assigns linking constraints to blocks\n\n Each linking constraint is assigned to the most frequent block among its variables.\n Variables of other blocks are relabeled as linking variables.\n Constraints that have only linking variables are skipped.\n\n @note: In contrast to SCIPcomputeDecompConsLabels(), this method potentially relabels variables."]
    pub fn SCIPassignDecompLinkConss(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        nskipconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes decomposition statistics and store them in the decomposition object"]
    pub fn SCIPcomputeDecompStats(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        uselimits: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and includes dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincludeDialog(
        scip: *mut SCIP,
        dialog: *mut *mut SCIP_DIALOG,
        dialogcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                dialog: *mut SCIP_DIALOG,
                dialoghdlr: *mut SCIP_DIALOGHDLR,
                nextdialog: *mut *mut SCIP_DIALOG,
            ) -> SCIP_RETCODE,
        >,
        dialogdesc: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        issubmenu: ::std::os::raw::c_uint,
        dialogdata: *mut SCIP_DIALOGDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns if the dialog already exists\n\n  @return TRUE is returned if the dialog exists, otherwise FALSE."]
    pub fn SCIPexistsDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " captures a dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcaptureDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " releases a dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreleaseDialog(scip: *mut SCIP, dialog: *mut *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " makes given dialog the root dialog of SCIP's interactive user shell; captures dialog and releases former root dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRootDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the root dialog of SCIP's interactive user shell\n\n  @return the root dialog of SCIP's interactive user shell is returned."]
    pub fn SCIPgetRootDialog(scip: *mut SCIP) -> *mut SCIP_DIALOG;
}
unsafe extern "C" {
    #[doc = " adds a sub dialog to the given dialog as menu entry and captures it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogEntry(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        subdialog: *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a single line of input which is treated as if the user entered the command line\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogInputLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a single line of input to the command history which can be accessed with the cursor keys\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogHistoryLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " starts interactive mode of SCIP by executing the root dialog\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the\n        interactive shell was closed:\n        - \\ref SCIP_STAGE_PROBLEM if the interactive shell was closed after the problem was created\n        - \\ref SCIP_STAGE_TRANSFORMED if the interactive shell was closed after the problem was transformed\n        - \\ref SCIP_STAGE_PRESOLVING if the interactive shell was closed  during presolving\n        - \\ref SCIP_STAGE_PRESOLVED if the interactive shell was closed after presolve\n        - \\ref SCIP_STAGE_SOLVING if the interactive shell was closed during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the interactive shell was closed after the problem was solved\n        - \\ref SCIP_STAGE_FREE if the interactive shell was closed after the problem was freed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartInteraction(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a display column and includes it in SCIP"]
    pub fn SCIPincludeDisp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        header: *const ::std::os::raw::c_char,
        dispstatus: SCIP_DISPSTATUS,
        dispcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                disp: *mut SCIP_DISP,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        dispdata: *mut SCIP_DISPDATA,
        width: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        position: ::std::os::raw::c_int,
        stripline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the display column of the given name, or NULL if not existing"]
    pub fn SCIPfindDisp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_DISP;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available display columns"]
    pub fn SCIPgetDisps(scip: *mut SCIP) -> *mut *mut SCIP_DISP;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available display columns"]
    pub fn SCIPgetNDisps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " automatically selects display columns for being shown w.r.t. the display width parameter"]
    pub fn SCIPautoselectDisps(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the display column mode"]
    pub fn SCIPchgDispMode(disp: *mut SCIP_DISP, mode: SCIP_DISPMODE);
}
unsafe extern "C" {
    #[doc = " creates an event handler and includes it in SCIP\n\n  @note method has all event handler callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeEventhdlrBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an event handler and includes it in SCIP with all its non-fundamental callbacks set\n  to NULL; if needed, non-fundamental callbacks can be set afterwards via setter functions\n  SCIPsetEventhdlrCopy(), SCIPsetEventhdlrFree(), SCIPsetEventhdlrInit(), SCIPsetEventhdlrExit(),\n  SCIPsetEventhdlrInitsol(), SCIPsetEventhdlrExitsol(), and SCIPsetEventhdlrDelete()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeEventhdlr() instead"]
    pub fn SCIPincludeEventhdlrBasic(
        scip: *mut SCIP,
        eventhdlrptr: *mut *mut SCIP_EVENTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy callback of the event handler"]
    pub fn SCIPsetEventhdlrCopy(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrFree(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets callback of the event handler to free specific event data"]
    pub fn SCIPsetEventhdlrDelete(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the event handler of the given name, or NULL if not existing"]
    pub fn SCIPfindEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EVENTHDLR;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available event handlers"]
    pub fn SCIPgetEventhdlrs(scip: *mut SCIP) -> *mut *mut SCIP_EVENTHDLR;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available event handlers"]
    pub fn SCIPgetNEventhdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " catches a global (not variable or row dependent) event\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " drops a global event (stops to track event)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " catches an objective value or domain change event on the given transformed variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " drops an objective value or domain change event (stops to track event) on the given transformed variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " catches a row coefficient, constant, or side change event on the given row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " drops a row coefficient, constant, or side change event (stops to track event) on the given row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables or disables exact solving mode\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT"]
    pub fn SCIPenableExactSolving(scip: *mut SCIP, enable: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the solution process is arithmetically exact, i.e., not subject to roundoff errors\n\n  @return Returns TRUE if \\SCIP is in exact solving mode, otherwise FALSE"]
    pub fn SCIPisExact(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether aggregation is allowed to use negative slack in exact solving mode\n\n  @return Returns TRUE if \\SCIP is not in exact solving mode or aggregation is allowed to use negative slack\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPallowNegSlack(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " branches on an LP solution exactly; does not call branching rules, since fractionalities are assumed to small;\n  if no fractional variables exist, the result is SCIP_DIDNOTRUN;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchLPExact(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds row to exact separation storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRowExact(scip: *mut SCIP, rowexact: *mut SCIP_ROWEXACT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for an expression handler and includes it into SCIP"]
    pub fn SCIPincludeExprhdlr(
        scip: *mut SCIP,
        exprhdlr: *mut *mut SCIP_EXPRHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        precedence: ::std::os::raw::c_uint,
        eval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                val: *mut f64,
                sol: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        data: *mut SCIP_EXPRHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives expression handlers"]
    pub fn SCIPgetExprhdlrs(scip: *mut SCIP) -> *mut *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " gives number of expression handlers"]
    pub fn SCIPgetNExprhdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns an expression handler of a given name (or NULL if not found)"]
    pub fn SCIPfindExprhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " returns expression handler for variable expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrVar(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " returns expression handler for constant value expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrValue(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " returns expression handler for sum expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrSum(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " returns expression handler for product expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrProduct(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " returns expression handler for power expressions (or NULL if not included)"]
    pub fn SCIPgetExprhdlrPower(scip: *mut SCIP) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " creates and captures an expression with given expression data and children"]
    pub fn SCIPcreateExpr(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprhdlr: *mut SCIP_EXPRHDLR,
        exprdata: *mut SCIP_EXPRDATA,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an expression with given expression data and up to two children"]
    pub fn SCIPcreateExpr2(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprhdlr: *mut SCIP_EXPRHDLR,
        exprdata: *mut SCIP_EXPRDATA,
        child1: *mut SCIP_EXPR,
        child2: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an expression representing a quadratic function"]
    pub fn SCIPcreateExprQuadratic(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an expression representing a monomial\n\n @note In deviation from the actual definition of monomials, we also allow for negative and rational exponents.\n So this function actually creates an expression for a signomial that has exactly one term."]
    pub fn SCIPcreateExprMonomial(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nfactors: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        exponents: *mut f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " appends child to the children list of expr\n\n @attention Only use if you really know what you are doing. The expression handler of the expression needs to be able to handle an increase in the number of children."]
    pub fn SCIPappendExprChild(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " overwrites/replaces a child of an expressions\n\n The old child is released and the newchild is captured, unless they are the same (=same pointer)."]
    pub fn SCIPreplaceExprChild(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childidx: ::std::os::raw::c_int,
        newchild: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " remove all children of expr\n\n @attention Only use if you really know what you are doing. The expression handler of the expression needs to be able to handle the removal of all children."]
    pub fn SCIPremoveExprChildren(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " duplicates the given expression and its children"]
    pub fn SCIPduplicateExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        mapexpr: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetexpr: *mut *mut SCIP_EXPR,
                sourcescip: *mut SCIP,
                sourceexpr: *mut SCIP_EXPR,
                ownercreate: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                        ownerfree: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerprint: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                file: *mut FILE,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownerevalactivity: *mut ::std::option::Option<
                            unsafe extern "C" fn(
                                scip: *mut SCIP,
                                expr: *mut SCIP_EXPR,
                                ownerdata: *mut SCIP_EXPR_OWNERDATA,
                            ) -> SCIP_RETCODE,
                        >,
                        ownercreatedata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
                mapexprdata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        mapexprdata: *mut ::std::os::raw::c_void,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " duplicates the given expression, but reuses its children"]
    pub fn SCIPduplicateExprShallow(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies an expression including children to use in a (possibly different) SCIP instance"]
    pub fn SCIPcopyExpr(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        copyexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an expression from a string\n\n We specify the grammar that defines the syntax of an expression.\n Loosely speaking, a `Base` will be any \"block\", a `Factor` is a `Base` to a power,\n a `Term` is a product of `Factors` and an `Expression` is a sum of `Terms`.\n\n The actual definition:\n ```\n Expression -> [\"+\" | \"-\"] Term { [ (\"+\" | \"-\" | \"number *\") Term | (\"number\" <varname>) ] }\n Term       -> Factor { (\"*\" | \"/\" ) Factor }\n Factor     -> Base [ \"^\" \"number\" | \"^(\" \"number\" \")\" ]\n Base       -> \"number\" | \"<varname>\" | \"(\" Expression \")\" | Op \"(\" OpExpression \")\n ```\n where `[a|b]` means `a` or `b` or none, `(a|b)` means `a` or `b`, `{a}` means 0 or more `a`.\n\n Note that `Op` and `OpExpression` are undefined.\n `Op` corresponds to the name of an expression handler and `OpExpression` to whatever string the expression handler accepts (through its parse method)."]
    pub fn SCIPparseExpr(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        exprstr: *const ::std::os::raw::c_char,
        finalpos: *mut *const ::std::os::raw::c_char,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " captures an expression (increments usage count)"]
    pub fn SCIPcaptureExpr(expr: *mut SCIP_EXPR);
}
unsafe extern "C" {
    #[doc = " releases an expression (decrements usage count and possibly frees expression)"]
    pub fn SCIPreleaseExpr(scip: *mut SCIP, expr: *mut *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is a variable expression"]
    pub fn SCIPisExprVar(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is a value expression"]
    pub fn SCIPisExprValue(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is a sum expression"]
    pub fn SCIPisExprSum(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is a product expression"]
    pub fn SCIPisExprProduct(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether an expression is a power expression"]
    pub fn SCIPisExprPower(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " print an expression as info-message"]
    pub fn SCIPprintExpr(scip: *mut SCIP, expr: *mut SCIP_EXPR, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initializes printing of expressions in dot format to a give FILE* pointer"]
    pub fn SCIPprintExprDotInit(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
        file: *mut FILE,
        whattoprint: SCIP_EXPRPRINT_WHAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initializes printing of expressions in dot format to a file with given filename"]
    pub fn SCIPprintExprDotInit2(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
        filename: *const ::std::os::raw::c_char,
        whattoprint: SCIP_EXPRPRINT_WHAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main part of printing an expression in dot format"]
    pub fn SCIPprintExprDot(
        scip: *mut SCIP,
        printdata: *mut SCIP_EXPRPRINTDATA,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " finishes printing of expressions in dot format"]
    pub fn SCIPprintExprDotFinal(
        scip: *mut SCIP,
        printdata: *mut *mut SCIP_EXPRPRINTDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " shows a single expression by use of dot and gv\n\n This function is meant for debugging purposes.\n It's signature is kept as simple as possible to make it\n easily callable from gdb, for example.\n\n It prints the expression into a temporary file in dot format, then calls dot to create a postscript file, then calls ghostview (gv) to show the file.\n SCIP will hold until ghostscript is closed."]
    pub fn SCIPshowExpr(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints structure of an expression a la Maple's dismantle"]
    pub fn SCIPdismantleExpr(
        scip: *mut SCIP,
        file: *mut FILE,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " evaluate an expression in a point\n\n Iterates over expressions to also evaluate children, if necessary.\n Value can be received via SCIPexprGetEvalValue().\n If an evaluation error (division by zero, ...) occurs, this value will\n be set to SCIP_INVALID.\n\n If a nonzero \\p soltag is passed, then only (sub)expressions are\n reevaluated that have a different solution tag. If a soltag of 0\n is passed, then subexpressions are always reevaluated.\n The tag is stored together with the value and can be received via\n SCIPexprGetEvalTag()."]
    pub fn SCIPevalExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns a previously unused solution tag for expression evaluation"]
    pub fn SCIPgetExprNewSoltag(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " evaluates gradient of an expression for a given point\n\n Initiates an expression walk to also evaluate children, if necessary.\n Value can be received from variable expressions via SCIPexprGetDerivative() or via SCIPgetExprPartialDiffNonlinear().\n If an error (division by zero, ...) occurs, these functions return SCIP_INVALID."]
    pub fn SCIPevalExprGradient(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " evaluates Hessian-vector product of an expression for a given point and direction\n\n Evaluates children, if necessary.\n Value can be received via SCIPgetExprPartialDiffGradientDirNonlinear().\n If an error (division by zero, ...) occurs, this value will\n be set to SCIP_INVALID."]
    pub fn SCIPevalExprHessianDir(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
        direction: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " possibly reevaluates the activity of the expression\n\n Reevaluate activity if currently stored is no longer uptodate (some bound was changed since last evaluation).\n\n The owner of the expression may overwrite the methods used to evaluate the activity,\n including whether the local or global domain of variables is used.\n By default (no owner, or owner doesn't overwrite activity evaluation),\n the local domain of variables is used.\n\n @note If expression is set to be integral, then activities are tightened to integral values.\n   Thus, ensure that the integrality information is valid (if set to TRUE; the default (FALSE) is always ok)."]
    pub fn SCIPevalExprActivity(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compare expressions\n @return -1, 0 or 1 if expr1 <, =, > expr2, respectively\n @note The given expressions are assumed to be simplified."]
    pub fn SCIPcompareExpr(
        scip: *mut SCIP,
        expr1: *mut SCIP_EXPR,
        expr2: *mut SCIP_EXPR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compute the hash value of an expression"]
    pub fn SCIPhashExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        hashval: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " simplifies an expression\n\n This is largely inspired by Joel Cohen's\n *Computer algebra and symbolic computation: Mathematical methods*,\n in particular Chapter 3.\n The other fountain of inspiration are the simplifying methods of expr.c in SCIP 7.\n\n Note: The things to keep in mind when adding simplification rules are the following.\n I will be using the product expressions (see expr_product.c) as an example.\n There are mainly 3 parts of the simplification process. You need to decide\n at which stage the simplification rule makes sense.\n 1. Simplify each factor (simplifyFactor()): At this stage we got the children of the product expression.\n    At this point, each child is simplified when viewed as a stand-alone expression, but not necessarily when viewed as child of a product expression.\n    Rules like SP2, SP7, etc are enforced at this point.\n 2. Multiply the factors (mergeProductExprlist()): At this point rules like SP4, SP5 and SP14 are enforced.\n 3. Build the actual simplified product expression (buildSimplifiedProduct()):\n    At this point rules like SP10, SP11, etc are enforced.\n\n During steps 1 and 2 do not forget to set the flag `changed` to TRUE when something actually changes.\n\n \\par Definition of simplified expressions\n\n An expression is simplified if it\n - is a value expression\n - is a var expression\n - is a product expression such that\n   - SP1: every child is simplified\n   - SP2: no child is a product\n   - SP4: no two children are the same expression (those should be multiplied)\n   - SP5: the children are sorted [commutative rule]\n   - SP7: no child is a value\n   - SP8: its coefficient is 1.0 (otherwise should be written as sum)\n   - SP10: it has at least two children\n   - TODO?: at most one child is an `abs`\n   - SP11: no two children are `expr*log(expr)`\n     (TODO: we could handle more complicated stuff like \\f$xy\\log(x) \\to - y * \\mathrm{entropy}(x)\\f$, but I am not sure this should happen at the simplification level;\n            similar for \\f$(xy) \\log(xy)\\f$, which currently simplifies to \\f$xy \\log(xy)\\f$)\n   - SP12: if it has two children, then neither of them is a sum (expand sums)\n   - SP12b: if it has at least two children and expandalways is set, then no child is a sum (expand sums always)\n   - SP13: no child is a sum with a single term\n   - SP14: at most one child is an `exp`\n - is a power expression such that\n   - POW1: exponent is not 0\n   - POW2: exponent is not 1\n   - POW3: its child is not a value\n   - POW4: its child is simplified\n   - POW5: if exponent is integer, its child is not a product\n   - POW5a: if exponent is fractional and distribfracexponent param is enabled, its child is not a product\n   - POW6: if exponent is integer, its child is not a sum with a single term (\\f$(2x)^2 \\to 4x^2\\f$)\n   - POW7: if exponent is integer and at most expandmaxeponent param, its child is not a sum (expand sums)\n   - POW8: its child is not a power unless \\f$(x^n)^m\\f$ with \\f$nm\\f$ being integer and \\f$n\\f$ or \\f$m\\f$ fractional and \\f$n\\f$ not being even integer\n   - POW9: its child is not a sum with a single term with a positive coefficient: \\f$(25x)^{0.5} \\to 5 x^{0.5}\\f$\n   - POW10: its child is not a binary variable: \\f$b^e, e > 0 \\to b\\f$; \\f$b^e, e < 0 \\to b := 1\\f$\n   - POW11: its child is not an exponential: \\f$\\exp(\\text{expr})^e \\to \\exp(e\\cdot\\text{expr})\\f$\n   - POW12: its child is not an absolute value if the exponent is an even integer: \\f$\\abs(\\text{expr})^e, e \\text{ even} \\to \\text{expr}^e\\f$\n - is a signedpower expression such that\n   - SPOW1: exponent is not 0\n   - SPOW2: exponent is not 1\n   - SPOW3: its child is not a value\n   - SPOW4: its child is simplified\n   - SPOW5: (TODO) do we want to distribute signpowers over products like we do for powers?\n   - SPOW6: exponent is not an odd integer: (signpow odd expr) -> (pow odd expr)\n   - SPOW8: if exponent is integer, its child is not a power\n   - SPOW9: its child is not a sum with a single term: \\f$\\mathrm{signpow}(25x,0.5) \\to 5\\mathrm{signpow}(x,0.5)\\f$\n   - SPOW10: its child is not a binary variable: \\f$\\mathrm{signpow}(b,e), e > 0 \\to b\\f$; \\f$\\mathrm{signpow}(b,e), e < 0 \\to b := 1\\f$\n   - SPOW11: its child is not an exponential: \\f$\\mathrm{signpow}(\\exp(\\text{expr}),e) \\to \\exp(e\\cdot\\text{expr})\\f$\n   - TODO: what happens when child is another signed power?\n   - TODO: if child &ge; 0 -> transform to normal power; if child < 0 -> transform to - normal power\n\n   TODO: Some of these criteria are too restrictive for signed powers; for example, the exponent does not need to be\n   an integer for signedpower to distribute over a product (SPOW5, SPOW6, SPOW8). Others can also be improved.\n - is a sum expression such that\n   - SS1: every child is simplified\n   - SS2: no child is a sum\n   - SS3: no child is a value (values should go in the constant of the sum)\n   - SS4: no two children are the same expression (those should be summed up)\n   - SS5: the children are sorted [commutative rule]\n   - SS6: it has at least one child\n   - SS7: if it consists of a single child, then either constant is != 0.0 or coef != 1\n   - SS8: no child has coefficient 0\n   - SS9: if a child c is a product that has an exponential expression as one of its factors, then the coefficient of c is +/-1.0\n   - SS10: if a child c is an exponential, then the coefficient of c is +/-1.0\n - it is a function with simplified arguments, but not all of them can be values\n - TODO? a logarithm doesn't have a product as a child\n - TODO? the exponent of an exponential is always 1\n\n \\par Ordering Rules (see SCIPexprCompare())\n \\anchor EXPR_ORDER\n These rules define a total order on *simplified* expressions.\n There are two groups of rules, when comparing equal type expressions and different type expressions.\n\n Equal type expressions:\n - OR1: u,v value expressions: u < v &hArr; val(u) < val(v)\n - OR2: u,v var expressions: u < v &hArr; `SCIPvarGetIndex(var(u))` < `SCIPvarGetIndex(var(v))`\n - OR3: u,v are both sum or product expression: < is a lexicographical order on the terms\n - OR4: u,v are both pow: u < v &hArr; base(u) < base(v) or, base(u) = base(v) and expo(u) < expo(v)\n - OR5: u,v are \\f$u = f(u_1, ..., u_n), v = f(v_1, ..., v_m)\\f$: u < v &hArr; For the first k such that \\f$u_k \\neq v_k\\f$, \\f$u_k < v_k\\f$, or if such a \\f$k\\f$ doesn't exist, then \\f$n < m\\f$.\n\n Different type expressions:\n - OR6: u value, v other: u < v always\n - OR7: u sum, v var or func: u < v &hArr; u < 0+v;\n        In other words, if \\f$u = \\sum_{i=1}^n \\alpha_i u_i\\f$, then u < v &hArr; \\f$u_n\\f$ < v or if \\f$u_n\\f$ = v and \\f$\\alpha_n\\f$ < 1.\n - OR8: u product, v pow, sum, var or func: u < v &hArr; u < 1*v;\n        In other words, if \\f$u = \\prod_{i=1}^n u_i\\f$, then u < v &hArr; \\f$u_n\\f$ < v.\n        Note: since this applies only to simplified expressions, the form of the product is correct.\n              Simplified products  do *not* have constant coefficients.\n - OR9: u pow, v sum, var or func: u < v &hArr; u < v^1\n - OR10: u var, v func: u < v always\n - OR11: u func, v other type of func: u < v &hArr; name(type(u)) < name(type(v))\n - OR12: none of the rules apply: u < v &hArr; ! v < u\n\n Examples:\n - x < x^2 ?:  x is var and x^2 power, so none applies (OR12).\n   Hence, we try to answer x^2 < x ?: x^2 < x &hArr; x < x or if x = x and 2 < 1 &hArr; 2 < 1 &hArr; False. So x < x^2 is True.\n - x < x^-1 --OR12&rarr; ~(x^-1 < x) --OR9&rarr; ~(x^-1 < x^1) --OR4&rarr; ~(x < x or -1 < 1) &rarr; ~True &rarr; False\n - x*y < x --OR8&rarr; x*y < 1*x --OR3&rarr; y < x --OR2&rarr; False\n - x*y < y --OR8&rarr; x*y < 1*y --OR3&rarr; y < x --OR2&rarr; False\n\n \\par Algorithm\n\n The recursive version of the algorithm is\n\n     EXPR simplify(expr)\n        for c in 1..expr->nchildren\n           expr->children[c] = simplify(expr->children[c])\n        end\n        return expr->exprhdlr->simplify(expr)\n     end\n\n Important: Whatever is returned by a simplify callback **has** to be simplified.\n Also, all children of the given expression **are** already simplified."]
    pub fn SCIPsimplifyExpr(
        scip: *mut SCIP,
        rootexpr: *mut SCIP_EXPR,
        simplified: *mut *mut SCIP_EXPR,
        changed: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retrieves symmetry information from an expression"]
    pub fn SCIPgetSymDataExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        symdata: *mut *mut SYM_EXPRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " replaces common sub-expressions in a given expression graph by using a hash key for each expression\n\n  The algorithm consists of two steps:\n\n  1. traverse through all given expressions and compute for each of them a (not necessarily unique) hash\n\n  2. initialize an empty hash table and traverse through all expression; check for each of them if we can find a\n     structural equivalent expression in the hash table; if yes we replace the expression by the expression inside the\n     hash table, otherwise we add it to the hash table\n\n  @note the hash keys of the expressions are used for the hashing inside the hash table; to compute if two expressions\n  (with the same hash) are structurally the same we use the function SCIPexprCompare()."]
    pub fn SCIPreplaceCommonSubexpressions(
        scip: *mut SCIP,
        exprs: *mut *mut SCIP_EXPR,
        nexprs: ::std::os::raw::c_int,
        replacedroot: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes the curvature of a given expression and all its subexpressions\n\n  @note this function also evaluates all subexpressions w.r.t. current variable bounds\n  @note this function relies on information from the curvature callback of expression handlers only,\n    consider using function @ref SCIPhasExprCurvature() of the convex-nlhdlr instead, as that uses more information to deduce convexity"]
    pub fn SCIPcomputeExprCurvature(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes integrality information of a given expression and all its subexpressions\n\n The integrality information can be accessed via SCIPexprGetIntegrality() and SCIPexprIsIntegral()."]
    pub fn SCIPcomputeExprIntegrality(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the total number of variable expressions in an expression\n\n The function counts variable expressions in common sub-expressions only once, but\n counts variables appearing in several variable expressions multiple times."]
    pub fn SCIPgetExprNVars(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns all variable expressions contained in a given expression\n\n The array to store all variable expressions needs to be at least of size\n the number of unique variable expressions in the expression which is given by SCIPgetExprNVars().\n\n If every variable is represented by only one variable expression (common subexpression have been removed)\n then SCIPgetExprNVars() can be bounded by SCIPgetNTotalVars().\n If, in addition, non-active variables have been removed from the expression, e.g., by simplifying,\n then SCIPgetExprNVars() can be bounded by SCIPgetNVars().\n\n @note function captures variable expressions"]
    pub fn SCIPgetExprVarExprs(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        varexprs: *mut *mut SCIP_EXPR,
        nvarexprs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the print callback for an expression\n\n @see SCIP_DECL_EXPRPRINT"]
    pub fn SCIPcallExprPrint(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        stage: SCIP_EXPRITER_STAGE,
        currentchild: ::std::os::raw::c_int,
        parentprecedence: ::std::os::raw::c_uint,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the curvature callback for an expression\n\n @see SCIP_DECL_EXPRCURVATURE\n\n Returns unknown curvature if callback not implemented."]
    pub fn SCIPcallExprCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        exprcurvature: SCIP_EXPRCURV,
        success: *mut ::std::os::raw::c_uint,
        childcurv: *mut SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the monotonicity callback for an expression\n\n @see SCIP_DECL_EXPRMONOTONICITY\n\n Returns unknown monotonicity if callback not implemented."]
    pub fn SCIPcallExprMonotonicity(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childidx: ::std::os::raw::c_int,
        result: *mut SCIP_MONOTONE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the eval callback for an expression with given values for children\n\n Does not iterates over expressions, but requires values for children to be given.\n Value is not stored in expression, but returned in `val`.\n If an evaluation error (division by zero, ...) occurs, this value will\n be set to `SCIP_INVALID`."]
    pub fn SCIPcallExprEval(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childrenvalues: *mut f64,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the eval and fwdiff callback of an expression with given values for children\n\n Does not iterates over expressions, but requires values for children and direction to be given.\n\n Value is not stored in expression, but returned in `val`.\n If an evaluation error (division by zero, ...) occurs, this value will be set to `SCIP_INVALID`.\n\n Direction is not stored in expression, but returned in `dot`.\n If an differentiation error (division by zero, ...) occurs, this value will be set to `SCIP_INVALID`."]
    pub fn SCIPcallExprEvalFwdiff(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        childrenvalues: *mut f64,
        direction: *mut f64,
        val: *mut f64,
        dot: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the interval evaluation callback for an expression\n\n @see SCIP_DECL_EXPRINTEVAL\n\n Returns entire interval if callback not implemented."]
    pub fn SCIPcallExprInteval(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        interval: *mut SCIP_INTERVAL,
        intevalvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_INTERVAL,
        >,
        intevalvardata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the estimate callback for an expression\n\n @see SCIP_DECL_EXPRESTIMATE\n\n Returns without success if callback not implemented."]
    pub fn SCIPcallExprEstimate(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        localbounds: *mut SCIP_INTERVAL,
        globalbounds: *mut SCIP_INTERVAL,
        refpoint: *mut f64,
        overestimate: ::std::os::raw::c_uint,
        targetvalue: f64,
        coefs: *mut f64,
        constant: *mut f64,
        islocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        branchcand: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the initial estimators callback for an expression\n\n @see SCIP_DECL_EXPRINITESTIMATES\n\n Returns no estimators if callback not implemented."]
    pub fn SCIPcallExprInitestimates(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        bounds: *mut SCIP_INTERVAL,
        overestimate: ::std::os::raw::c_uint,
        coefs: *mut *mut f64,
        constant: *mut f64,
        nreturned: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the simplify callback for an expression\n\n @see SCIP_DECL_EXPRSIMPLIFY\n\n Returns unmodified expression if simplify callback not implemented.\n\n Does not simplify descendants (children, etc). Use SCIPsimplifyExpr() for that."]
    pub fn SCIPcallExprSimplify(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        simplifiedexpr: *mut *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the reverse propagation callback for an expression\n\n @see SCIP_DECL_EXPRREVERSEPROP\n\n Returns unmodified `childrenbounds` if reverseprop callback not implemented."]
    pub fn SCIPcallExprReverseprop(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        bounds: SCIP_INTERVAL,
        childrenbounds: *mut SCIP_INTERVAL,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls the symmetry information callback for an expression\n\n Returns NULL pointer if not implemented."]
    pub fn SCIPcallExprGetSymData(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        symdata: *mut *mut SYM_EXPRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an expression iterator"]
    pub fn SCIPcreateExpriter(scip: *mut SCIP, iterator: *mut *mut SCIP_EXPRITER) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees an expression iterator"]
    pub fn SCIPfreeExpriter(iterator: *mut *mut SCIP_EXPRITER);
}
unsafe extern "C" {
    #[doc = " checks whether an expression is quadratic\n\n An expression is quadratic if it is either a square (of some expression), a product (of two expressions),\n or a sum of terms where at least one is a square or a product.\n\n Use SCIPexprGetQuadraticData() to get data about the representation as quadratic."]
    pub fn SCIPcheckExprQuadratic(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        isquadratic: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees information on quadratic representation of an expression\n\n Before doing changes to an expression, it can be useful to call this function."]
    pub fn SCIPfreeExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR);
}
unsafe extern "C" {
    #[doc = " evaluates quadratic term in a solution\n\n \\note This requires that every expression used in the quadratic data is a variable expression."]
    pub fn SCIPevalExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " prints quadratic expression"]
    pub fn SCIPprintExprQuadratic(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks the curvature of the quadratic expression\n\n For this, it builds the matrix Q of quadratic coefficients and computes its eigenvalues using LAPACK.\n If Q is\n - semidefinite positive -> curv is set to convex,\n - semidefinite negative -> curv is set to concave,\n - otherwise -> curv is set to unknown.\n\n If `assumevarfixed` is given and some expressions in quadratic terms correspond to variables present in\n this hashmap, then the corresponding rows and columns are ignored in the matrix Q."]
    pub fn SCIPcomputeExprQuadraticCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        curv: *mut SCIP_EXPRCURV,
        assumevarfixed: *mut SCIP_HASHMAP,
        storeeigeninfo: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns a monomial representation of a product expression\n\n The array to store all factor expressions needs to be of size the number of\n children in the expression which is given by SCIPexprGetNChildren().\n\n Given a non-trivial monomial expression, the function finds its representation as \\f$cx^\\alpha\\f$, where\n \\f$c\\f$ is a real coefficient, \\f$x\\f$ is a vector of auxiliary or original variables (where some entries can\n be NULL is the auxiliary variable has not been created yet), and \\f$\\alpha\\f$ is a real vector of exponents.\n\n A non-trivial monomial is a product of a least two expressions."]
    pub fn SCIPgetExprMonomialData(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        coef: *mut f64,
        exponents: *mut f64,
        factors: *mut *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns SCIP version number as major + minor / 100\n\n  @return SCIP major and minor version number"]
    pub fn SCIPversion() -> f64;
}
unsafe extern "C" {
    #[doc = " returns SCIP major version\n\n  @return major SCIP version"]
    pub fn SCIPmajorVersion() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns SCIP minor version\n\n  @return minor SCIP version"]
    pub fn SCIPminorVersion() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns SCIP technical (or patch) version\n\n  @return technical SCIP version"]
    pub fn SCIPtechVersion() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns SCIP sub version number\n\n  @return subversion SCIP version\n\n  @deprecated SCIPsubversion() always returns 0 and will be removed in a future release."]
    pub fn SCIPsubversion() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " prints a version information line to a file stream via the message handler system\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVersion(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " prints detailed information on the compile-time flags\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintBuildOptions(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " prints error message for the given SCIP_RETCODE via the error prints method"]
    pub fn SCIPprintError(retcode: SCIP_RETCODE);
}
unsafe extern "C" {
    #[doc = " creates and initializes SCIP data structures\n\n  @note The SCIP default message handler is installed. Use the method SCIPsetMessagehdlr() to install your own\n        message handler or SCIPsetMessagehdlrLogfile() and SCIPsetMessagehdlrQuiet() to write into a log\n        file and turn off/on the display output, respectively.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @post After calling this method @p scip reached the solving stage \\ref SCIP_STAGE_INIT\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreate(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees SCIP data structures\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method \\SCIP reached the solving stage \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfree(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns current stage of SCIP\n\n  @return the current SCIP stage\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetStage(scip: *mut SCIP) -> SCIP_STAGE;
}
unsafe extern "C" {
    #[doc = " outputs SCIP stage and solution status if applicable via the message handler\n\n  @note If the message handler is set to a NULL pointer nothing will be printed\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may to correspond to the original status.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPprintStage(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets solution status\n\n  @return SCIP solution status\n\n  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPgetStatus(scip: *mut SCIP) -> SCIP_STATUS;
}
unsafe extern "C" {
    #[doc = " gets name for a solution status"]
    pub fn SCIPstatusName(status: SCIP_STATUS) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " outputs solution status\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPprintStatus(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the current stage belongs to the transformed problem space\n\n  @return Returns TRUE if the \\SCIP instance is transformed, otherwise FALSE"]
    pub fn SCIPisTransformed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the presolving process would be finished given no more presolving reductions are found in this\n  presolving round\n\n  Checks whether the number of presolving rounds is not exceeded and the presolving reductions found in the current\n  presolving round suffice to trigger another presolving round.\n\n  @note if subsequent presolvers find more reductions, presolving might continue even if the method returns FALSE\n  @note does not check whether infeasibility or unboundedness was already detected in presolving (which would result\n        in presolving being stopped although the method returns TRUE)\n\n  @return Returns TRUE if presolving is finished if no further reductions are detected"]
    pub fn SCIPisPresolveFinished(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether SCIP has performed presolving during the last solve\n\n  @return Returns TRUE if presolving was performed during the last solve"]
    pub fn SCIPhasPerformedPresolve(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the user pressed CTRL-C to interrupt the solving process\n\n  @return Returns TRUE if Ctrl-C was pressed, otherwise FALSE."]
    pub fn SCIPpressedCtrlC(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the solving process should be / was stopped before proving optimality;\n  if the solving process should be / was stopped, the status returned by SCIPgetStatus() yields\n  the reason for the premature abort\n\n  @return Returns TRUE if solving process is stopped/interrupted, otherwise FALSE."]
    pub fn SCIPisStopped(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " includes information about an external code linked into the SCIP library"]
    pub fn SCIPincludeExternalCodeInformation(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns an array of names of currently included external codes"]
    pub fn SCIPgetExternalCodeNames(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns an array of the descriptions of currently included external codes\n\n  @note some descriptions may be NULL"]
    pub fn SCIPgetExternalCodeDescriptions(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns the number of currently included information on external codes"]
    pub fn SCIPgetNExternalCodes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " prints information on external codes to a file stream via the message handler system\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintExternalCodes(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP.\n\n  @note method has all heuristic callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeHeurBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeHeur(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP with its most fundamental callbacks.\n  All non-fundamental (or optional) callbacks\n  as, e. g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetHeurCopy(), SCIPsetHeurFree(),\n  SCIPsetHeurInit(), SCIPsetHeurExit(), SCIPsetHeurInitsol(), and SCIPsetHeurExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeHeur() instead"]
    pub fn SCIPincludeHeurBasic(
        scip: *mut SCIP,
        heur: *mut *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of primal heuristic"]
    pub fn SCIPsetHeurCopy(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of primal heuristic"]
    pub fn SCIPsetHeurFree(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of primal heuristic"]
    pub fn SCIPsetHeurInit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of primal heuristic"]
    pub fn SCIPsetHeurInitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the primal heuristic of the given name, or NULL if not existing"]
    pub fn SCIPfindHeur(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available primal heuristics"]
    pub fn SCIPgetHeurs(scip: *mut SCIP) -> *mut *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available primal heuristics"]
    pub fn SCIPgetNHeurs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a primal heuristic"]
    pub fn SCIPsetHeurPriority(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " create a diving set associated with a primal heuristic. The primal heuristic needs to be included\n  before this method can be called. The diveset is installed in the array of divesets of the heuristic\n  and can be retrieved later by accessing SCIPheurGetDivesets()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateDiveset(
        scip: *mut SCIP,
        diveset: *mut *mut SCIP_DIVESET,
        heur: *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        minreldepth: f64,
        maxreldepth: f64,
        maxlpiterquot: f64,
        maxdiveubquot: f64,
        maxdiveavgquot: f64,
        maxdiveubquotnosol: f64,
        maxdiveavgquotnosol: f64,
        lpresolvedomchgquot: f64,
        lpsolvefreq: ::std::os::raw::c_int,
        maxlpiterofs: ::std::os::raw::c_int,
        initialseed: ::std::os::raw::c_uint,
        backtrack: ::std::os::raw::c_uint,
        onlylpbranchcands: ::std::os::raw::c_uint,
        ispublic: ::std::os::raw::c_uint,
        specificsos1score: ::std::os::raw::c_uint,
        divesetgetscore: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                divetype: SCIP_DIVETYPE,
                cand: *mut SCIP_VAR,
                candsol: f64,
                candsfrac: f64,
                score: *mut f64,
                roundup: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        divesetavailable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                available: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " check specific preconditions for diving, e.g., if an incumbent solution is available"]
    pub fn SCIPisDivesetAvailable(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        available: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an IIS finder and includes it in SCIP\n\n  @note this method has all IIS finder callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeIISfinderBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeIISfinder(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        iisfindercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, iisfinder: *mut SCIP_IISFINDER) -> SCIP_RETCODE,
        >,
        iisfinderfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, iisfinder: *mut SCIP_IISFINDER) -> SCIP_RETCODE,
        >,
        iisfinderexec: ::std::option::Option<
            unsafe extern "C" fn(
                iis: *mut SCIP_IIS,
                iisfinder: *mut SCIP_IISFINDER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        iisfinderdata: *mut SCIP_IISFINDERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Creates an IIS finder and includes it in SCIP with its most fundamental callbacks.\n\n  All non-fundamental (or optional) callbacks as, e.g., copy and free callbacks, will be set to NULL. Optional\n  callbacks can be set via specific setter functions, see SCIPsetIISfinderCopy() and SCIPsetIISfinderFree(),\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeIISfinder() instead"]
    pub fn SCIPincludeIISfinderBasic(
        scip: *mut SCIP,
        iisfinder: *mut *mut SCIP_IISFINDER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        iisfinderexec: ::std::option::Option<
            unsafe extern "C" fn(
                iis: *mut SCIP_IIS,
                iisfinder: *mut SCIP_IISFINDER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        iisfinderdata: *mut SCIP_IISFINDERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of IIS finder"]
    pub fn SCIPsetIISfinderCopy(
        scip: *mut SCIP,
        iisfinder: *mut SCIP_IISFINDER,
        iisfindercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, iisfinder: *mut SCIP_IISFINDER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of IIS finder"]
    pub fn SCIPsetIISfinderFree(
        scip: *mut SCIP,
        iisfinder: *mut SCIP_IISFINDER,
        iisfinderfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, iisfinder: *mut SCIP_IISFINDER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " the execution method that iterates over the IIS finder plugins"]
    pub fn SCIPgenerateIIS(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the IIS finder of the given name, or NULL if not existing"]
    pub fn SCIPfindIISfinder(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_IISFINDER;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available IIS finders"]
    pub fn SCIPgetIISfinders(scip: *mut SCIP) -> *mut *mut SCIP_IISFINDER;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available IIS finders"]
    pub fn SCIPgetNIISfinders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of an IIS finder"]
    pub fn SCIPsetIISfinderPriority(
        scip: *mut SCIP,
        iisfinder: *mut SCIP_IISFINDER,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Gets the IIS storage.\n\n  @return the \\ref SCIP_IIS iis storage.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetIIS(scip: *mut SCIP) -> *mut SCIP_IIS;
}
unsafe extern "C" {
    #[doc = " returns whether the LP was or is to be solved in the current node\n\n  @return whether the LP was or is to be solved in the current node.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPhasCurrentNodeLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the LP of the current node is already constructed\n\n  @return whether the LP of the current node is already constructed.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " makes sure that the LP of the current node is loaded and may be accessed through the LP information methods\n\n  @warning Contructing the LP might change the amount of variables known in the transformed problem and therefore also\n           the variables array of SCIP (returned by SCIPgetVars() and SCIPgetVarsData()), so it might be necessary to\n           call one of the later method after this one\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructLP(scip: *mut SCIP, cutoff: *mut ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " makes sure that the LP of the current node is flushed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPflushLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets solution status of current LP\n\n  @return the solution status of current LP.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPSolstat(scip: *mut SCIP) -> SCIP_LPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " returns whether the current LP solution passed the primal feasibility check\n\n  @returns whether the current LP solution passed the primal feasibility check.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPPrimalReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current LP solution passed the dual feasibility check\n\n  @returns whether the current LP solution passed the dual feasibility check.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPDualReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound\n\n  @return whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets objective value of current LP (which is the sum of column and loose objective value)\n\n  @return the objective value of current LP (which is the sum of column and loose objective value).\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible\n        if a limit was hit during solving. It must not be used as a dual bound if the LP solution status returned by\n        SCIPgetLPSolstat() is SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of objective value of current LP that results from COLUMN variables only\n\n  @return the part of objective value of current LP that results from COLUMN variables only.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColumnObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of objective value of current LP that results from LOOSE variables only\n\n  @return part of objective value of current LP that results from LOOSE variables only.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPLooseObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective\n  function) global bound\n\n  @return the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective\n  function) global bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetGlobalPseudoObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound\n\n  @return the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound\n\n  @return whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisRootLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from COLUMN variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the part of the objective value of the root node LP that results from COLUMN variables only;\n  or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootColumnObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from LOOSE variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved\n\n  @return the part of the objective value of the root node LP that results from LOOSE variables only;\n  or SCIP_INVALID if the root node LP was not (yet) solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootLooseObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets current primal feasibility tolerance of LP"]
    pub fn SCIPgetLPFeastol(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets primal feasibility tolerance of LP"]
    pub fn SCIPsetLPFeastol(scip: *mut SCIP, newfeastol: f64);
}
unsafe extern "C" {
    #[doc = " resets primal feasibility tolerance of LP\n\n Sets primal feasibility tolerance to min of numerics/lpfeastolfactor * numerics/feastol and relaxfeastol."]
    pub fn SCIPresetLPFeastol(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " gets current LP columns along with the current number of LP columns\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColsData(
        scip: *mut SCIP,
        cols: *mut *mut *mut SCIP_COL,
        ncols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current LP columns\n\n  @return the current LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPCols(scip: *mut SCIP) -> *mut *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets current number of LP columns\n\n  @return the current number of LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPCols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets current number of unfixed LP columns\n\n  @return the current number of unfixed LP columns.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNUnfixedLPCols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets current LP rows along with the current number of LP rows\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRowsData(
        scip: *mut SCIP,
        rows: *mut *mut *mut SCIP_ROW,
        nrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current LP rows\n\n  @return the current LP rows.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRows(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets current number of LP rows\n\n  @return the current number of LP rows.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present\n  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing\n\n  @return TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present\n  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPallColsInLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current LP solution is basic, i.e. is defined by a valid simplex basis\n\n  @return whether the current LP solution is basic, i.e. is defined by a valid simplex basis.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPSolBasic(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets all indices of basic columns and rows: index i >= 0 corresponds to column i, index i < 0 to row -i-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBasisInd(scip: *mut SCIP, basisind: *mut ::std::os::raw::c_int)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a row from the inverse basis matrix B^-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvRow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a column from the inverse basis matrix B^-1\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvCol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a row from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvARow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        binvrow: *mut f64,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a column from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A),\n  i.e., it computes B^-1 * A_c with A_c being the c'th column of A\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvACol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a weighted sum of all LP rows; for negative weights, the left and right hand side of the corresponding\n  LP row are swapped in the summation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsumLPRows(
        scip: *mut SCIP,
        weights: *mut f64,
        sumcoef: *mut SCIP_REALARRAY,
        sumlhs: *mut f64,
        sumrhs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " interrupts or disables the interrupt of the currently ongoing lp solve; if the lp is not currently constructed just returns with no effect\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinterruptLP(scip: *mut SCIP, interrupt: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes current LP to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes MIP relaxation of the current branch-and-bound node to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteMIP(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
        origobj: ::std::os::raw::c_uint,
        lazyconss: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the LP interface of SCIP;\n  with the LPI you can use all of the methods defined in lpi/lpi.h;\n\n  @warning You have to make sure, that the full internal state of the LPI does not change or is recovered completely\n           after the end of the method that uses the LPI. In particular, if you manipulate the LP or its solution\n           (e.g. by calling one of the SCIPlpiAdd...() or one of the SCIPlpiSolve...() methods), you have to check in\n           advance with SCIPlpiWasSolved() whether the LP is currently solved. If this is the case, you have to make\n           sure, the internal solution status is recovered completely at the end of your method. This can be achieved\n           by getting the LPI state before applying any LPI manipulations with SCIPlpiGetState() and restoring it\n           afterwards with SCIPlpiSetState() and SCIPlpiFreeState(). Additionally you have to resolve the LP with the\n           appropriate SCIPlpiSolve...() call in order to reinstall the internal solution status.\n\n  @warning Make also sure, that all parameter values that you have changed are set back to their original values.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPI(scip: *mut SCIP, lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Displays quality information about the current LP solution. An LP solution need to be available. Information printed\n  is subject to what the LP solver supports\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPprintLPSolutionQuality(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compute relative interior point to current LP\n  @see SCIPlpComputeRelIntPoint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcomputeLPRelIntPoint(
        scip: *mut SCIP,
        relaxrows: ::std::os::raw::c_uint,
        inclobjcutoff: ::std::os::raw::c_uint,
        timelimit: f64,
        iterlimit: ::std::os::raw::c_int,
        point: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the reduced costs of a column in the last (feasible) LP\n\n  @return the reduced costs of a column in the last (feasible) LP\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @note calling this method in SCIP_STAGE_SOLVED is only recommended to experienced users and should only be called\n        for pure LP instances (without presolving)\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetColRedcost(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the Farkas coefficient of a column in the last (infeasible) LP\n\n  @return the Farkas coefficient of a column in the last (infeasible) LP\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetColFarkasCoef(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
unsafe extern "C" {
    #[doc = " marks a column to be not removable from the LP in the current node\n\n  @pre this method can be called in the following stage of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkColNotRemovableLocal(scip: *mut SCIP, col: *mut SCIP_COL);
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row from a constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row from a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row from a separator\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row from an unspecified source\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a separator\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from an unspecified source\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureRow(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseRow(scip: *mut SCIP, row: *mut *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left hand side of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowLhs(scip: *mut SCIP, row: *mut SCIP_ROW, lhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowRhs(scip: *mut SCIP, row: *mut SCIP_ROW, rhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs row, that all subsequent additions of variables to the row should be cached and not directly applied;\n  after all additions were applied, SCIPflushRowExtensions() must be called;\n  while the caching of row extensions is activated, information methods of the row give invalid results;\n  caching should be used, if a row is build with SCIPaddVarToRow() calls variable by variable to increase\n  the performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcacheRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " flushes all cached row extensions after a call of SCIPcacheRowExtensions() and merges coefficients with\n  equal columns into a single coefficient\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolves variable to columns and adds them with the coefficient to the row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variable will not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note In case calling this method in the enforcement process of an lp solution, it might be that some variables,\n        that were not yet in the LP (e.g. dynamic columns) will change their lp solution value returned by SCIP.\n        For example, a variable, which has a negative objective value, that has no column in the lp yet, is in the lp solution\n        on its upper bound (variables with status SCIP_VARSTATUS_LOOSE are in an lp solution on it's best bound), but\n        creating the column, changes the solution value (variable than has status SCIP_VARSTATUS_COLUMN, and the\n        initialization sets the lp solution value) to 0.0. (This leads to the conclusion that, if a constraint was\n        violated, the linear relaxation might not be violated anymore.)\n\n  @note When several variables are added to a row with the use of this function, performance can be improved by\n        calling SCIPcacheRowExtensions() before these additions and SCIPflushRowExtensions() after."]
    pub fn SCIPaddVarToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolves variables to columns and adds them with the coefficients to the row;\n  this method caches the row extensions and flushes them afterwards to gain better performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If a coefficients absolute value is below the SCIP epsilon tolerance, the variable with its value is not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolves variables to columns and adds them with the same single coefficient to the row;\n  this method caches the row extensions and flushes them afterwards to gain better performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variables will not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRowSameCoef(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to find a value, such that all row coefficients, if scaled with this value become integral\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcRowIntegralScalar(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to scale row, s.t. all coefficients (of integer variables) become integral\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmakeRowIntegral(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks a row to be not removable from the LP in the current node\n\n  @pre this method can be called in the following stage of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRowNotRemovableLocal(scip: *mut SCIP, row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " returns number of integral columns in the row\n\n  @return number of integral columns in the row\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowNumIntCols(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns number of implied integral columns in the row\n\n  @return number of implied integral columns in the row\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowNumImpliedIntCols(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns minimal absolute value of row vector's non-zero coefficients\n\n  @return minimal absolute value of row vector's non-zero coefficients\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns maximal absolute value of row vector's non-zero coefficients\n\n  @return maximal absolute value of row vector's non-zero coefficients\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the minimal activity of a row w.r.t. the column's bounds\n\n  @return the minimal activity of a row w.r.t. the column's bounds\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the maximal activity of a row w.r.t. the column's bounds\n\n  @return the maximal activity of a row w.r.t. the column's bounds\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a row in the last LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row in the last LP solution\n\n  @return activity of a row in the last LP solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the last LP solution\n\n  @return the feasibility of a row in the last LP solution: negative value means infeasibility\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a row for the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for the current pseudo solution\n\n  @return the activity of a row for the current pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row for the current pseudo solution: negative value means infeasibility\n\n  @return the feasibility of a row for the current pseudo solution: negative value means infeasibility\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a row in the last LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row in the last LP or pseudo solution\n\n  @return the activity of a row in the last LP or pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the last LP or pseudo solution\n\n  @return the feasibility of a row in the last LP or pseudo solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for the given primal solution\n\n  @return the activitiy of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolActivity(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row for the given primal solution\n\n  @return the feasibility of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL)
    -> f64;
}
unsafe extern "C" {
    #[doc = " returns the parallelism of row with objective function\n\n  @return 1 is returned if the row is parallel to the objective function and 0 if it is orthogonal\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowObjParallelism(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
unsafe extern "C" {
    #[doc = " output row to file stream via the message handler system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRow(scip: *mut SCIP, row: *mut SCIP_ROW, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initiates LP diving, making methods SCIPchgVarObjDive(), SCIPchgVarLbDive(), and SCIPchgVarUbDive() available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note diving is allowed even if the current LP is not flushed, not solved, or not solved to optimality; be aware\n  that solving the (first) diving LP may take longer than expect and that the latter two cases could stem from\n  numerical troubles during the last LP solve; because of this, most users will want to call this method only if\n  SCIPgetLPSolstat(scip) == SCIP_LPSOLSTAT_OPTIMAL"]
    pub fn SCIPstartDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " quits LP diving and resets bounds and objective values of columns to the current node's values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPendDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes cutoffbound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgCutoffboundDive(scip: *mut SCIP, newcutoffbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's objective value in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's lower bound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's upper bound in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a row to the LP in current dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowDive(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes row lhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowLhs()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowLhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newlhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes row rhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowRhs()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowRhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newrhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets variable's objective value in current dive\n\n  @return the variable's objective value in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets variable's lower bound in current dive\n\n  @return the variable's lower bound in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets variable's upper bound in current dive\n\n  @return the variable's upper bound in current dive.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " solves the LP of the current dive; no separation or pricing is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note be aware that the LP solve may take longer than expected if SCIPgetLPSolstat(scip) != SCIP_LPSOLSTAT_OPTIMAL,\n  compare the explanation of SCIPstartDive()"]
    pub fn SCIPsolveDiveLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of the node in the current branch and bound run, where the last LP was solved in diving\n  or probing mode\n\n  @return the number of the node in the current branch and bound run, where the last LP was solved in diving\n  or probing mode.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLastDivenode(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns whether we are in diving mode\n\n  @return whether we are in diving mode.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinDive(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " computes two measures for dual degeneracy (dual degeneracy rate and variable-constraint ratio)\n  based on the changes applied when reducing the problem to the optimal face\n\n  returns the dual degeneracy rate, i.e., the share of nonbasic variables with reduced cost 0\n  and the variable-constraint ratio, i.e., the number of unfixed variables in relation to the basis size"]
    pub fn SCIPgetLPDualDegeneracy(
        scip: *mut SCIP,
        degeneracy: *mut f64,
        varconsratio: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns block memory to use at the current time\n\n  @return the block memory to use at the current time."]
    pub fn SCIPblkmem(scip: *mut SCIP) -> *mut BMS_BLKMEM;
}
unsafe extern "C" {
    #[doc = " returns buffer memory for short living temporary objects\n\n  @return the buffer memory for short living temporary objects"]
    pub fn SCIPbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
unsafe extern "C" {
    #[doc = " returns clean buffer memory for short living temporary objects initialized to all zero\n\n  @return the buffer memory for short living temporary objects initialized to all zero"]
    pub fn SCIPcleanbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
unsafe extern "C" {
    #[doc = " returns the total number of bytes used in block and buffer memory\n\n  @return the total number of bytes used in block and buffer memory."]
    pub fn SCIPgetMemUsed(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the total number of bytes in block and buffer memory\n\n  @return the total number of bytes in block and buffer memory."]
    pub fn SCIPgetMemTotal(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the estimated number of bytes used by external software, e.g., the LP solver\n\n  @return the estimated number of bytes used by external software, e.g., the LP solver."]
    pub fn SCIPgetMemExternEstim(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " calculate memory size for dynamically allocated arrays\n\n  @return the memory size for dynamically allocated arrays."]
    pub fn SCIPcalcMemGrowSize(
        scip: *mut SCIP,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " extends a dynamically allocated block memory array to be able to store at least the given number of elements;\n  use SCIPensureBlockMemoryArray() define to call this method!\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPensureBlockMemoryArray_call(
        scip: *mut SCIP,
        arrayptr: *mut *mut ::std::os::raw::c_void,
        elemsize: usize,
        arraysize: *mut ::std::os::raw::c_int,
        minsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints output about used memory"]
    pub fn SCIPprintMemoryDiagnostic(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " run garbage collection on block memory\n\n For both settings and problems block memory, frees unused chunks in chunk blocks\n and frees chunk blocks that have no chunks by calling BMSgarbagecollectBlockMemory().\n Note that the former (freeing unused chunks) is also done automatically when a\n chunk block has many unused chunks."]
    pub fn SCIPcollectMemoryGarbage(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " installs the given message handler, such that all messages are passed to this handler. A messages handler can be\n  created via SCIPmessagehdlrCreate().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note The currently installed messages handler gets freed if this SCIP instance is its last user (w.r.t. capture/release)."]
    pub fn SCIPsetMessagehdlr(scip: *mut SCIP, messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the currently installed message handler\n\n  @return the currently installed message handler, or NULL if messages are currently suppressed"]
    pub fn SCIPgetMessagehdlr(scip: *mut SCIP) -> *mut SCIP_MESSAGEHDLR;
}
unsafe extern "C" {
    #[doc = " sets the log file name for the currently installed message handler"]
    pub fn SCIPsetMessagehdlrLogfile(scip: *mut SCIP, filename: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " sets the currently installed message handler to be quiet (or not)"]
    pub fn SCIPsetMessagehdlrQuiet(scip: *mut SCIP, quiet: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn SCIPwarningMessage(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn SCIPprintDebugMessage(
        scip: *mut SCIP,
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn SCIPdebugMessagePrint(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn SCIPdialogMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn SCIPinfoMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn SCIPverbMessage(
        scip: *mut SCIP,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " returns the current message verbosity level\n\n  @return message verbosity level of SCIP\n\n  @see \\ref SCIP_VerbLevel \"SCIP_VERBLEVEL\" for a list of all verbosity levels"]
    pub fn SCIPgetVerbLevel(scip: *mut SCIP) -> SCIP_VERBLEVEL;
}
unsafe extern "C" {
    #[doc = " returns whether the NLP relaxation has been enabled\n\n  If the NLP relaxation is enabled, then SCIP will construct the NLP relaxation when the solving process is about to begin.\n  To check whether an NLP is existing, use SCIPisNLPConstructed().\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @see SCIPenableNLP"]
    pub fn SCIPisNLPEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " notifies SCIP that the NLP relaxation should be initialized in INITSOLVE\n\n  This method is typically called by a constraint handler that handles constraints that have a nonlinear representation as nonlinear rows, e.g., cons_nonlinear.\n\n  The function should be called before the branch-and-bound process is initialized, e.g., when presolve is exiting.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPenableNLP(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " returns whether an NLP has been constructed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisNLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks whether the NLP has a continuous variable in a nonlinear term\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPContinuousNonlinearity(
        scip: *mut SCIP,
        result: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current NLP variables along with the current number of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets array with variables of the NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets current number of variables in NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " computes for each variables the number of NLP rows in which the variable appears in the nonlinear part\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsNonlinearity(
        scip: *mut SCIP,
        nlcount: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns dual solution values associated with lower bounds of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsLbDualsol(scip: *mut SCIP) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " returns dual solution values associated with upper bounds of NLP variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsUbDualsol(scip: *mut SCIP) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets current NLP nonlinear rows along with the current number of NLP nonlinear rows\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRowsData(
        scip: *mut SCIP,
        nlrows: *mut *mut *mut SCIP_NLROW,
        nnlrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets array with nonlinear rows of the NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRows(scip: *mut SCIP) -> *mut *mut SCIP_NLROW;
}
unsafe extern "C" {
    #[doc = " gets current number of nonlinear rows in NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPNlRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets statistics on convexity of rows in NLP\n\n  Reports counts on the current number of linear rows, convex inequalities, nonconvex inequalities, and nonlinear equalities or ranged rows.\n  - A nonlinear inequality with infinity left-hand-side is accounted as convex if its expression has been marked as convex.\n  - A nonlinear inequality with infinity right-hand-side is accounted as convex if its expression has been marked as concave.\n  - Other nonlinear rows are accounted as nonconvex. Note that convexity for a nonlinear row may just not have been detected.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLPNlRowsStat(
        scip: *mut SCIP,
        nlinear: *mut ::std::os::raw::c_int,
        nconvexineq: *mut ::std::os::raw::c_int,
        nnonconvexineq: *mut ::std::os::raw::c_int,
        nnonlineareq: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a nonlinear row to the NLP. This row is captured by the NLP.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes a nonlinear row from the NLP\n\n  This row is released in the NLP.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " makes sure that the NLP of the current node is flushed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets or clears initial primal guess for NLP solution (start point for NLP solver)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuess(scip: *mut SCIP, initialguess: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initial primal guess for NLP solution (start point for NLP solver)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuessSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the current NLP (or diving NLP if in diving mode) with given parameters\n\n  Typical use is\n\n      SCIP_NLPPARAM nlparam = { SCIP_NLPPARAM_DEFAULT(scip); }\n      nlpparam.iterlimit = 42;\n      SCIP_CALL( SCIPsolveNLPParam(scip, nlpparam) );\n\n  or, in one line:\n\n      SCIP_CALL( SCIPsolveNLPParam(scip, (SCIP_NLPPARAM){ SCIP_NLPPARAM_DEFAULT(scip), .iterlimit = 42 }) );\n\n  To get the latter, also \\ref SCIPsolveNLP can be used.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveNLPParam(scip: *mut SCIP, param: SCIP_NLPPARAM) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets solution status of current NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPSolstat(scip: *mut SCIP) -> SCIP_NLPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " gets termination status of last NLP solve\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPTermstat(scip: *mut SCIP) -> SCIP_NLPTERMSTAT;
}
unsafe extern "C" {
    #[doc = " gives statistics (number of iterations, solving time, ...) of last NLP solve\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPStatistics(
        scip: *mut SCIP,
        statistics: *mut SCIP_NLPSTATISTICS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets objective value of current NLP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPObjval(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " indicates whether a solution for the current NLP is available\n\n The solution may be optimal, feasible, or infeasible.\n Thus, returns whether the NLP solution status is at most \\ref SCIP_NLPSOLSTAT_LOCINFEASIBLE.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPSolution(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets fractional variables of last NLP solution along with solution values and fractionalities\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPFracVars(
        scip: *mut SCIP,
        fracvars: *mut *mut *mut SCIP_VAR,
        fracvarssol: *mut *mut f64,
        fracvarsfrac: *mut *mut f64,
        nfracvars: *mut ::std::os::raw::c_int,
        npriofracvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes current NLP to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPwriteNLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the NLP interface and problem used by the SCIP NLP\n\n  @warning With the NLPI and its problem, all methods defined in \\ref scip_nlpi.h and \\ref pub_nlpi.h can be used.\n           It needs to be ensured that the full internal state of the NLPI does not change or is recovered completely\n           after the end of the method that uses the NLPI. In particular, if the NLP or its solution is manipulated\n           (e.g. by calling one of the SCIPaddNlpi...() or the SCIPsolveNlpi() method), one has to check in advance\n           whether the NLP is currently solved.  If this is the case, one has to make sure that the internal solution\n           status is recovered completely again. Additionally one has to resolve the NLP with\n           SCIPsolveNlpi() in order to reinstall the internal solution status.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPI(
        scip: *mut SCIP,
        nlpi: *mut *mut SCIP_NLPI,
        nlpiproblem: *mut *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initiates NLP diving\n\n  Makes functions SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP() and SCIPchgVarsBoundsDiveNLP() available.\n  Further, SCIPsolveNLP() can be used to solve the diving NLP.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstartDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " ends NLP diving\n\n  Resets changes made by SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP(), and SCIPchgVarsBoundsDiveNLP().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes linear objective coefficient of a variable in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarObjDiveNLP(scip: *mut SCIP, var: *mut SCIP_VAR, coef: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes bounds of a variable in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBoundsDiveNLP(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lb: f64,
        ub: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes bounds of a set of variables in diving NLP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarsBoundsDiveNLP(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        constant: f64,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
        curvature: SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear row without any coefficients\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear row from a linear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRowFromRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of a nonlinear row, and frees memory if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseNlRow(scip: *mut SCIP, nlrow: *mut *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left hand side of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, lhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowRhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, rhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes constant of a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowConstant(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        constant: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set curvature of a nonlinear row"]
    pub fn SCIPsetNlRowCurvature(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, curvature: SCIP_EXPRCURV);
}
unsafe extern "C" {
    #[doc = " adds variable with a linear coefficient to a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variables with linear coefficients to a row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefsToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes linear coefficient of a variables in a nonlinear row\n\n  Setting the coefficient to 0.0 means that it is removed from the row.\n  The variable does not need to exists before.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLinearCoef(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets or deletes expression in a nonlinear row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNlRowExpr(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowNLPActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a nonlinear row in the last NLP solution\n\n  If row cannot be evaluated at NLP solution, then activity is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP solution: negative value means infeasibility\n\n  If row cannot be evaluated at NLP solution, then feasibility is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a nonlinear row for the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowPseudoActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the activity of a nonlinear row for the current pseudo solution\n\n  If row cannot be evaluated at pseudo solution, then activity is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudoactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the current pseudo solution: negative value means infeasibility\n\n  If row cannot be evaluated at pseudo solution, then feasibility is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudofeasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the activity of a nonlinear row in the last NLP or pseudo solution\n\n  If row cannot be evaluated, then activity is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP or pseudo solution\n\n  If row cannot be evaluated, then feasibility is set to SCIP_INVALID.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the activity of a nonlinear row for the given primal solution or NLP solution or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the given primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives the minimal and maximal activity of a nonlinear row w.r.t. the variable's bounds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivityBounds(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        minactivity: *mut f64,
        maxactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints a nonlinear row to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, file: *mut FILE)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compares two NLPIs w.r.t. their priority"]
    pub fn SCIPnlpiComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets data of an NLPI"]
    pub fn SCIPnlpiGetData(nlpi: *mut SCIP_NLPI) -> *mut SCIP_NLPIDATA;
}
unsafe extern "C" {
    #[doc = " gets NLP solver name"]
    pub fn SCIPnlpiGetName(nlpi: *mut SCIP_NLPI) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets NLP solver description"]
    pub fn SCIPnlpiGetDesc(nlpi: *mut SCIP_NLPI) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets NLP solver priority"]
    pub fn SCIPnlpiGetPriority(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives number of problems created for NLP solver so far"]
    pub fn SCIPnlpiGetNProblems(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives total time spend in problem creation/modification/freeing"]
    pub fn SCIPnlpiGetProblemTime(nlpi: *mut SCIP_NLPI) -> f64;
}
unsafe extern "C" {
    #[doc = " total number of NLP solves so far"]
    pub fn SCIPnlpiGetNSolves(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives total time spend in NLP solves (as reported by solver)"]
    pub fn SCIPnlpiGetSolveTime(nlpi: *mut SCIP_NLPI) -> f64;
}
unsafe extern "C" {
    #[doc = " gives total time spend in function evaluation during NLP solves\n\n If parameter `timing/nlpieval` is off (the default), depending on the NLP solver, this may just return 0."]
    pub fn SCIPnlpiGetEvalTime(nlpi: *mut SCIP_NLPI) -> f64;
}
unsafe extern "C" {
    #[doc = " gives total number of iterations spend by NLP solver so far"]
    pub fn SCIPnlpiGetNIterations(nlpi: *mut SCIP_NLPI) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gives number of times a solve ended with a specific termination status"]
    pub fn SCIPnlpiGetNTermStat(
        nlpi: *mut SCIP_NLPI,
        termstatus: SCIP_NLPTERMSTAT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives number of times a solve ended with a specific solution status"]
    pub fn SCIPnlpiGetNSolStat(
        nlpi: *mut SCIP_NLPI,
        solstatus: SCIP_NLPSOLSTAT,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " adds statistics from one NLPI to another"]
    pub fn SCIPnlpiMergeStatistics(
        targetnlpi: *mut SCIP_NLPI,
        sourcenlpi: *mut SCIP_NLPI,
        reset: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " creates an NLPI and includes it into SCIP"]
    pub fn SCIPincludeNlpi(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        nlpicopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sourcenlpi: *mut SCIP_NLPI) -> SCIP_RETCODE,
        >,
        nlpifree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                nlpidata: *mut *mut SCIP_NLPIDATA,
            ) -> SCIP_RETCODE,
        >,
        nlpigetsolverpointer: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> *mut ::std::os::raw::c_void,
        >,
        nlpicreateproblem: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut *mut SCIP_NLPIPROBLEM,
                name: *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpifreeproblem: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_RETCODE,
        >,
        nlpigetproblempointer: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> *mut ::std::os::raw::c_void,
        >,
        nlpiaddvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nvars: ::std::os::raw::c_int,
                lbs: *const f64,
                ubs: *const f64,
                varnames: *mut *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpiaddconstraints: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nconss: ::std::os::raw::c_int,
                lhss: *const f64,
                rhss: *const f64,
                nlininds: *const ::std::os::raw::c_int,
                lininds: *const *mut ::std::os::raw::c_int,
                linvals: *const *mut f64,
                exprs: *mut *mut SCIP_EXPR,
                names: *mut *const ::std::os::raw::c_char,
            ) -> SCIP_RETCODE,
        >,
        nlpisetobjective: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nlins: ::std::os::raw::c_int,
                lininds: *const ::std::os::raw::c_int,
                linvals: *const f64,
                expr: *mut SCIP_EXPR,
                constant: f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgvarbounds: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nvars: ::std::os::raw::c_int,
                indices: *const ::std::os::raw::c_int,
                lbs: *const f64,
                ubs: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgconssides: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                nconss: ::std::os::raw::c_int,
                indices: *const ::std::os::raw::c_int,
                lhss: *const f64,
                rhss: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpidelvarset: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                dstats: *mut ::std::os::raw::c_int,
                dstatssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        nlpidelconsset: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                dstats: *mut ::std::os::raw::c_int,
                dstatssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        nlpichglinearcoefs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                idx: ::std::os::raw::c_int,
                nvals: ::std::os::raw::c_int,
                varidxs: *const ::std::os::raw::c_int,
                vals: *const f64,
            ) -> SCIP_RETCODE,
        >,
        nlpichgexpr: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                idxcons: ::std::os::raw::c_int,
                expr: *mut SCIP_EXPR,
            ) -> SCIP_RETCODE,
        >,
        nlpichgobjconstant: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                objconstant: f64,
            ) -> SCIP_RETCODE,
        >,
        nlpisetinitialguess: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                primalvalues: *mut f64,
                consdualvalues: *mut f64,
                varlbdualvalues: *mut f64,
                varubdualvalues: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        nlpisolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                param: SCIP_NLPPARAM,
            ) -> SCIP_RETCODE,
        >,
        nlpigetsolstat: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_NLPSOLSTAT,
        >,
        nlpigettermstat: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
            ) -> SCIP_NLPTERMSTAT,
        >,
        nlpigetsolution: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                primalvalues: *mut *mut f64,
                consdualvalues: *mut *mut f64,
                varlbdualvalues: *mut *mut f64,
                varubdualvalues: *mut *mut f64,
                objval: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        nlpigetstatistics: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlpi: *mut SCIP_NLPI,
                problem: *mut SCIP_NLPIPROBLEM,
                statistics: *mut SCIP_NLPSTATISTICS,
            ) -> SCIP_RETCODE,
        >,
        nlpidata: *mut SCIP_NLPIDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the NLPI of the given name, or NULL if not existing"]
    pub fn SCIPfindNlpi(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_NLPI;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available NLPIs (sorted by priority)"]
    pub fn SCIPgetNlpis(scip: *mut SCIP) -> *mut *mut SCIP_NLPI;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available NLPIs"]
    pub fn SCIPgetNNlpis(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of an NLPI"]
    pub fn SCIPsetNlpiPriority(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets internal pointer to NLP solver\n\n Depending on the solver interface, a solver pointer may exist for every NLP problem instance.\n For this case, a NLPI problem can be passed in as well."]
    pub fn SCIPgetNlpiSolverPointer(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " creates an empty problem instance"]
    pub fn SCIPcreateNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut *mut SCIP_NLPIPROBLEM,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a problem instance"]
    pub fn SCIPfreeNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets internal pointer to solver-internal problem instance"]
    pub fn SCIPgetNlpiProblemPointer(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " add variables to nlpi"]
    pub fn SCIPaddNlpiVars(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nvars: ::std::os::raw::c_int,
        lbs: *const f64,
        ubs: *const f64,
        varnames: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add constraints to nlpi"]
    pub fn SCIPaddNlpiConstraints(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nconss: ::std::os::raw::c_int,
        lhss: *const f64,
        rhss: *const f64,
        nlininds: *const ::std::os::raw::c_int,
        lininds: *const *mut ::std::os::raw::c_int,
        linvals: *const *mut f64,
        exprs: *mut *mut SCIP_EXPR,
        names: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets or overwrites objective, a minimization problem is expected"]
    pub fn SCIPsetNlpiObjective(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nlins: ::std::os::raw::c_int,
        lininds: *const ::std::os::raw::c_int,
        linvals: *const f64,
        expr: *mut SCIP_EXPR,
        constant: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change variable bounds"]
    pub fn SCIPchgNlpiVarBounds(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nvars: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        lbs: *const f64,
        ubs: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change constraint sides"]
    pub fn SCIPchgNlpiConsSides(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        nconss: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        lhss: *const f64,
        rhss: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " delete a set of variables"]
    pub fn SCIPdelNlpiVarSet(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        dstats: *mut ::std::os::raw::c_int,
        dstatssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " delete a set of constraints"]
    pub fn SCIPdelNlpiConsSet(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        dstats: *mut ::std::os::raw::c_int,
        dstatssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes or adds linear coefficients in a constraint or objective"]
    pub fn SCIPchgNlpiLinearCoefs(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        idx: ::std::os::raw::c_int,
        nvals: ::std::os::raw::c_int,
        varidxs: *const ::std::os::raw::c_int,
        vals: *const f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change the expression in the nonlinear part"]
    pub fn SCIPchgNlpiExpr(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        idxcons: ::std::os::raw::c_int,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change the constant offset in the objective"]
    pub fn SCIPchgNlpiObjConstant(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        objconstant: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initial guess"]
    pub fn SCIPsetNlpiInitialGuess(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        primalvalues: *mut f64,
        consdualvalues: *mut f64,
        varlbdualvalues: *mut f64,
        varubdualvalues: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " try to solve NLP with all parameters given as SCIP_NLPPARAM struct\n\n Typical use is\n\n     SCIP_NLPPARAM nlparam = { SCIP_NLPPARAM_DEFAULT(scip); }\n     nlpparam.iterlimit = 42;\n     SCIP_CALL( SCIPsolveNlpiParam(scip, nlpi, nlpiproblem, nlpparam) );\n\n or, in \"one\" line:\n\n     SCIP_CALL( SCIPsolveNlpiParam(scip, nlpi, nlpiproblem,\n        (SCIP_NLPPARAM){ SCIP_NLPPARAM_DEFAULT(scip), .iterlimit = 42 }) );\n\n To get the latter, also \\ref SCIPsolveNlpi can be used."]
    pub fn SCIPsolveNlpiParam(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        param: SCIP_NLPPARAM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives solution status"]
    pub fn SCIPgetNlpiSolstat(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_NLPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " gives termination reason"]
    pub fn SCIPgetNlpiTermstat(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_NLPTERMSTAT;
}
unsafe extern "C" {
    #[doc = " gives primal and dual solution\n for a ranged constraint, the dual variable is positive if the right hand side is active and negative if the left hand side is active"]
    pub fn SCIPgetNlpiSolution(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        primalvalues: *mut *mut f64,
        consdualvalues: *mut *mut f64,
        varlbdualvalues: *mut *mut f64,
        varubdualvalues: *mut *mut f64,
        objval: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives solve statistics"]
    pub fn SCIPgetNlpiStatistics(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        problem: *mut SCIP_NLPIPROBLEM,
        statistics: *mut SCIP_NLPSTATISTICS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a NLPI problem from given nonlinear rows\n\n The function computes for each variable the number of non-linear occurrences and stores it in the nlscore array.\n\n @note the first row corresponds always to the cutoff row (even if cutoffbound is SCIPinfinity(scip))"]
    pub fn SCIPcreateNlpiProblemFromNlRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut *mut SCIP_NLPIPROBLEM,
        name: *const ::std::os::raw::c_char,
        nlrows: *mut *mut SCIP_NLROW,
        nnlrows: ::std::os::raw::c_int,
        var2idx: *mut SCIP_HASHMAP,
        nlrow2idx: *mut SCIP_HASHMAP,
        nlscore: *mut f64,
        cutoffbound: f64,
        setobj: ::std::os::raw::c_uint,
        onlyconvex: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates variable bounds and the cutoff row in a NLPI problem\n\n The NLPI problem must have been setup by SCIPcreateNlpiProblemFromNlRows()."]
    pub fn SCIPupdateNlpiProblem(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2nlpiidx: *mut SCIP_HASHMAP,
        nlpivars: *mut *mut SCIP_VAR,
        nlpinvars: ::std::os::raw::c_int,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds SCIP_ROWs to a NLPI problem"]
    pub fn SCIPaddNlpiProblemRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        rows: *mut *mut SCIP_ROW,
        nrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds SCIP_NLROWs to a NLPI problem"]
    pub fn SCIPaddNlpiProblemNlRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        nlrows: *mut *mut SCIP_NLROW,
        nnlrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a node selector and includes it in SCIP.\n\n  @note method has all node selector callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeNodeselBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Creates a node selector and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetNodeselCopy(), SCIPsetNodeselFree(),\n  SCIPsetNodeselInit(), SCIPsetNodeselExit(), SCIPsetNodeselInitsol(), and SCIPsetNodeselExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeNodesel() instead"]
    pub fn SCIPincludeNodeselBasic(
        scip: *mut SCIP,
        nodesel: *mut *mut SCIP_NODESEL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of node selector"]
    pub fn SCIPsetNodeselCopy(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of node selector"]
    pub fn SCIPsetNodeselFree(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of node selector"]
    pub fn SCIPsetNodeselInit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of node selector"]
    pub fn SCIPsetNodeselExit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of node selector"]
    pub fn SCIPsetNodeselInitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of node selector"]
    pub fn SCIPsetNodeselExitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the node selector of the given name, or NULL if not existing"]
    pub fn SCIPfindNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available node selectors"]
    pub fn SCIPgetNodesels(scip: *mut SCIP) -> *mut *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available node selectors"]
    pub fn SCIPgetNNodesels(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a node selector in standard mode"]
    pub fn SCIPsetNodeselStdPriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the priority of a node selector in memory saving mode"]
    pub fn SCIPsetNodeselMemsavePriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the currently used node selector"]
    pub fn SCIPgetNodesel(scip: *mut SCIP) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " returns value treated as zero\n\n  @return value treated as zero"]
    pub fn SCIPepsilon(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns value treated as zero for sums of floating point values\n\n  @return value treated as zero for sums of floating point values"]
    pub fn SCIPsumepsilon(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    pub fn SCIPfeastol(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    pub fn SCIPdualfeastol(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns convergence tolerance used in barrier algorithm\n\n  @return convergence tolerance used in barrier algorithm"]
    pub fn SCIPbarrierconvtol(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " return the cutoff bound delta\n\n  @return cutoff bound data"]
    pub fn SCIPcutoffbounddelta(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " return the relaxation primal feasibility tolerance\n\n  @see SCIPchgRelaxfeastol\n  @return relaxfeastol"]
    pub fn SCIPrelaxfeastol(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the feasibility tolerance for constraints\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgFeastol(scip: *mut SCIP, feastol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the feasibility tolerance for reduced costs\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgDualfeastol(scip: *mut SCIP, dualfeastol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the convergence tolerance used in barrier algorithm\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBarrierconvtol(scip: *mut SCIP, barrierconvtol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the primal feasibility tolerance of relaxations\n\n This tolerance value is used by the SCIP core and plugins to tighten then feasibility tolerance on relaxations\n (especially the LP relaxation) during a solve. It is set to SCIP_INVALID initially, which means that only the\n feasibility tolerance of the particular relaxation is taken into account. If set to a valid value, however,\n then this value should be used to reduce the primal feasibility tolerance of a relaxation (thus, use the\n minimum of relaxfeastol and the relaxations primal feastol).\n\n @pre The value of relaxfeastol is reset to SCIP_INVALID when initializing the solve (INITSOL).\n Therefore, this method can only be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n @return previous value of relaxfeastol"]
    pub fn SCIPchgRelaxfeastol(scip: *mut SCIP, relaxfeastol: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " marks that some limit parameter was changed"]
    pub fn SCIPmarkLimitChanged(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " returns value treated as infinity"]
    pub fn SCIPinfinity(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the minimum value that is regarded as huge and should be handled separately (e.g., in activity\n  computation)"]
    pub fn SCIPgetHugeValue(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if values are in range of epsilon"]
    pub fn SCIPisEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than epsilon) lower than val2"]
    pub fn SCIPisLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than epsilon) greater than val2"]
    pub fn SCIPisLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than epsilon) greater than val2"]
    pub fn SCIPisGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than epsilon) lower than val2"]
    pub fn SCIPisGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is (positive) infinite"]
    pub fn SCIPisInfinity(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is huge and should be handled separately (e.g., in activity computation)"]
    pub fn SCIPisHugeValue(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range epsilon of 0.0"]
    pub fn SCIPisZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than epsilon"]
    pub fn SCIPisPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -epsilon"]
    pub fn SCIPisNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within epsilon"]
    pub fn SCIPisIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks whether the product val * scalar is integral in epsilon scaled by scalar"]
    pub fn SCIPisScalingIntegral(scip: *mut SCIP, val: f64, scalar: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than epsilon"]
    pub fn SCIPisFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + epsilon down to the next integer"]
    pub fn SCIPfloor(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - epsilon up to the next integer"]
    pub fn SCIPceil(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer with epsilon tolerance"]
    pub fn SCIPround(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in epsilon tolerance"]
    pub fn SCIPfrac(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if values are in range of sumepsilon"]
    pub fn SCIPisSumEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range sumepsilon of 0.0"]
    pub fn SCIPisSumZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than sumepsilon"]
    pub fn SCIPisSumPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -sumepsilon"]
    pub fn SCIPisSumNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of feasibility tolerance"]
    pub fn SCIPisFeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference val1 and val2 is lower than feasibility tolerance"]
    pub fn SCIPisFeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than feasibility tolerance"]
    pub fn SCIPisFeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than feastol"]
    pub fn SCIPisFeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -feastol"]
    pub fn SCIPisFeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range feasibility tolerance of 0.0"]
    pub fn SCIPisFeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than feasibility tolerance"]
    pub fn SCIPisFeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -feasibility tolerance"]
    pub fn SCIPisFeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within the LP feasibility bounds"]
    pub fn SCIPisFeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than feastol"]
    pub fn SCIPisFeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + feasibility tolerance down to the next integer"]
    pub fn SCIPfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - feasibility tolerance up to the next integer"]
    pub fn SCIPfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in feasibility tolerance"]
    pub fn SCIPfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x)"]
    pub fn SCIPfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of dual feasibility tolerance"]
    pub fn SCIPisDualfeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference val1 and val2 is lower than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range dual feasibility tolerance of 0.0"]
    pub fn SCIPisDualfeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within the LP dual feasibility tolerance"]
    pub fn SCIPisDualfeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than dual feasibility tolerance"]
    pub fn SCIPisDualfeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + dual feasibility tolerance down to the next integer"]
    pub fn SCIPdualfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - dual feasibility tolerance up to the next integer"]
    pub fn SCIPdualfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in dual feasibility tolerance"]
    pub fn SCIPdualfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in dual feasibility tolerance"]
    pub fn SCIPdualfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if the given new lower bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisLbBetter(
        scip: *mut SCIP,
        newlb: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if the given new upper bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisUbBetter(
        scip: *mut SCIP,
        newub: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of epsilon"]
    pub fn SCIPisRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than epsilon"]
    pub fn SCIPisRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than epsilon"]
    pub fn SCIPisRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than epsilon"]
    pub fn SCIPisRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -epsilon"]
    pub fn SCIPisRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of sumepsilon"]
    pub fn SCIPisSumRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than sumepsilon"]
    pub fn SCIPisSumRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than sumepsilon"]
    pub fn SCIPisSumRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than sumepsilon"]
    pub fn SCIPisSumRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -sumepsilon"]
    pub fn SCIPisSumRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " converts the given real number representing an integer to an int; in optimized mode the function gets inlined for\n  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToInt(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts the given real number representing an integer to a long integer; in optimized mode the function gets inlined for\n  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToLongint(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " Checks if an iteratively updated value is reliable or should be recomputed from scratch.\n  This is useful, if the value, e.g., the activity of a linear constraint or the pseudo objective value, gets a high\n  absolute value during the optimization process which is later reduced significantly. In this case, the last digits\n  were canceled out when increasing the value and are random after decreasing it.\n  We do not consider the cancellations which can occur during increasing the absolute value because they just cannot\n  be expressed using fixed precision floating point arithmetic, anymore.\n  In order to get more reliable values, the idea is to always store the last reliable value, where increasing the\n  absolute of the value is viewed as preserving reliability. Then, after each update, the new absolute value can be\n  compared against the last reliable one with this method, checking whether it was decreased by a factor of at least\n  \"lp/recompfac\" and should be recomputed."]
    pub fn SCIPisUpdateUnreliable(
        scip: *mut SCIP,
        newvalue: f64,
        oldvalue: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " outputs a real number, or \"+infinity\", or \"-infinity\" to a file"]
    pub fn SCIPprintReal(
        scip: *mut SCIP,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " parse a real value that was written with SCIPprintReal()"]
    pub fn SCIPparseReal(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " parse a rational value"]
    pub fn SCIPparseRational(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        value: *mut SCIP_RATIONAL,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Bool parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_uint,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_uint,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a int parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_int,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_int,
        minvalue: ::std::os::raw::c_int,
        maxvalue: ::std::os::raw::c_int,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Longint parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_longlong,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_longlong,
        minvalue: ::std::os::raw::c_longlong,
        maxvalue: ::std::os::raw::c_longlong,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Real parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut f64,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: f64,
        minvalue: f64,
        maxvalue: f64,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a char parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_char,
        allowedvalues: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a string(char*) parameter, sets it to its default value, and adds it to the parameter set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the fixing status of an existing parameter\n\n  @return TRUE if the parameter is fixed to a value, otherwise FALSE."]
    pub fn SCIPisParamFixed(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the pointer to the SCIP parameter with the given name\n\n  @return pointer to the parameter with the given name"]
    pub fn SCIPgetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PARAM;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " fixes the value of an existing parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note: Be careful with this method! Some general settings, e.g., the time or node limit, should not be fixed because\n         they have to be changed for sub-SCIPs."]
    pub fn SCIPfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " unfixes the value of an existing parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPunfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBoolParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether the value of an existing SCIP_Bool parameter is valid"]
    pub fn SCIPisBoolParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgIntParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing int parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether the value of an existing int parameter is valid"]
    pub fn SCIPisIntParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgLongintParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Longint paramter is valid"]
    pub fn SCIPisLongintParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgRealParam(scip: *mut SCIP, param: *mut SCIP_PARAM, value: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Real paramter is valid"]
    pub fn SCIPisRealParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgCharParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing char parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether parameter value for a given SCIP_Real parameter is valid"]
    pub fn SCIPisCharParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgStringParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether parameter value for a given string parameter is valid"]
    pub fn SCIPisStringParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing parameter\n\n  The parameter type is checked and conversion of the given value to this type is attempted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads parameters from a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreadParams(scip: *mut SCIP, filename: *const ::std::os::raw::c_char)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes a single parameter to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes all parameters in the parameter set to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParams(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets a single parameter to its default value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets all parameters to their default values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParams(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets parameters to\n\n  - \\ref SCIP_PARAMEMPHASIS_DEFAULT to use default values (see also SCIPresetParams())\n  - \\ref SCIP_PARAMEMPHASIS_COUNTER to get feasible and \"fast\" counting process\n  - \\ref SCIP_PARAMEMPHASIS_CPSOLVER to get CP like search (e.g. no LP relaxation)\n  - \\ref SCIP_PARAMEMPHASIS_EASYCIP to solve easy problems fast\n  - \\ref SCIP_PARAMEMPHASIS_FEASIBILITY to detect feasibility fast\n  - \\ref SCIP_PARAMEMPHASIS_HARDLP to be capable to handle hard LPs\n  - \\ref SCIP_PARAMEMPHASIS_OPTIMALITY to prove optimality fast\n  - \\ref SCIP_PARAMEMPHASIS_PHASEFEAS to find feasible solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEIMPROVE to find improved solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEPROOF to proof optimality during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_NUMERICS to solve problems which cause numerical issues\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetEmphasis(
        scip: *mut SCIP,
        paramemphasis: SCIP_PARAMEMPHASIS,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets parameters to deactivate separators and heuristics that use auxiliary SCIP instances; should be called for\n  auxiliary SCIP instances to avoid recursion\n\n  @note only deactivates plugins which could cause recursion, some plugins which use sub-SCIPs stay activated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSubscipsOff(scip: *mut SCIP, quiet: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets heuristic parameters values to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all heuristic parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for heuristic is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the heuristic are called more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all heuristics\n\n  @note: Using SCIP_PARAMSETTING_AGGRESSIVE enables heuristics regardless of the USESSUBSCIP flag,\n         which could lead to unintended recursion when applied to a subscip.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetHeuristics(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving parameters to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all presolving parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for presolving is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the presolving is more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all presolving\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPresolving(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets separating parameters to\n\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all separating parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for separating is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the separating is done more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all separating\n\n  @note: Using SCIP_PARAMSETTING_AGGRESSIVE enables separators regardless of the USESSUBSCIP flag,\n         which could lead to unintended recursion when applied to a subscip.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSeparating(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the array of all available SCIP parameters\n\n  @return SCIP_PARAM* array, containing all SCIP parameters."]
    pub fn SCIPgetParams(scip: *mut SCIP) -> *mut *mut SCIP_PARAM;
}
unsafe extern "C" {
    #[doc = " returns the total number of all available SCIP parameters\n\n  @return number of all SCIP parameters."]
    pub fn SCIPgetNParams(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether plugins with sub-SCIPs that could cause recursion have been disabled\n\n  @return the value of the variable set->subscipsoff"]
    pub fn SCIPgetSubscipsOff(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates a presolver and includes it in SCIP\n\n  @note method has all presolver callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludePresolBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePresol(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Creates a presolver and includes it in SCIP with its fundamental callback. All non-fundamental (or optional)\n  callbacks as, e.g., init and exit callbacks, will be set to NULL. Optional callbacks can be set via specific setter\n  functions. These are SCIPsetPresolCopy(), SCIPsetPresolFree(), SCIPsetPresolInit(), SCIPsetPresolExit(),\n  SCIPsetPresolInitpre(), and SCIPsetPresolExitPre().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludePresol() instead"]
    pub fn SCIPincludePresolBasic(
        scip: *mut SCIP,
        presolptr: *mut *mut SCIP_PRESOL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of presolver"]
    pub fn SCIPsetPresolCopy(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of presolver"]
    pub fn SCIPsetPresolFree(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of presolver"]
    pub fn SCIPsetPresolInit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of presolver"]
    pub fn SCIPsetPresolExit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of presolver"]
    pub fn SCIPsetPresolInitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of presolver"]
    pub fn SCIPsetPresolExitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the presolver of the given name, or NULL if not existing"]
    pub fn SCIPfindPresol(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
    -> *mut SCIP_PRESOL;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available presolvers"]
    pub fn SCIPgetPresols(scip: *mut SCIP) -> *mut *mut SCIP_PRESOL;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available presolvers"]
    pub fn SCIPgetNPresols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a presolver"]
    pub fn SCIPsetPresolPriority(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of presolve rounds (current or last presolve)"]
    pub fn SCIPgetNPresolRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP\n  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all pricer callbacks as arguments and is thus changed every time a new callback is added\n        in future releases; consider using SCIPincludePricerBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePricer(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP with all non-fundamental callbacks set to NULL;\n  if needed, these can be added afterwards via setter functions SCIPsetPricerCopy(), SCIPsetPricerFree(),\n  SCIPsetPricerInity(), SCIPsetPricerExit(), SCIPsetPricerInitsol(), SCIPsetPricerExitsol(),\n  SCIPsetPricerFarkas();\n\n  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer().\n  This should be done during the problem creation stage.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludePricer() instead"]
    pub fn SCIPincludePricerBasic(
        scip: *mut SCIP,
        pricerptr: *mut *mut SCIP_PRICER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerCopy(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerFree(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the variable pricer of the given name, or NULL if not existing"]
    pub fn SCIPfindPricer(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
    -> *mut SCIP_PRICER;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available variable pricers; active pricers are in the first slots of the array"]
    pub fn SCIPgetPricers(scip: *mut SCIP) -> *mut *mut SCIP_PRICER;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available variable pricers"]
    pub fn SCIPgetNPricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of currently active variable pricers, that are used in the LP solving loop"]
    pub fn SCIPgetNActivePricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a variable pricer"]
    pub fn SCIPsetPricerPriority(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " activates pricer to be used for the current problem\n  This method should be called during the problem creation stage for all pricers that are necessary to solve\n  the problem model.\n  The pricers are automatically deactivated when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deactivates pricer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)\n  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls\n  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method, \\SCIP reaches the following stage:\n        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProb(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                original: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        probdata: *mut SCIP_PROBDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)\n  all callback methods will be set to NULL and can be set afterwards, if needed, via SCIPsetProbDelorig(),\n  SCIPsetProbTrans(), SCIPsetProbDeltrans(), SCIPsetProbInitsol(), SCIPsetProbExitsol(), and\n  SCIPsetProbCopy()\n  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls\n  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After calling this method, \\SCIP reaches the following stage:\n        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProbBasic(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets callback to free user data of original problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDelorig(
        scip: *mut SCIP,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets callback to create user data of transformed problem by transforming original user data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbTrans(
        scip: *mut SCIP,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets callback to free user data of transformed problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDeltrans(
        scip: *mut SCIP,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization callback of transformed data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbInitsol(
        scip: *mut SCIP,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization callback of transformed data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbExitsol(
        scip: *mut SCIP,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets callback to copy user data to a subscip\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbCopy(
        scip: *mut SCIP,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                original: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file and initializes all solving data structures\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @post After the method was called, \\SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT if reading failed (usually, when a SCIP_READERROR occurs)\n       - \\ref SCIP_STAGE_PROBLEM if the problem file was successfully read"]
    pub fn SCIPreadProb(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs original problem to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintOrigProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs transformed problem of the current node to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintTransProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes original problem to file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteOrigProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes transformed problem which are valid in the current node to file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note If you want the write all constraints (including the once which are redundant for example), you need to set\n        the parameter <write/allconss> to TRUE"]
    pub fn SCIPwriteTransProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees problem and solution process data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_FREE\n\n  @post After this method was called, SCIP is in the following stage:\n       - \\ref SCIP_STAGE_INIT"]
    pub fn SCIPfreeProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " permutes parts of the problem data structure\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n\n  @todo This need to be changed to use the new random number generator implemented in random.c"]
    pub fn SCIPpermuteProb(
        scip: *mut SCIP,
        randseed: ::std::os::raw::c_uint,
        permuteconss: ::std::os::raw::c_uint,
        permutebinvars: ::std::os::raw::c_uint,
        permuteintvars: ::std::os::raw::c_uint,
        permutebinimplvars: ::std::os::raw::c_uint,
        permuteintimplvars: ::std::os::raw::c_uint,
        permutecontimplvars: ::std::os::raw::c_uint,
        permutecontvars: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets user problem data\n\n  @return a SCIP_PROBDATA pointer, or NULL if no problem data was allocated\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbData(scip: *mut SCIP) -> *mut SCIP_PROBDATA;
}
unsafe extern "C" {
    #[doc = " sets user problem data\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbData(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns name of the current problem instance\n\n  @return name of the current problem instance\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbName(scip: *mut SCIP) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " sets name of the current problem instance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbName(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the objective function of the original problem.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVED\n\n  @note This method should be only used to change the objective function during two reoptimization runs and is only\n        recommended to an experienced user.\n\n  @note All variables not given in \\p vars array are assumed to have an objective coefficient of zero."]
    pub fn SCIPchgReoptObjective(
        scip: *mut SCIP,
        objsense: SCIP_OBJSENSE,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns objective sense of original problem\n\n  @return objective sense of original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetObjsense(scip: *mut SCIP) -> SCIP_OBJSENSE;
}
unsafe extern "C" {
    #[doc = " sets objective sense of problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetObjsense(scip: *mut SCIP, objsense: SCIP_OBJSENSE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds offset of objective function\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaddObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds offset of objective function to original problem and to all existing solution in original space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddOrigObjoffsetExact(scip: *mut SCIP, addval: *mut SCIP_RATIONAL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds offset of objective function to original problem and to all existing solution in original space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddOrigObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the objective offset of the original problem\n\n  @return the objective offset of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjoffset(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the exact objective offset of the original problem\n\n  DO NOT MODIFY THE POINTER RETURNED BY THIS METHOD\n\n  @return the exact objective offset of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjoffsetExact(scip: *mut SCIP) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the objective scale of the original problem\n\n  @return the objective scale of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjscale(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the objective offset of the transformed problem\n\n  @return the objective offset of the transformed problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjoffset(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the objective scale of the transformed problem\n\n  @return the objective scale of the transformed problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjscale(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets limit on objective function, such that only solutions better than this limit are accepted\n\n  @note SCIP will only look for solutions with a strictly better objective value, thus, e.g., prune\n        all branch-and-bound nodes with dual bound equal or worse to the objective limit.\n        However, SCIP will also collect solutions with objective value worse than the objective limit and\n        use them to run improvement heuristics on them.\n  @note If SCIP can prove that there exists no solution with a strictly better objective value, the solving status\n        will normally be infeasible (the objective limit is interpreted as part of the problem).\n        The only exception is that by chance, SCIP found a solution with the same objective value and thus\n        proved the optimality of this solution, resulting in solution status optimal.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetObjlimit(scip: *mut SCIP, objlimit: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns current limit on objective function\n\n  @return the current objective limit of the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetObjlimit(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " informs SCIP, that the objective value is always integral in every feasible solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This function should be used to inform SCIP that the objective function is integral, helping to improve the\n        performance. This is useful when using column generation. If no column generation (pricing) is used, SCIP\n        automatically detects whether the objective function is integral or can be scaled to be integral. However, in\n        any case, the user has to make sure that no variable is added during the solving process that destroys this\n        property."]
    pub fn SCIPsetObjIntegral(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the objective value is known to be integral in every feasible solution\n\n  @return TRUE, if objective value is known to be always integral, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note If no pricing is performed, SCIP automatically detects whether the objective function is integral or can be\n        scaled to be integral, helping to improve performance. This function returns the result. Otherwise\n        SCIPsetObjIntegral() can be used to inform SCIP. However, in any case, the user has to make sure that no\n        variable is added during the solving process that destroys this property."]
    pub fn SCIPisObjIntegral(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the Euclidean norm of the objective function vector (available only for transformed problem)\n\n  @return the Euclidean norm of the transformed objective function vector\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetObjNorm(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " adds variable to the problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variable to the problem and uses it as pricing candidate to enter the LP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPricedVar(scip: *mut SCIP, var: *mut SCIP_VAR, score: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes variable from the problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @warning The variable is not deleted from the constraints when in SCIP_STAGE_PROBLEM.  In this stage, it is the\n           user's responsibility to ensure the variable has been removed from all constraints or the constraints\n           deleted.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @warning The variable is not deleted from the constraints when in SCIP_STAGE_PROBLEM.  In this stage, it is the\n           user's responsibility to ensure the variable has been removed from all constraints or the constraints\n           deleted."]
    pub fn SCIPdelVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        deleted: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets variables of the problem along with the numbers of different variable types; data may become invalid after\n  calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets array with active problem variables\n\n  @return array with active problem variables\n\n  @note Variables in the array are grouped in following order:\n        - binaries\n        - integers\n        - implied integral binaries\n        - implied integral integers\n        - implied integral continuous\n        - continuous\n\n  @warning Modifying a variable status (e.g. with SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar())\n           or a variable type (e.g. with SCIPchgVarType() and SCIPchgVarImplType())\n           may invalidate or resort the data array.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets number of active problem variables\n\n  @return the number of active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary active problem variables\n\n  @return the number of binary active problem variables\n\n  @note This function does not count binary variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integer active problem variables\n\n  @return the number of integer active problem variables\n\n  @note This function does not count integer variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of implied integral active problem variables\n\n  @return the number of implied integral active problem variables\n\n  @note This function counts binary, integer, and continuous variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary implied integral active problem variables\n\n  @return the number of binary implied integral active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBinImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integer implied integral active problem variables\n\n  @return the number of integer implied integral active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNIntImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of continuous implied integral active problem variables\n\n  @return the number of continuous implied integral active problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNContImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of continuous active problem variables\n\n  @return the number of continuous active problem variables\n\n  @note This function does not count continuous variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of active problem variables with a non-zero objective coefficient\n\n  @note In case of the original problem the number of variables is counted. In case of the transformed problem the\n        number of variables is just returned since it is stored internally\n\n  @return the number of active problem variables with a non-zero objective coefficient\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNObjVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with fixed and aggregated problem variables; data may become invalid after\n  calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @return an array with fixed and aggregated problem variables; data may become invalid after\n          calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFixedVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets number of fixed or aggregated problem variables\n\n  @return the number of fixed or aggregated problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNFixedVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets variables of the original problem along with the numbers of different variable types; data may become invalid\n  after a call to SCIPchgVarType()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets array with original problem variables\n\n  @return array with original problem variables\n\n  @note Variables in the array are grouped in following order:\n        - binaries\n        - integers\n        - implied integral binaries\n        - implied integral integers\n        - implied integral continuous\n        - continuous\n\n  @warning Modifying the variable number (e.g. with SCIPaddVar() and SCIPdelVar())\n           or a variable type (e.g. with SCIPchgVarType() and SCIPchgVarImplType())\n           may invalidate or resort the data array.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets number of original problem variables\n\n  @return the number of original problem variables\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary variables in the original problem\n\n  @return the number of binary variables in the original problem\n\n  @note This function does not count binary variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of integer variables in the original problem\n\n  @return the number of integer variables in the original problem\n\n  @note This function does not count integer variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of implied integral variables in the original problem\n\n  @return the number of implied integral variables in the original problem\n\n  @note This function counts binary, integer, and continuous variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of binary implied integral variables in the original problem\n\n  @return the number of binary implied integral variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigBinImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integer implied integral variables in the original problem\n\n  @return the number of integer implied integral variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigIntImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of continuous implied integral variables in the original problem\n\n  @return the number of continuous implied integral variables in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigContImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of continuous variables in the original problem\n\n  @return the number of continuous variables in the original problem\n\n  @note This function does not count continuous variables which are implied integral.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of all problem variables created during creation and solving of problem;\n  this includes also variables that were deleted in the meantime\n\n  @return the number of all problem variables created during creation and solving of problem;\n          this includes also variables that were deleted in the meantime\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets variables of the original or transformed problem along with the numbers of different variable types;\n  the returned problem space (original or transformed) corresponds to the given solution;\n  data may become invalid after calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and\n  SCIPmultiaggregateVar()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetSolVarsData(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nbinimplvars: *mut ::std::os::raw::c_int,
        nintimplvars: *mut ::std::os::raw::c_int,
        ncontimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns variable of given name in the problem, or NULL if not existing\n\n  @return variable of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindVar(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns TRUE iff all potential variables exist in the problem, and FALSE, if there may be additional variables,\n  that will be added in pricing and improve the objective value\n\n  @return TRUE, if all potential variables exist in the problem; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPallVarsInProb(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " adds constraint to the problem; if constraint is only valid locally, it is added to the local subproblem of the\n  current node (and all of its subnodes); otherwise it is added to the global problem;\n  if a local constraint is added at the root node, it is automatically upgraded into a global constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPaddCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds constraint to the problem and upgrades conflict in the conflict store; if oldcons is valid globally, newcons\n  is added to the global problem; otherwise it is added to the local subproblem of the current node\n\n  @note must only be called once for both constraints\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note this method will release the upgraded constraint"]
    pub fn SCIPaddConsUpgrade(
        scip: *mut SCIP,
        oldcons: *mut SCIP_CONS,
        newcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " globally removes constraint from all subproblems; removes constraint from the constraint set change data of the\n  node, where it was added, or from the problem, if it was a problem constraint\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns original constraint of given name in the problem, or NULL if not existing\n\n  @return original constraint of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindOrigCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
    -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " returns constraint of given name in the problem, or NULL if not existing\n\n  @return constraint of given name in the problem, or NULL if not existing\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets number of upgraded constraints\n\n  @return number of upgraded constraints\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNUpgrConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets total number of globally valid constraints currently in the problem\n\n  @return total number of globally valid constraints currently in the problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of globally valid constraints currently in the problem\n\n  @return array of globally valid constraints currently in the problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @warning If your are using the method SCIPaddCons(), it can happen that the internal constraint array (which is\n           accessed via this method) gets resized. This can invalid the pointer which is returned by this method."]
    pub fn SCIPgetConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets total number of constraints in the original problem\n\n  @return total number of constraints in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of constraints in the original problem\n\n  @return array of constraints in the original problem\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " computes the number of check constraint in the current node (loop over all constraint handler and cumulates the\n  number of check constraints)\n\n  @return returns the number of check constraints\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNCheckConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " adds a conflict to a given node or globally to the problem if @p node == NULL.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note this method will release the constraint"]
    pub fn SCIPaddConflict(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to remove conflicts depending on an old cutoff bound if the improvement of the new incumbent is good enough\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearConflictStore(scip: *mut SCIP, event: *mut SCIP_EVENT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds constraint to the given node (and all of its subnodes), even if it is a global constraint;\n  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if\n  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is\n  only active in a small part of the tree although it is valid in a larger part.\n  In this case, one should pass the more global node where the constraint is valid as \"validnode\".\n  Note that the same constraint cannot be added twice to the branching tree with different \"validnode\" parameters.\n  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\".\n  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to\n  the given node. If a local constraint is added to the root node, it is added to the global problem instead.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds constraint locally to the current node (and all of its subnodes), even if it is a global constraint;\n  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if\n  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is\n  only active in a small part of the tree although it is valid in a larger part.\n\n  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\".\n  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to\n  the given node. If a local constraint is added to the root node, it is added to the global problem instead.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The same constraint cannot be added twice to the branching tree with different \"validnode\" parameters. This is\n        the case due to internal data structures and performance issues. In such a case you should try to realize your\n        issue using the method SCIPdisableCons() and SCIPenableCons() and control these via the event system of SCIP."]
    pub fn SCIPaddConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the given node (and all subnodes);\n  if the method is called at the root node, the constraint is globally deleted from the problem;\n  the constraint deletion is being remembered at the given node, s.t. after leaving the node's subtree, the constraint\n  is automatically enabled again, and after entering the node's subtree, it is automatically disabled;\n  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;\n  alternatively, use SCIPdisableCons()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the current node (and all subnodes);\n  if the method is called during problem modification or at the root node, the constraint is globally deleted from\n  the problem;\n  the constraint deletion is being remembered at the current node, s.t. after leaving the current subtree, the\n  constraint is automatically enabled again, and after reentering the current node's subtree, it is automatically\n  disabled again;\n  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;\n  alternatively, use SCIPdisableCons()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note SCIP stage does not get changed\n"]
    pub fn SCIPdelConsLocal(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. original problem contained in current subtree\n\n  @return estimate of best primal solution w.r.t. original problem contained in current subtree\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalOrigEstimate(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. transformed problem contained in current subtree\n\n  @return estimate of best primal solution w.r.t. transformed problem contained in current subtree\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalTransEstimate(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets dual bound of current node\n\n  @return dual bound of current node\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalDualbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lower bound of current node in transformed problem\n\n  @return lower bound  of current node in transformed problem\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalLowerbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets dual bound of given node\n\n  @return dual bound of a given node\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeDualbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lower bound of given node in transformed problem\n\n  @return lower bound  of given node in transformed problem\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeLowerbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
unsafe extern "C" {
    #[doc = " if given value is tighter (larger for minimization, smaller for maximization) than the current node's dual bound (in\n  original problem space), sets the current node's dual bound to the new value\n\n  @note the given new bound has to be a dual bound, i.e., it has to be valid for the original problem.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalDualbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if given value is larger than the current node's lower bound (in transformed problem), sets the current node's\n  lower bound to the new value\n\n  @note the given new bound has to be a lower bound, i.e., it has to be valid for the transformed problem.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalLowerbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if given value is tighter (higher for minimization, lower for maximization) than the node's dual bound, sets the\n  node's dual bound to the new value.\n\n  @note must not be used on a leaf because the node priority queue remains untouched\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeDualbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if given value is higher than the node's lower bound (in transformed problem), sets the node's lower bound to the\n  new value.\n\n  @note must not be used on a leaf because the node priority queue remains untouched\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeLowerbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change the node selection priority of the given child\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgChildPrio(scip: *mut SCIP, child: *mut SCIP_NODE, priority: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether we are in probing mode; probing mode is activated via SCIPstartProbing() and stopped\n  via SCIPendProbing()\n\n  @return TRUE, if SCIP is currently in probing mode, otherwise FALSE\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPinProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " initiates probing, making methods SCIPnewProbingNode(), SCIPbacktrackProbing(), SCIPchgVarLbProbing(),\n  SCIPchgVarUbProbing(), SCIPfixVarProbing(), SCIPpropagateProbing(), and SCIPsolveProbingLP() available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The collection of variable statistics is turned off during probing. If these statistics should be collected\n        during probing use the method SCIPenableVarHistory() to turn the collection explicitly on."]
    pub fn SCIPstartProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a new probing sub node, whose changes can be undone by backtracking to a higher node in the probing path\n  with a call to SCIPbacktrackProbing();\n  using a sub node for each set of probing bound changes can improve conflict analysis\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPnewProbingNode(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the current probing depth\n\n  @return the probing depth, i.e. the number of probing sub nodes existing in the probing path\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetProbingDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " undoes all changes to the problem applied in probing up to the given probing depth;\n  the changes of the probing node of the given probing depth are the last ones that remain active;\n  changes that were applied before calling SCIPnewProbingNode() cannot be undone\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPbacktrackProbing(
        scip: *mut SCIP,
        probingdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " quits probing and resets bounds and constraints to the focus node's environment\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " injects a change of variable's lower bound into current probing node; the same can also be achieved with a call to\n  SCIPchgVarLb(), but in this case, the bound change would be treated like a deduction instead of a branching decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " injects a change of variable's upper bound into current probing node; the same can also be achieved with a call to\n  SCIPchgVarUb(), but in this case, the bound change would be treated like a deduction instead of a branching decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets variable's objective value in current probing\n\n  @return the variable's objective value in current probing.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " injects a change of variable's bounds into current probing node to fix the variable to the specified value;\n  the same can also be achieved with a call to SCIPfixVar(), but in this case, the bound changes would be treated\n  like deductions instead of branching decisions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVarProbing(scip: *mut SCIP, var: *mut SCIP_VAR, fixedval: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes (column) variable's objective value during probing mode\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @pre The variable needs to be a column variable."]
    pub fn SCIPchgVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the objective function has changed during probing mode\n\n  @return \\ref TRUE if objective has changed, \\ref FALSE otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisObjChangedProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;\n  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()\n  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed\n  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbing(
        scip: *mut SCIP,
        maxproprounds: ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
        ndomredsfound: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;\n  only propagations of the binary variables fixed at the current probing node that are triggered by the implication\n  graph and the clique table are applied;\n  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()\n  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed\n  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbingImplications(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage);\n  no separation or pricing is applied\n\n  The LP has to be constructed before (you can use SCIPisLPConstructed() or SCIPconstructLP()).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage) and applies pricing\n  until the LP is solved to optimality; no separation is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed . See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLPWithPricing(
        scip: *mut SCIP,
        pretendroot: ::std::os::raw::c_uint,
        displayinfo: ::std::os::raw::c_uint,
        maxpricerounds: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the LP state for the current probing node\n\n  @note state and norms are stored at the node and later released by SCIP; therefore, the pointers are set\n        to NULL by the method\n\n  @note the pointers to state and norms must not be NULL; however, they may point to a NULL pointer if the\n        respective information should not be set\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetProbingLPState(
        scip: *mut SCIP,
        lpistate: *mut *mut SCIP_LPISTATE,
        lpinorms: *mut *mut SCIP_LPINORMS,
        primalfeas: ::std::os::raw::c_uint,
        dualfeas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a row to the LP in the current probing node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowProbing(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " applies the cuts in the separation storage to the LP and clears the storage afterwards;\n  this method can only be applied during probing; the user should resolve the probing LP afterwards\n  in order to get a new solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyCutsProbing(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves relaxation(s) at the current probing node (cannot be applied at preprocessing stage);\n  no separation or pricing is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingRelax(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print statistics of probing"]
    pub fn SCIPsnprintfProbingStats(
        scip: *mut SCIP,
        strbuf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " stores the candidate score and preferred rounding direction for a candidate variable"]
    pub fn SCIPgetDivesetScore(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
        divecand: *mut SCIP_VAR,
        divecandsol: f64,
        divecandfrac: f64,
        candscore: *mut f64,
        roundup: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " update diveset LP statistics, should be called after every LP solved by this diving heuristic"]
    pub fn SCIPupdateDivesetLPStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        niterstoadd: ::std::os::raw::c_longlong,
        divecontext: SCIP_DIVECONTEXT,
    );
}
unsafe extern "C" {
    #[doc = " update diveset statistics and global diveset statistics"]
    pub fn SCIPupdateDivesetStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        nprobingnodes: ::std::os::raw::c_int,
        nbacktracks: ::std::os::raw::c_int,
        nsolsfound: ::std::os::raw::c_longlong,
        nbestsolsfound: ::std::os::raw::c_longlong,
        nconflictsfound: ::std::os::raw::c_longlong,
        leavewassol: ::std::os::raw::c_uint,
        divecontext: SCIP_DIVECONTEXT,
    );
}
unsafe extern "C" {
    #[doc = " enforces a probing/diving solution by suggesting bound changes that maximize the score w.r.t. the current diving settings\n\n  the process is guided by the enforcement priorities of the constraint handlers and the scoring mechanism provided by\n  the dive set.\n  Constraint handlers may suggest diving bound changes in decreasing order of their enforcement priority, based on the\n  solution values in the solution @p sol and the current local bounds of the variables. A diving bound change\n  is a triple (variable,branching direction,value) and is used inside SCIPperformGenericDivingAlgorithm().\n\n  After a successful call, SCIP holds two arrays of suggested dive bound changes, one for the preferred child\n  and one for the alternative.\n\n  @see SCIPgetDiveBoundChangeData() for retrieving the dive bound change suggestions.\n\n  The method stops after the first constraint handler was successful\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChanges(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a diving bound change to the diving bound change storage of SCIP together with the information if this is a\n  bound change for the preferred direction or not\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddDiveBoundChange(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        value: f64,
        preferred: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get the dive bound change data for the preferred or the alternative direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChangeData(
        scip: *mut SCIP,
        variables: *mut *mut *mut SCIP_VAR,
        directions: *mut *mut SCIP_BRANCHDIR,
        values: *mut *mut f64,
        ndivebdchgs: *mut ::std::os::raw::c_int,
        preferred: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " clear the dive bound change data structures\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearDiveBoundChanges(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " creates a propagator and includes it in SCIP.\n\n\n  @note method has all propagator callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludePropBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeProp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a propagator and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetPropInit(), SCIPsetPropExit(),\n  SCIPsetPropCopy(), SCIPsetPropFree(), SCIPsetPropInitsol(), SCIPsetPropExitsol(),\n  SCIPsetPropInitpre(), SCIPsetPropExitpre(), SCIPsetPropPresol(), and SCIPsetPropResprop().\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeProp() instead"]
    pub fn SCIPincludePropBasic(
        scip: *mut SCIP,
        propptr: *mut *mut SCIP_PROP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of propagator"]
    pub fn SCIPsetPropCopy(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of propagator"]
    pub fn SCIPsetPropFree(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of propagator"]
    pub fn SCIPsetPropInit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of propagator"]
    pub fn SCIPsetPropExit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of propagator"]
    pub fn SCIPsetPropInitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of propagator"]
    pub fn SCIPsetPropExitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets preprocessing initialization method of propagator"]
    pub fn SCIPsetPropInitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets preprocessing deinitialization method of propagator"]
    pub fn SCIPsetPropExitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving method of propagator"]
    pub fn SCIPsetPropPresol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets propagation conflict resolving callback of propagator"]
    pub fn SCIPsetPropResprop(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the propagator of the given name, or NULL if not existing"]
    pub fn SCIPfindProp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PROP;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available propagators"]
    pub fn SCIPgetProps(scip: *mut SCIP) -> *mut *mut SCIP_PROP;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available propagators"]
    pub fn SCIPgetNProps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a propagator"]
    pub fn SCIPsetPropPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the presolving priority of a propagator"]
    pub fn SCIPsetPropPresolPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        presolpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and initializes a random number generator\n\n  @note The initial seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPcreateRandom(
        scip: *mut SCIP,
        randnumgen: *mut *mut SCIP_RANDNUMGEN,
        initialseed: ::std::os::raw::c_uint,
        useglobalseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a random number generator"]
    pub fn SCIPfreeRandom(scip: *mut SCIP, randnumgen: *mut *mut SCIP_RANDNUMGEN);
}
unsafe extern "C" {
    #[doc = " initializes a random number generator with a given seed\n\n  @note The seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPsetRandomSeed(
        scip: *mut SCIP,
        randnumgen: *mut SCIP_RANDNUMGEN,
        seed: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " modifies an initial seed value with the global shift of random seeds"]
    pub fn SCIPinitializeRandomSeed(
        scip: *mut SCIP,
        initialseedvalue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates a reader and includes it in SCIP\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note method has all reader callbacks as arguments and is thus changed every time a new callback is added\n        in future releases; consider using SCIPincludeReaderBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeReader(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                filename: *const ::std::os::raw::c_char,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objoffset: f64,
                objscale: f64,
                objoffsetexact: *mut SCIP_RATIONAL,
                objscaleexact: *mut SCIP_RATIONAL,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a reader and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see\n  SCIPsetReaderCopy(), SCIPsetReaderFree(), SCIPsetReaderRead(), SCIPsetReaderWrite().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeReader() instead"]
    pub fn SCIPincludeReaderBasic(
        scip: *mut SCIP,
        readerptr: *mut *mut SCIP_READER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set copy method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderCopy(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set deinitialization method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderFree(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set read method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderRead(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set write method of reader\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderWrite(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                filename: *const ::std::os::raw::c_char,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objoffset: f64,
                objscale: f64,
                objoffsetexact: *mut SCIP_RATIONAL,
                objscaleexact: *mut SCIP_RATIONAL,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the reader of the given name, or NULL if not existing"]
    pub fn SCIPfindReader(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
    -> *mut SCIP_READER;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available readers"]
    pub fn SCIPgetReaders(scip: *mut SCIP) -> *mut *mut SCIP_READER;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available readers"]
    pub fn SCIPgetNReaders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP\n\n  @note method has all relaxation handler callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeRelaxBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeRelax(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP. All non fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetRelaxInit(), SCIPsetRelaxExit(),\n  SCIPsetRelaxCopy(), SCIPsetRelaxFree(), SCIPsetRelaxInitsol(), and SCIPsetRelaxExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeRelax() instead"]
    pub fn SCIPincludeRelaxBasic(
        scip: *mut SCIP,
        relaxptr: *mut *mut SCIP_RELAX,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of relaxation handler"]
    pub fn SCIPsetRelaxCopy(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of relaxation handler"]
    pub fn SCIPsetRelaxFree(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the relaxation handler of the given name, or NULL if not existing"]
    pub fn SCIPfindRelax(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_RELAX;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available relaxation handlers"]
    pub fn SCIPgetRelaxs(scip: *mut SCIP) -> *mut *mut SCIP_RELAX;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available relaxation handlers"]
    pub fn SCIPgetNRelaxs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a relaxation handler"]
    pub fn SCIPsetRelaxPriority(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the ids of child nodes stored in the reoptimization tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptChildIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        idssize: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the ids of all leave nodes store in the reoptimization tree induced by the given node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptLeaveIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        idssize: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes in the reoptimization tree induced by @p node; if @p node == NULL, the method\n  returns the number of nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptnodes(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of leave nodes of the subtree induced by @p node; if @p node == NULL, the method\n  returns the number of leaf nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptLeaves(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the node of the reoptimization tree corresponding to the unique @p id"]
    pub fn SCIPgetReoptnode(scip: *mut SCIP, id: ::std::os::raw::c_uint) -> *mut SCIP_REOPTNODE;
}
unsafe extern "C" {
    #[doc = " add a variable bound change to a given reoptnode\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptnodeBndchg(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        var: *mut SCIP_VAR,
        bound: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set the @p representation as the new search frontier\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPsetReoptCompression(
        scip: *mut SCIP,
        representation: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add stored constraint to a reoptimization node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddReoptnodeCons(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
        constype: REOPT_CONSTYPE,
        linear: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the branching path stored in the reoptree at ID id"]
    pub fn SCIPgetReoptnodePath(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
        nafterdualvars: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " initialize a set of empty reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPinitRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reset a set of initialized reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPresetRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " free a set of initialized reoptimization nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPfreeRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reactivate the given @p reoptnode and split them into several nodes if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPapplyReopt(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        id: ::std::os::raw::c_uint,
        estimate: f64,
        childnodes: *mut *mut SCIP_NODE,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
        childnodessize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " remove the stored information about bound changes based in dual information\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetReoptnodeDualcons(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " splits the root into several nodes and moves the child nodes of the root to one of the created nodes\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsplitReoptRoot(
        scip: *mut SCIP,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns if a node should be reoptimized"]
    pub fn SCIPreoptimizeNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " deletes the given reoptimization node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdeleteReoptnode(
        scip: *mut SCIP,
        reoptnode: *mut *mut SCIP_REOPTNODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the similarity between two objective functions"]
    pub fn SCIPgetReoptSimilarity(
        scip: *mut SCIP,
        run1: ::std::os::raw::c_int,
        run2: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a separator and includes it in SCIP.\n\n  @note method has all separator callbacks as arguments and is thus changed every time a new\n        callback is added\n        in future releases; consider using SCIPincludeSepaBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeSepa(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a separator and includes it in SCIP with its most fundamental callbacks. All non-fundamental\n  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL.\n  Optional callbacks can be set via specific setter functions, see SCIPsetSepaInit(), SCIPsetSepaFree(),\n  SCIPsetSepaInitsol(), SCIPsetSepaExitsol(), SCIPsetSepaCopy(), SCIPsetExit().\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeSepa() instead"]
    pub fn SCIPincludeSepaBasic(
        scip: *mut SCIP,
        sepa: *mut *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
                depth: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of separator"]
    pub fn SCIPsetSepaCopy(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of separator"]
    pub fn SCIPsetSepaFree(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of separator"]
    pub fn SCIPsetSepaInit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of separator"]
    pub fn SCIPsetSepaExit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of separator"]
    pub fn SCIPsetSepaInitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of separator"]
    pub fn SCIPsetSepaExitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the separator of the given name, or NULL if not existing"]
    pub fn SCIPfindSepa(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_SEPA;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available separators"]
    pub fn SCIPgetSepas(scip: *mut SCIP) -> *mut *mut SCIP_SEPA;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available separators"]
    pub fn SCIPgetNSepas(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a separator"]
    pub fn SCIPsetSepaPriority(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " declares separator to be a parent separator\n\n  Parent separators generate cuts of several types. To distinguish these cuts, they create child separators, which are\n  only needed to detect which cuts are applied."]
    pub fn SCIPsetSepaIsParentsepa(scip: *mut SCIP, sepa: *mut SCIP_SEPA);
}
unsafe extern "C" {
    #[doc = " sets the parent separator\n\n  Informs SCIP that the separator @p sepa depends on the parent separator @p parentsepa."]
    pub fn SCIPsetSepaParentsepa(scip: *mut SCIP, sepa: *mut SCIP_SEPA, parentsepa: *mut SCIP_SEPA);
}
unsafe extern "C" {
    #[doc = " gets value of minimal efficacy for a cut to enter the LP\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @return value of \"separating/minefficacyroot\" if at root node, otherwise value of \"separating/minefficacy\""]
    pub fn SCIPgetSepaMinEfficacy(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a cut selector and includes it in SCIP\n\n  @note this method has all cut selector callbacks as arguments and is thus changed every time a new\n        callback is added in future releases; consider using SCIPincludeCutselBasic() and setter functions\n        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeCutsel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
        cutselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cutsel: *mut SCIP_CUTSEL,
                cuts: *mut *mut SCIP_ROW,
                ncuts: ::std::os::raw::c_int,
                forcedcuts: *mut *mut SCIP_ROW,
                nforcedcuts: ::std::os::raw::c_int,
                root: ::std::os::raw::c_uint,
                maxnselectedcuts: ::std::os::raw::c_int,
                nselectedcuts: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        cutseldata: *mut SCIP_CUTSELDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Creates a cut selector and includes it in SCIP with its most fundamental callbacks.\n\n  All non-fundamental (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL. Optional\n  callbacks can be set via specific setter functions, see SCIPsetCutselCopy(), SCIPsetCutselFree(),\n  SCIPsetCutselInit(), SCIPsetCutselExit(), SCIPsetCutselInitsol(), and SCIPsetCutselExitsol()\n\n  @note if you want to set all callbacks with a single method call, consider using SCIPincludeCutsel() instead"]
    pub fn SCIPincludeCutselBasic(
        scip: *mut SCIP,
        cutsel: *mut *mut SCIP_CUTSEL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cutsel: *mut SCIP_CUTSEL,
                cuts: *mut *mut SCIP_ROW,
                ncuts: ::std::os::raw::c_int,
                forcedcuts: *mut *mut SCIP_ROW,
                nforcedcuts: ::std::os::raw::c_int,
                root: ::std::os::raw::c_uint,
                maxnselectedcuts: ::std::os::raw::c_int,
                nselectedcuts: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        cutseldata: *mut SCIP_CUTSELDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets copy method of cut selector"]
    pub fn SCIPsetCutselCopy(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets destructor method of cut selector"]
    pub fn SCIPsetCutselFree(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets initialization method of cut selector"]
    pub fn SCIPsetCutselInit(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of cut selector"]
    pub fn SCIPsetCutselExit(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of cut selector"]
    pub fn SCIPsetCutselInitsol(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of cut selector"]
    pub fn SCIPsetCutselExitsol(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        cutselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the cut selector of the given name, or NULL if not existing"]
    pub fn SCIPfindCutsel(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
    -> *mut SCIP_CUTSEL;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available cut selectors"]
    pub fn SCIPgetCutsels(scip: *mut SCIP) -> *mut *mut SCIP_CUTSEL;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available cut selectors"]
    pub fn SCIPgetNCutsels(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the priority of a cut selector"]
    pub fn SCIPsetCutselPriority(
        scip: *mut SCIP,
        cutsel: *mut SCIP_CUTSEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to zero\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an exact primal solution, initialized to zero\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSolExact(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an exact primal solution, initialized to the current exact LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateLPSolExact(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to the current NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to the current relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRelaxSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreatePseudoSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP or pseudo solution, depending on whether the LP was solved\n  at the current node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCurrentSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a partial primal solution, initialized to unknown values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreatePartialSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution, initialized to unknown values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateUnknownSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a primal solution living in the original problem space, initialized to zero;\n  a solution in original space allows to set original variables to values that would be invalid in the\n  transformed problem due to preprocessing fixings or aggregations\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateOrigSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a primal solution; note that a copy of a linked solution is also linked and needs to be unlinked\n  if it should stay unaffected from changes in the LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a solution in the original primal solution space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcreateSolCopyOrig(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a primal solution, thereby replacing infinite fixings of variables by finite values;\n  the copy is always defined in the original variable space;\n  success indicates whether the objective value of the solution was changed by removing infinite values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcreateFiniteSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeSol(scip: *mut SCIP, sol: *mut *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current exact LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkLPSolExact(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current NLP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkNLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current relaxation solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkRelaxSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkPseudoSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " links a primal solution to the current LP or pseudo solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkCurrentSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears a primal solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPclearSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores solution values of variables in solution's own array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlinkSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores exact solution values of variables in solution's own array\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlinkSolExact(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets value of variable in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets exact value of variable in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolValExact(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets values of multiple variables in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of variable in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPincSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        incval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns value of variable in primal CIP solution, or in current LP/pseudo solution\n\n  @return value of variable in primal CIP solution, or in current LP/pseudo solution\n\n  @pre In case the solution pointer @p sol is @b NULL, that means it is asked for the LP or pseudo solution, this method\n       can only be called if @p scip is in the solving stage \\ref SCIP_STAGE_SOLVING. In any other case, this method\n       can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVal(scip: *mut SCIP, sol: *mut SCIP_SOL, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets value of variable in primal CIP solution, or in current LP/pseudo solution\n\n  @pre In case the solution pointer @p sol is @b NULL, that means it is asked for the LP or pseudo solution, this method\n       can only be called if @p scip is in the solving stage \\ref SCIP_STAGE_SOLVING. In any other case, this method\n       can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolValExact(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        res: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " gets values of multiple variables in primal CIP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value\n\n  @return objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolOrigObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets exact objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolOrigObjExact(scip: *mut SCIP, sol: *mut SCIP_SOL, res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " returns transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value\n\n  @return transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTransObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTransObjExact(scip: *mut SCIP, sol: *mut SCIP_SOL, res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " recomputes the objective value of an original solution, e.g., when transferring solutions\n  from the solution pool (objective coefficients might have changed in the meantime)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n"]
    pub fn SCIPrecomputeSolObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " maps original space objective value into transformed objective value\n\n  @return transformed objective value\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPtransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " maps transformed objective value into original space\n\n  @return objective value into original space\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPretransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets clock time, when this solution was found\n\n  @return clock time, when this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTime(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found\n\n  @return branch and bound run number, where this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolRunnum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found\n\n  @return node number of the specific branch and bound run, where this solution was found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolNodenum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets heuristic, that found this solution (or NULL if it's from the tree)\n\n  @return heuristic, that found this solution (or NULL if it's from the tree)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolHeur(scip: *mut SCIP, sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " returns whether two given solutions are exactly equal\n\n  @return returns whether two given solutions are exactly equal\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPareSolsEqual(
        scip: *mut SCIP,
        sol1: *mut SCIP_SOL,
        sol2: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " adjusts solution values of implied integral variables in handed solution, solution objective value is not\n  deteriorated by this method\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPadjustImplicitSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs non-zero variables of solution in original problem space to the given file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre In case the solution pointer @p sol is NULL (askinking for the current LP/pseudo solution), this method can be\n       called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @pre In case the solution pointer @p sol is @b not NULL, this method can be called if @p scip is in one of the\n       following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print a rational solution"]
    pub fn SCIPprintSolExact(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs non-zero variables of solution in transformed problem space to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintTransSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs discrete variables of solution in original problem space to the given file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintMIPStart(scip: *mut SCIP, sol: *mut SCIP_SOL, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns dual solution value of a constraint"]
    pub fn SCIPgetDualSolVal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsolval: *mut f64,
        boundconstraint: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " check whether the dual solution is available\n\n @note This is used when calling \\ref SCIPprintDualSol()\n\n @return is dual solution available?\n\n @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPisDualSolAvailable(
        scip: *mut SCIP,
        printreason: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " outputs dual solution from LP solver to file stream\n\n  @note This only works if no presolving has been performed, which can be checked by calling method \\ref\n        SCIPhasPerformedPresolve().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintDualSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs non-zero variables of solution representing a ray in original problem space to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRay(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of feasible primal solutions stored in the solution storage in case the problem is transformed;\n  in case the problem stage is SCIP_STAGE_PROBLEM, the number of solution in the original solution candidate\n  storage is returned\n\n  @return number of feasible primal solutions stored in the solution storage in case the problem is transformed; or\n          number of solution in the original solution candidate storage if the problem stage is SCIP_STAGE_PROBLEM\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of feasible primal solutions stored in the solution storage in case the problem is transformed; in case\n  if the problem stage is in SCIP_STAGE_PROBLEM, it returns the number array of solution candidate stored\n\n  @return array of feasible primal solutions\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " gets best feasible primal solution found so far if the problem is transformed; in case the problem is in\n  SCIP_STAGE_PROBLEM it returns the best solution candidate, or NULL if no solution has been found or the candidate\n  store is empty;\n\n  @return best feasible primal solution so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBestSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " outputs best feasible primal solution found so far to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREE"]
    pub fn SCIPprintBestSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs best feasible primal solution found so far in transformed variables to file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintBestTransSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " try to round given solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIProundSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copy the fp values to the exact arrays of the solution"]
    pub fn SCIPmakeSolExact(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retransforms solution to original problem space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPretransformSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retransforms exact solution to original problem space\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPretransformSolExact(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads a given solution file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSol(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads a given solution file and store the solution values in the given solution pointer\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSolFile(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        sol: *mut SCIP_SOL,
        xml: ::std::os::raw::c_uint,
        partial: *mut ::std::os::raw::c_uint,
        error: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds feasible primal solution to solution storage by copying it\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds primal solution to solution storage, frees the solution afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds current LP/pseudo solution to solution storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks solution for feasibility; if possible, adds it to storage by copying\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks primal solution; if feasible, adds it to storage; solution is freed afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks current LP/pseudo solution for feasibility; if possible, adds it to storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns all partial solutions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPartialSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " returns number of partial solutions\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPartialSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " checks solution for feasibility without adding it to the solution store\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks solution for feasibility in original problem without adding it to the solution store;\n  this method is used to double check a solution in order to validate the presolving process\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSolOrig(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        feasible: *mut ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " update integrality violation of a solution"]
    pub fn SCIPupdateSolIntegralityViolation(scip: *mut SCIP, sol: *mut SCIP_SOL, absviol: f64);
}
unsafe extern "C" {
    #[doc = " update bound violation of a solution"]
    pub fn SCIPupdateSolBoundViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
unsafe extern "C" {
    #[doc = " update LP row violation of a solution"]
    pub fn SCIPupdateSolLPRowViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
unsafe extern "C" {
    #[doc = " update constraint violation of a solution"]
    pub fn SCIPupdateSolConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
unsafe extern "C" {
    #[doc = " update LP row and constraint violations of a solution"]
    pub fn SCIPupdateSolLPConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
unsafe extern "C" {
    #[doc = " allow violation updates"]
    pub fn SCIPactivateSolViolationUpdates(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " disallow violation updates"]
    pub fn SCIPdeactivateSolViolationUpdates(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " return whether a primal ray is stored that proves unboundedness of the LP relaxation\n\n  @return return whether a primal ray is stored that proves unboundedness of the LP relaxation\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPhasPrimalRay(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets value of given variable in primal ray causing unboundedness of the LP relaxation;\n  should only be called if such a ray is stored (check with SCIPhasPrimalRay())\n\n  @return value of given variable in primal ray causing unboundedness of the LP relaxation\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPrimalRayVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " updates the primal ray thats proves unboundedness\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPupdatePrimalRay(scip: *mut SCIP, primalray: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " overwrite the fp-values in a solution with the rounded exact ones"]
    pub fn SCIPoverwriteFPsol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks exact primal solution; if feasible, adds it to storage; solution is freed afterwards\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySolFreeExact(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initializes solving data structures and transforms problem\n\n  Before SCIP 10, this function also called the garbage collection for block memory explicitly.\n  It has been removed for performance reason, but if memory is very tight, then the previous behavior can be\n  restored by adding a call to SCIPcollectMemoryGarbage() before SCIPtransformProb().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n       - \\ref SCIP_STAGE_FREE\n\n  @post When calling this method in the \\ref SCIP_STAGE_PROBLEM stage, the \\SCIP stage is changed to \\ref\n        SCIP_STAGE_TRANSFORMED; otherwise, the stage is not changed\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPtransformProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms and presolves problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages:\n        - \\ref SCIP_STAGE_PRESOLVING if the presolving process was interrupted\n        - \\ref SCIP_STAGE_PRESOLVED if the presolving process was finished and did not solve the problem\n        - \\ref SCIP_STAGE_SOLVED if the problem was solved during presolving\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPpresolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms, presolves, and solves problem\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n\n        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving\n        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms, presolves, and solves problem using the configured concurrent solvers\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution\n        process was interrupted:\n        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving\n        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search\n        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolveConcurrent(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is\n  preserved\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of\n        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_TRANSFORMED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSolve(scip: *mut SCIP, restart: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees all solution process data including presolving and transformed problem, only original problem is kept\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post After calling this method \\SCIP reaches one of the following stages:\n        - \\ref SCIP_STAGE_INIT if the method was called from \\SCIP stage \\ref SCIP_STAGE_INIT\n        - \\ref SCIP_STAGE_PROBLEM if the method was called from any other of the allowed stages\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeTransform(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs \\SCIP that the solving process should be interrupted as soon as possible (e.g., after the current node has\n   been solved)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPinterruptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether \\SCIP has been informed that the solving process should be interrupted as soon as possible\n\n  This function returns whether SCIPinterruptSolve() has been called, which is different from SCIPinterrupted(),\n  which returns whether a SIGINT signal has been received by the SCIP signal handler.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPisSolveInterrupted(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " informs SCIP that the solving process should be restarted as soon as possible (e.g., after the current node has\n  been solved)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the \\SCIP stage does not get changed"]
    pub fn SCIPrestartSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether we are in the restarting phase\n\n  @return TRUE, if we are in the restarting phase; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPisInRestart(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is\n  preserved\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of\n        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_PRESOLVED.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeReoptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " include specific heuristics and branching rules for reoptimization\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPenableReoptimization(
        scip: *mut SCIP,
        enable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether reoptimization is enabled or not"]
    pub fn SCIPisReoptEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the stored solutions corresponding to a given run"]
    pub fn SCIPgetReoptSolsRun(
        scip: *mut SCIP,
        run: ::std::os::raw::c_int,
        sols: *mut *mut SCIP_SOL,
        solssize: ::std::os::raw::c_int,
        nsols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " mark all stored solutions as not updated"]
    pub fn SCIPresetReoptSolMarks(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " check if the reoptimization process should be restarted\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcheckReoptRestart(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        restart: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " save bound change based on dual information in the reoptimization tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptDualBndchg(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
        oldbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the optimal solution of the last iteration or NULL of none exists"]
    pub fn SCIPgetReoptLastOptSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " returns the objective coefficent of a given variable in a previous iteration\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetReoptOldObjCoef(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        run: ::std::os::raw::c_int,
        objcoef: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of branch and bound runs performed, including the current run\n\n  @return the number of branch and bound runs performed, including the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of reoptimization runs performed, including the current run\n\n  @return the number of reoptimization runs performed, including the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNReoptRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " add given number to the number of processed nodes in current run and in all runs, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddNNodes(scip: *mut SCIP, nnodes: ::std::os::raw::c_longlong);
}
unsafe extern "C" {
    #[doc = " gets number of processed nodes in current run, including the focus node\n\n  @return the number of processed nodes in current run, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of processed nodes in all runs, including the focus node\n\n  @return the total number of processed nodes in all runs, including the focus node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of leaf nodes processed with feasible relaxation solution\n\n @return number of leaf nodes processed with feasible relaxation solution\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNFeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of infeasible leaf nodes processed\n\n @return number of infeasible leaf nodes processed\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNInfeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of processed leaf nodes that hit LP objective limit\n\n @return number of processed leaf nodes that hit LP objective limit\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNObjlimLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of global bound changes\n\n @return number of global bound changes\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of global bound changes applied in the current run\n\n @return number of global bound changes\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgsRun(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of global fixings applied in the current run\n\n @return number of global fixings\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootIntFixingsRun(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of times a selected node was from a cut off subtree\n\n  @return number of times a selected node was from a cut off subtree\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNDelayedCutoffs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved so far\n\n  @return the total number of LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of calls to the exact LP solver\n\n  @return the number of calls to the exact LP solver\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNExactLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm\n\n  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of active non-zeros in the current transformed problem\n\n  @return the number of active non-zeros in the current transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNNZs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node\n\n  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used in primal and dual simplex and barrier algorithm for the first LP at the root\n  node\n\n  @return the total number of iterations used in primal and dual simplex and barrier algorithm for the first root LP\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootFirstLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of primal LPs solved so far\n\n  @return the total number of primal LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used so far in primal simplex\n\n  @return total number of iterations used so far in primal simplex\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of dual LPs solved so far\n\n  @return the total number of dual LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used so far in dual simplex\n\n  @return the total number of iterations used so far in dual simplex\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of barrier LPs solved so far\n\n  @return the total number of barrier LPs solved so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of iterations used so far in barrier algorithm\n\n  @return the total number of iterations used so far in barrier algorithm\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal and dual simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in primal and dual simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of primal LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of primal LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in primal simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of dual LPs solved so far that were resolved from an advanced start basis\n\n  @return the total number of dual LPs solved so far that were resolved from an advanced start basis\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far in dual simplex calls where an advanced start basis\n  was available\n\n  @return the total number of simplex iterations used so far in dual simplex calls where an advanced start\n          basis was available\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved so far for node relaxations\n\n  @return the total number of LPs solved so far for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved in 0 iterations for node relaxations\n\n  @return the total number of LPs solved with 0 iteratins for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeZeroIterationLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far for node relaxations\n\n  @return the total number of simplex iterations used so far for node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved so far for initial LP in node relaxations\n\n  @return the total number of LPs solved so far for initial LP in node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far for initial LP in node relaxations\n\n  @return the total number of simplex iterations used so far for initial LP in node relaxations\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of LPs solved so far during diving and probing\n\n  @return total number of LPs solved so far during diving and probing\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far during diving and probing\n\n  @return the total number of simplex iterations used so far during diving and probing\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of times, strong branching was called (each call represents solving two LPs)\n\n  @return the total number of times, strong branching was called (each call represents solving two LPs)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching\n\n  @return the total number of simplex iterations used so far in strong branching\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of times, strong branching was called at the root node (each call represents solving two LPs)\n\n  @return the total number of times, strong branching was called at the root node (each call represents solving two LPs)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching at the root node\n\n  @return the total number of simplex iterations used so far in strong branching at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of pricing rounds performed so far at the current node\n\n  @return the number of pricing rounds performed so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNPriceRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get current number of variables in the pricing store\n\n  @return the current number of variables in the pricing store\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of pricing variables found so far\n\n  @return the total number of pricing variables found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of pricing variables applied to the LPs\n\n  @return the total number of pricing variables applied to the LPs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of separation rounds performed so far at the current node\n\n  @return the number of separation rounds performed so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNSepaRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of cuts added to the sepastore so far; this includes global cuts from the cut pool as often as they are separated\n\n  @return the total number of cuts added to the sepastore so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get number of cuts found so far in current separation round\n\n  @return the number of cuts found so far in current separation round\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFoundRound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of cuts applied to the LPs\n\n  @return the total number of cuts applied to the LPs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of constraints found in conflict analysis (conflict, reconvergence constraints, and dual proofs)\n\n  @return the total number of constraints found in conflict analysis (conflict, reconvergence constraints, and dual proofs)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get number of conflict constraints found so far at the current node\n\n  @return the number of conflict constraints found so far at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFoundNode(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get total number of conflict constraints added to the problem\n\n  @return the total number of conflict constraints added to the problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of resolution conflict constraints added to the problem\n\n  @return the total number of resolution conflict constraints added to the problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNResConflictConssApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " get total number of dual proof constraints added to the problem\n\n  @return the total number of dual proof constraints added to the problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictDualproofsApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)\n\n  @return the maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets maximal depth of all processed nodes over all branch and bound runs\n\n  @return the maximal depth of all processed nodes over all branch and bound runs\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxTotalDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets total number of backtracks, i.e. number of times, the new node was selected from the leaves queue\n\n  @return the total number of backtracks, i.e. number of times, the new node was selected from the leaves queue\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBacktracks(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets total number of active constraints at the current node\n\n  @return the total number of active constraints at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNActiveConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets total number of enabled constraints at the current node\n\n  @return the total number of enabled constraints at the current node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNEnabledConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets average dual bound of all unprocessed nodes for original problem\n\n  @return the average dual bound of all unprocessed nodes for original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgDualbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets average lower (dual) bound of all unprocessed nodes in transformed problem\n\n  @return the average lower (dual) bound of all unprocessed nodes in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgLowerbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global dual bound\n\n  @return the global dual bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetDualbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global exact dual bound\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetDualboundExact(scip: *mut SCIP, result: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets global lower (dual) bound in transformed problem\n\n  @return the global lower (dual) bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global exact lower (dual) bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerboundExact(scip: *mut SCIP, result: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets dual bound of the root node for the original problem\n\n  @return the dual bound of the root node for the original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDualboundRoot(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem of the root node\n\n  @return the lower (dual) bound in transformed problem of the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerboundRoot(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets dual bound for the original problem obtained by the first LP solve at the root node\n\n  @return the dual bound for the original problem of the first LP solve at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPDualboundRoot(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem obtained by the first LP solve at the root node\n\n  @return the lower (dual) bound in transformed problem obtained by first LP solve at the root node\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPLowerboundRoot(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the primal bound of the very first solution\n\n @return the primal bound of the very first solution"]
    pub fn SCIPgetFirstPrimalBound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global primal bound (objective value of best solution or user objective limit) for the original problem\n\n  @return the global primal bound (objective value of best solution or user objective limit) for the original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPrimalbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global primal bound (objective value of best solution or user objective limit) for the original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPrimalboundExact(scip: *mut SCIP, result: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)\n\n  @return the global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetUpperbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global exact upper (primal) bound in transformed problem (objective value of best solution or user objective limit)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetUpperboundExact(scip: *mut SCIP, result: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " gets global cutoff bound in transformed problem: a sub problem with lower bound larger than the cutoff\n  cannot contain a better feasible solution; usually, this bound is equal to the upper bound, but if the\n  objective value is always integral, the cutoff bound is (nearly) one less than the upper bound;\n  additionally, due to objective function domain propagation, the cutoff bound can be further reduced\n\n  @return global cutoff bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCutoffbound(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets global cutoff bound of exact transformed problem: a sub problem with lower bound larger than the cutoff\n  cannot contain a better feasible solution; usually, this bound is equal to the upper bound, but if the\n  objective value is always integral, the cutoff bound is (nearly) one less than the upper bound;\n  additionally, due to objective function domain propagation, the cutoff bound can be further reduced\n\n  @return global cutoff bound in transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCutoffboundExact(scip: *mut SCIP) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " updates the cutoff bound\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note using this method in the solving stage can lead to an erroneous SCIP solving status; in particular,\n        if a solution not respecting the cutoff bound was found before installing a cutoff bound which\n        renders the remaining problem infeasible, this solution may be reported as optimal\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the given cutoff bound has to better or equal to known one (SCIPgetCutoffbound())\n  @note a given cutoff bound is also used for updating the objective limit, if possible"]
    pub fn SCIPupdateCutoffbound(scip: *mut SCIP, cutoffbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the current primal bound is justified with a feasible primal solution; if not, the primal bound\n  was set from the user as objective limit\n\n  @return TRUE if the current primal bound is justified with a feasible primal solution, otherwise FALSE\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisPrimalboundSol(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,\n  or infinity, if they have opposite sign\n\n  @return the current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,\n  or infinity, if they have opposite sign\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetGap(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds\n  have same sign, or infinity, if they have opposite sign\n\n  @return current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds\n  have same sign, or infinity, if they have opposite sign\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransGap(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets number of feasible primal solutions found so far\n\n  @return the number of feasible primal solutions found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of feasible primal solutions respecting the objective limit found so far\n\n  @return the number of feasible primal solutions respecting the objective limit found so far\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNLimSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of feasible primal solutions found so far, that improved the primal bound at the time they were found\n\n  @return the number of feasible primal solutions found so far, that improved the primal bound at the time they were found\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBestSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables\n\n  @return the average pseudo cost value for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocost(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @return the average pseudo cost value for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCurrentRun(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables\n\n  @return the average number of pseudo cost updates for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCount(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @return the average number of pseudo cost updates for the given direction over all variables,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCountCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the number of pseudo cost updates for the given direction over all variables\n\n  @return the number of pseudo cost updates for the given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostCount(
        scip: *mut SCIP,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5\n\n  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScore(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average discounted pseudo cost score value over all variables, assuming a fractionality of 0.5\n\n  This combines both pscost and ancpscost fields.\n\n  @return the average discounted pseudo cost score value over all variables, assuming a fractionality of 0.5,\n  combining both pscost and ancpscost fields\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgDPseudocostScore(scip: *mut SCIP, discountfac: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variance of pseudo costs for all variables in the requested direction\n\n  @return the variance of pseudo costs for all variables in the requested direction\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostVariance(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5,\n  only using the pseudo cost information of the current run\n\n  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScoreCurrentRun(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average conflict score value over all variables\n\n  @return the average conflict score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictScore(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average conflict score value over all variables, only using the conflict score information of the current run\n\n  @return the average conflict score value over all variables, only using the conflict score information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictScoreCurrentRun(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average inference score value over all variables\n\n  @return the average inference score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScore(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average conflictlength score value over all variables, only using the conflictlength information of the\n  current run\n\n  @return the average conflictlength score value over all variables, only using the conflictlength information of the\n          current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScoreCurrentRun(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables\n\n  @return the average number of inferences found after branching in given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferences(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables,\n  only using the inference information of the current run\n\n  @return the average number of inferences found after branching in given direction over all variables,\n          only using the inference information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferencesCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average inference score value over all variables\n\n  @return the average inference score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScore(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average inference score value over all variables, only using the inference information of the\n  current run\n\n  @return the average inference score value over all variables, only using the inference information of the\n          current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScoreCurrentRun(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables\n\n  @return the average number of cutoffs found after branching in given direction over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffs(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables,\n  only using the cutoff information of the current run\n\n  @return the average number of cutoffs found after branching in given direction over all variables,\n          only using the cutoff information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffsCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average cutoff score value over all variables\n\n  @return the average cutoff score value over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScore(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the average cutoff score value over all variables, only using the cutoff score information of the current run\n\n  @return the average cutoff score value over all variables, only using the cutoff score information of the current run\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScoreCurrentRun(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average normalized efficacy of a GMI cut over all variables\n\n  @return the average normalized efficacy of a GMI cut over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgGMIeff(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " increases the average normalized efficacy of a GMI cut over all variables\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincAvgGMIeff(scip: *mut SCIP, gmieff: f64);
}
unsafe extern "C" {
    #[doc = " computes a deterministic measure of time from statistics\n\n  @return the deterministic  time\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDeterministicTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " outputs status statistics\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatusStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects status statistics in a SCIP_DATATREE object\n\n  This function sets:\n   - status: the current status of the solver\n   - info: info about the keys and values stored in the datatree\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectStatusStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs timing statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects timing statistics in SCIP_DATATREE\n\n  The following keys are set:\n  - \"total_time\": Total time spent in SCIP.\n  - \"solving_time\": Time spent solving the problem.\n  - \"presolving_time\": Time spent in presolving.\n  - \"reading_time\": Time spent reading the problem.\n  - \"copy_time\": Time spent copying the problem (if applicable).\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectTimingStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs statistics for original problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintOrigProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects statistics for original problem in a SCIP_DATATREE object\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectOrigProblemStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs statistics for transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTransProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects statistics for transformed problem\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectTransProblemStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs presolver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPresolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects presolver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectPresolverStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs constraint statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects constraint statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectConstraintStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs constraint timing statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects constraint timing statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectConstraintTimingStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs propagator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPropagatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects propagator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectPropagatorStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs conflict statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConflictStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects conflict statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectConflictStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs separator statistics\n\n  Columns:\n    - RootCalls: The number of calls that happened at the root.\n    - FoundCuts: The total number of cuts generated by the separators.\n      Note: Cutpool-FoundCuts \\f$= \\sum_{i=1}^nsepas ( Foundcuts_i - DirectAdd_i )\\f$.\n    - ViaPoolAdd: The total number of cuts added to the sepastore from the cutpool.\n    - DirectAdd: The total number of cuts added directly to the sepastore from the separator.\n    - Applied: The sum of all cuts from the separator that were applied to the LP.\n    - ViaPoolApp: The number of cuts that entered the sepastore from the cutpool that were applied to the LP.\n    - DirectApp: The number of cuts that entered the sepastore directly and were applied to the LP.\n\n  The number of cuts ViaPoolAdd + Directly should be equal to the number of cuts Filtered + Forced + Selected in the\n  cutselector statistics.\n\n  @note The following edge case may lead to over or undercounting of statistics: When SCIPapplyCutsProbing() is\n        called, cuts are counted for the cut selection statistics, but not for the separator statistics.  This\n        happens, e.g., in the default plugin prop_obbt.c.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSeparatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects separator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectSeparatorStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs cutselector statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintCutselectorStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects cutselector statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectCutselectorStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs pricer statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPricerStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects pricer statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectPricerStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs branching rule statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchruleStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects branching rule statistics in a SCIP_DATATREE object"]
    pub fn SCIPcollectBranchruleStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs heuristics statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintHeuristicStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects heuristics statistics into SCIP_DATATREE\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectHeuristicStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs compression statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintCompressionStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects compression statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectCompressionStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs LP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects LP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectLPStatistics(scip: *mut SCIP, datatree: *mut SCIP_DATATREE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs NLP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintNLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects NLP statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectNLPStatistics(scip: *mut SCIP, datatree: *mut SCIP_DATATREE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs relaxator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRelaxatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects relaxator statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectRelaxatorStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs tree statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTreeStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects tree statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectTreeStatistics(scip: *mut SCIP, datatree: *mut SCIP_DATATREE)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs root statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRootStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects root statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectRootStatistics(scip: *mut SCIP, datatree: *mut SCIP_DATATREE)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs solution statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSolutionStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects solution statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectSolutionStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs concurrent solver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConcsolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects concurrent solver statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectConcsolverStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs Benders' decomposition statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBendersStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects Benders' decomposition statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectBendersStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs expression handler statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintExpressionHandlerStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects expression handler statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectExpressionHandlerStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs NLPI statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintNLPIStatistics(scip: *mut SCIP, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " collects NLPI statistics\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcollectNLPIStatistics(scip: *mut SCIP, datatree: *mut SCIP_DATATREE)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs solving statistics\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may to correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs solving statistics in JSON format\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @note If limits have been changed between the solution and the call to this function, the status is recomputed and\n        thus may correspond to the original status.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatisticsJson(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs reoptimization statistics\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintReoptStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs history statistics about branchings on variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchingStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " collects branching statistics about variables in a SCIP_DATATREE\n\n This function collects detailed branching statistics for all variables in the SCIP instance and organizes them into\n a hierarchical structure in the provided `SCIP_DATATREE`. The statistics include locks, branchings, inferences,\n cutoffs, pseudocosts, and strong branching information.\n\n The `datatree` will contain the following keys:\n - `variables`: A nested table keyed by variable names, containing:\n   - `name`: Name of the variable.\n   - `priority`: Branching priority of the variable.\n   - `factor`: Branching factor of the variable.\n   - `locks_down`: Number of locks in the down direction.\n   - `locks_up`: Number of locks in the up direction.\n   - `avg_depth`: Average branching depth for the variable.\n   - `branchings_down`: Number of branchings in the down direction.\n   - `branchings_up`: Number of branchings in the up direction.\n   - `strong_branchings`: Number of strong branchings performed on the variable.\n   - `avg_inferences_down`: Average number of inferences per branching in the down direction.\n   - `avg_inferences_up`: Average number of inferences per branching in the up direction.\n   - `cutoff_rate_down`: Percentage of branchings in the down direction that led to cutoffs.\n   - `cutoff_rate_up`: Percentage of branchings in the up direction that led to cutoffs.\n   - `pseudocost_down`: Pseudocost in the down direction.\n   - `pseudocost_up`: Pseudocost in the up direction.\n   - `pseudocost_count_down`: Number of pseudocost updates in the down direction.\n   - `pseudocost_count_up`: Number of pseudocost updates in the up direction.\n   - `pseudocost_variance_down`: Variance of pseudocost in the down direction.\n   - `pseudocost_variance_up`: Variance of pseudocost in the up direction.\n - `total_branchings_down`: Total number of branchings in the down direction across all variables.\n - `total_branchings_up`: Total number of branchings in the up direction across all variables.\n - `total_strong_branchings`: Total number of strong branchings across all variables.\n - `avg_inferences_down`: Average inferences per branching in the down direction across all variables.\n - `avg_inferences_up`: Average inferences per branching in the up direction across all variables.\n - `avg_cutoff_rate_down`: Average cutoff rate for branchings in the down direction across all variables.\n - `avg_cutoff_rate_up`: Average cutoff rate for branchings in the up direction across all variables.\n - `status`: If the problem is not solved, a string indicating that statistics are not available.\n\n @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n @return \\ref SCIP_OKAY if everything worked. Otherwise, a suitable error code is returned."]
    pub fn SCIPcollectBranchingStatistics(
        scip: *mut SCIP,
        datatree: *mut SCIP_DATATREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs node information display line\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintDisplayLine(
        scip: *mut SCIP,
        file: *mut FILE,
        verblevel: SCIP_VERBLEVEL,
        endline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets total number of implications between variables that are stored in the implication graph\n\n  @return the total number of implications between variables that are stored in the implication graph\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNImplications(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " update statistical information when a new solution was found"]
    pub fn SCIPstoreSolutionGap(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " recomputes and returns the primal dual gap stored in the stats\n\n @return returns the primal dual gap stored in the stats"]
    pub fn SCIPgetPrimalDualIntegral(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a statistics table and includes it in SCIP"]
    pub fn SCIPincludeTable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        active: ::std::os::raw::c_uint,
        tablecopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tablefree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                table: *mut SCIP_TABLE,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        tablecollect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                table: *mut SCIP_TABLE,
                datatree: *mut SCIP_DATATREE,
            ) -> SCIP_RETCODE,
        >,
        tabledata: *mut SCIP_TABLEDATA,
        position: ::std::os::raw::c_int,
        earlieststage: SCIP_STAGE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the statistics table of the given name, or NULL if not existing"]
    pub fn SCIPfindTable(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_TABLE;
}
unsafe extern "C" {
    #[doc = " returns the array of currently available statistics tables"]
    pub fn SCIPgetTables(scip: *mut SCIP) -> *mut *mut SCIP_TABLE;
}
unsafe extern "C" {
    #[doc = " returns the number of currently available statistics tables"]
    pub fn SCIPgetNTables(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets current time of day in seconds (standard time zone)\n\n  @return the current time of day in seconds (standard time zone)."]
    pub fn SCIPgetTimeOfDay(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a clock using the default clock type\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a clock counting the CPU user seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateCPUClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a clock counting the wall clock seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateWallClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets the time measurement of a clock to zero and completely stops the clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " starts the time measurement of a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstartClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stops the time measurement of a clock\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstopClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables or disables \\p clck"]
    pub fn SCIPsetClockEnabled(clck: *mut SCIP_CLOCK, enable: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " enables or disables all statistic clocks of SCIP concerning plugin statistics,\n  LP execution time, strong branching time, etc.\n\n  Method reads the value of the parameter timing/statistictiming. In order to disable statistic timing,\n  set the parameter to FALSE.\n\n  @note: The (pre-)solving time clocks which are relevant for the output during (pre-)solving\n         are not affected by this method\n\n  @see: For completely disabling all timing of SCIP, consider setting the parameter timing/enabled to FALSE\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableOrDisableStatisticTiming(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " starts the current solving time\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stops the current solving time in seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstopSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the measured time of a clock in seconds\n\n  @return the measured time of a clock in seconds."]
    pub fn SCIPgetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the measured time of a clock to the given value in seconds\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK, sec: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the current total SCIP time in seconds, possibly accumulated over several problems.\n\n  @return the current total SCIP time in seconds, ie. the total time since the SCIP instance has been created"]
    pub fn SCIPgetTotalTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the current solving time in seconds\n\n  @return the current solving time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSolvingTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the current reading time in seconds\n\n  @return the current reading time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetReadingTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the current presolving time in seconds\n\n  @return the current presolving time in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPresolvingTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the time need to solve the first LP in the root node\n\n  @return the solving time for the first LP in the root node in seconds.\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetFirstLPTime(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets focus node in the tree\n\n  if we are in probing/diving mode this method returns the node in the tree where the probing/diving mode was started.\n\n  @return the current node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetFocusNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets current node in the tree\n\n  @return the current node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCurrentNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,\n  such that the depth includes the probing path\n\n  @return the depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,\n  such that the depth includes the probing path\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the\n  branching tree, excluding the nodes of the probing path\n\n  @return the depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the\n  branching tree, excluding the nodes of the probing path\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetFocusDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets current plunging depth (successive times, a child was selected as next node)\n\n  @return the current plunging depth (successive times, a child was selected as next node)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPlungeDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the root node of the tree\n\n  @return the root node of the search tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRootNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the effective root depth, i.e., the depth of the deepest node which is part of all paths from the root node\n  to the unprocessed nodes.\n\n  @return effective root depth\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetEffectiveRootDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the current node is already solved and only propagated again\n\n  @return TRUE is returned if \\SCIP performance repropagation, otherwise FALSE.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinRepropagation(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets children of focus node along with the number of children\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetChildren(
        scip: *mut SCIP,
        children: *mut *mut *mut SCIP_NODE,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of children of focus node\n\n  @return number of children of the focus node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNChildren(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets siblings of focus node along with the number of siblings\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetSiblings(
        scip: *mut SCIP,
        siblings: *mut *mut *mut SCIP_NODE,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of siblings of focus node\n\n  @return the number of siblings of focus node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNSiblings(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets leaves of the tree along with the number of leaves\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLeaves(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of leaves in the tree\n\n  @return the number of leaves in the tree\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLeaves(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of nodes left in the tree (children + siblings + leaves)\n\n  @return the number of nodes left in the tree (children + siblings + leaves)\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodesLeft(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @return the best child of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @return the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection strategy\n\n  @return the best child of the focus node w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection strategy\n\n  @return the best sibling of the focus node w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best leaf from the node queue w.r.t. the node selection strategy\n\n  @return the best leaf from the node queue w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestLeaf(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy\n\n  @return the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the node with smallest lower bound from the tree (child, sibling, or leaf)\n\n  @return the node with smallest lower bound from the tree (child, sibling, or leaf)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestboundNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " access to all data of open nodes (leaves, children, and siblings)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetOpenNodesData(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        children: *mut *mut *mut SCIP_NODE,
        siblings: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
        nchildren: *mut ::std::os::raw::c_int,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks node and whole sub tree to be cut off from branch and bound tree\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcutoffNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all nodes from branch and bound tree that were marked to be cut off via SCIPcutoffNode()\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note In diving mode, the removal of nodes is delayed until diving ends."]
    pub fn SCIPpruneTree(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks the given node to be propagated again the next time a node of its subtree is processed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrepropagateNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns depth of first node in active path that is marked being cutoff\n\n  @return depth of first node in active path that is marked being cutoff\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutoffdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns depth of first node in active path that has to be propagated again\n\n  @return depth of first node in active path that has to be propagated again\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRepropdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " prints all branching decisions on variables from the root to the given node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNodeRootPath(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets whether the LP should be solved at the focus node\n\n  @note In order to have an effect, this method needs to be called after a node is focused but before the LP is\n        solved.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetFocusnodeLP(scip: *mut SCIP, solvelp: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " query if node was the last parent of a branching of the tree\n\n  @return TRUE if node was the last parent of a branching of the tree\n\n  @pre This method can be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPwasNodeLastBranchParent(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " validate the result of the solve\n\n  the validation includes\n\n  - checking the feasibility of the incumbent solution in the original problem (using SCIPcheckSolOrig())\n\n  - checking if the objective bounds computed by SCIP agree with external primal and dual reference bounds.\n\n  All external reference bounds the original problem space and the original objective sense.\n\n  For infeasible problems, +/-SCIPinfinity() should be passed as reference bounds depending on the objective sense\n  of the original problem."]
    pub fn SCIPvalidateSolve(
        scip: *mut SCIP,
        primalreference: f64,
        dualreference: f64,
        reftol: f64,
        quiet: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
        primalboundcheck: *mut ::std::os::raw::c_uint,
        dualboundcheck: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " validate the result of an exact solve\n\n  the validation includes\n\n  - checking the feasibility of the incumbent solution in the original problem (using SCIPcheckSolOrig())\n\n  - checking if the objective bounds computed by SCIP agree with external primal and dual reference bounds.\n\n  All external reference bounds the original problem space and the original objective sense.\n\n  For infeasible problems, +/-inf should be passed as reference bounds depending on the objective sense\n  of the original problem."]
    pub fn SCIPvalidateSolveExact(
        scip: *mut SCIP,
        primalreference: *mut SCIP_RATIONAL,
        dualreference: *mut SCIP_RATIONAL,
        quiet: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
        primalboundcheck: *mut ::std::os::raw::c_uint,
        dualboundcheck: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures problem variable\n\n  If variable is of integral type, fractional bounds are automatically rounded.\n  An integer variable with bounds zero and one is automatically converted into a binary variable.\n\n  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will\n           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the\n           original objective function value of variables created during the solving process has to be multiplied by\n           -1, too.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures problem variable without setting optional callbacks and variable data.\n\n  Callbacks and variable data can be set in the following using SCIPvarSetDelorigData(), SCIPvarSetTransData(),\n  SCIPvarSetDeltransData(), SCIPvarSetCopy(), and SCIPvarSetData().\n\n  Variable flags are set as initial = TRUE and removable = FALSE, and can be adjusted by using SCIPvarSetInitial() and SCIPvarSetRemovable(), resp.\n\n  If variable is of integral type, fractional bounds are automatically rounded.\n  An integer variable with bounds zero and one is automatically converted into a binary variable.\n\n  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will\n           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the\n           original objective function value of variables created during the solving process has to be multiplied by\n           -1, too.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVarBasic(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures problem variable that may be implied integral\n\n  If variable is of integral type, fractional bounds are automatically rounded.\n  An integer variable with bounds zero and one is automatically converted into a binary variable.\n\n  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will\n           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the\n           original objective function value of variables created during the solving process has to be multiplied by\n           -1, too.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVarImpl(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
        impltype: SCIP_IMPLINTTYPE,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds exact data to variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarExactData(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lb: *mut SCIP_RATIONAL,
        ub: *mut SCIP_RATIONAL,
        obj: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs the variable name to the file stream\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteVarName(
        scip: *mut SCIP,
        file: *mut FILE,
        var: *mut SCIP_VAR,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print the given list of variables to output stream separated by the given delimiter character;\n\n  i. e. the variables x1, x2, ..., xn with given delimiter ',' are written as: \\<x1\\>, \\<x2\\>, ..., \\<xn\\>;\n\n  the method SCIPparseVarsList() can parse such a string\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsList(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
        delimiter: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print the given variables and coefficients as linear sum in the following form\n  c1 \\<x1\\> + c2 \\<x2\\>   ... + cn \\<xn\\>\n\n  This string can be parsed by the method SCIPparseVarsLinearsum().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsLinearsum(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print the given monomials as polynomial in the following form\n  c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...\n\n  This string can be parsed by the method SCIPparseVarsPolynomial().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsPolynomial(
        scip: *mut SCIP,
        file: *mut FILE,
        monomialvars: *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut f64,
        monomialcoefs: *mut f64,
        monomialnvars: *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parses variable information (in cip format) out of a string; if the parsing process was successful a variable is\n  created and captured; if variable is of integral type, fractional bounds are automatically rounded; an integer\n  variable with bounds zero and one is automatically converted into a binary variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parses the given string for a variable name and stores the variable in the corresponding pointer if such a variable\n  exits and returns the position where the parsing stopped\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarName(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        var: *mut *mut SCIP_VAR,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parse the given string as variable list (here ',' is the delimiter)) (\\<x1\\>, \\<x2\\>, ..., \\<xn\\>) (see\n  SCIPwriteVarsList() ); if it was successful, the pointer success is set to TRUE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist.\n\n  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens\n        except that the required size is stored in the corresponding integer; the reason for this approach is that we\n        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP\n        memory functions)."]
    pub fn SCIPparseVarsList(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parse the given string as linear sum of variables and coefficients (c1 \\<x1\\> + c2 \\<x2\\> + ... + cn \\<xn\\>)\n  (see SCIPwriteVarsLinearsum() ); if it was successful, the pointer success is set to TRUE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist.\n\n  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens\n        except that the required size is stored in the corresponding integer; the reason for this approach is that we\n        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP\n        memory functions)."]
    pub fn SCIPparseVarsLinearsum(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parse the given string as linear sum of variables and coefficients (c1 \\<x1\\> + c2 \\<x2\\> + ... + cn \\<xn\\>)\n  (see SCIPwriteVarsLinearsum() ); if it was successful, the pointer success is set to TRUE\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist.\n\n  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens\n        except that the required size is stored in the corresponding integer; the reason for this approach is that we\n        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP\n        memory functions)."]
    pub fn SCIPparseVarsLinearsumExact(
        scip: *mut SCIP,
        str_: *mut ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        vals: *mut *mut SCIP_RATIONAL,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " parse the given string as signomial of variables and coefficients\n  (c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...)\n  (see SCIPwriteVarsPolynomial()); if it was successful, the pointer success is set to TRUE\n\n  The user has to call SCIPfreeParseVarsPolynomialData(scip, monomialvars, monomialexps,\n  monomialcoefs, monomialnvars, *nmonomials) short after SCIPparseVarsPolynomial to free all the\n  allocated memory again.  Do not keep the arrays created by SCIPparseVarsPolynomial around, since\n  they use buffer memory that is intended for short term use only.\n\n  Parsing is stopped at the end of string (indicated by the \\\\0-character) or when no more monomials\n  are recognized.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarsPolynomial(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees memory allocated when parsing a signomial from a string\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfreeParseVarsPolynomialDataExact(
        scip: *mut SCIP,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialcoefs: *mut *mut *mut SCIP_RATIONAL,
        nmonomials: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " parse the given string as signomial of variables and coefficients\n  (c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...)\n  (see SCIPwriteVarsPolynomial()); if it was successful, the pointer success is set to TRUE\n\n  The user has to call SCIPfreeParseVarsPolynomialData(scip, monomialvars, monomialexps,\n  monomialcoefs, monomialnvars, *nmonomials) short after SCIPparseVarsPolynomial to free all the\n  allocated memory again.\n\n  Parsing is stopped at the end of string (indicated by the \\\\0-character) or when no more monomials\n  are recognized.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarsPolynomialExact(
        scip: *mut SCIP,
        str_: *mut ::std::os::raw::c_char,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialcoefs: *mut *mut *mut SCIP_RATIONAL,
        nmonomials: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees memory allocated when parsing a signomial from a string\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfreeParseVarsPolynomialData(
        scip: *mut SCIP,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " increases usage counter of variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcaptureVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of variable, if the usage pointer reaches zero the variable gets freed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note the pointer of the variable will be NULLed"]
    pub fn SCIPreleaseVar(scip: *mut SCIP, var: *mut *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the name of a variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PROBLEM\n\n  @note to get the current name of a variable, use SCIPvarGetName() from pub_var.h"]
    pub fn SCIPchgVarName(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets and captures transformed variable of a given variable; if the variable is not yet transformed,\n  a new transformed variable for this variable is created\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets and captures transformed variables for an array of variables;\n  if a variable of the array is not yet transformed, a new transformed variable for this variable is created;\n  it is possible to call this method with vars == transvars\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets corresponding transformed variable of a given variable;\n  returns NULL as transvar, if transformed variable is not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets corresponding transformed variables for an array of variables;\n  stores NULL in a transvars slot, if the transformed variable is not yet existing;\n  it is possible to call this method with vars == transvars, but remember that variables that are not\n  yet transformed will be replaced with NULL\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets negated variable x' = lb + ub - x of variable x; negated variable is created, if not yet existing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        negvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets negated variables x' = lb + ub - x of variables x; negated variables are created, if not yet existing;\n  in difference to \\ref SCIPcreateVar, the negated variable must not be released (unless captured explicitly)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        negvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a binary variable that is equal to the given binary variable, and that is either active, fixed, or\n  multi-aggregated, or the negated variable of an active, fixed, or multi-aggregated variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentative(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        repvar: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets binary variables that are equal to the given binary variables, and which are either active, fixed, or\n  multi-aggregated, or the negated variables of active, fixed, or multi-aggregated variables\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentatives(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        repvars: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " flattens aggregation graph of multi-aggregated variable in order to avoid exponential recursion later on\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPflattenVarAggregationGraph(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Transforms a given linear sum of variables, that is a_1*x_1 + ... + a_n*x_n + c into a corresponding linear sum of\n  active variables, that is b_1*y_1 + ... + b_m*y_m + d.\n\n  If the number of needed active variables is greater than the available slots in the variable array, nothing happens\n  except that an upper bound on the required size is stored in the variable requiredsize; otherwise, the active\n  variable representation is stored in the arrays.\n\n  The reason for this approach is that we cannot reallocate memory, since we do not know how the memory has been\n  allocated (e.g., by a C++ 'new' or SCIP functions). Note that requiredsize is an upper bound due to possible\n  cancelations.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The resulting linear sum is stored into the given variable array, scalar array, and constant. That means the\n        given entries are overwritten.\n\n  @note That method can be used to convert a single variables into variable space of active variables. Therefore call\n        the method with the linear sum 1.0*x + 0.0."]
    pub fn SCIPgetProbvarLinearSum(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        constant: *mut f64,
        requiredsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms given variable, scalar and constant to the corresponding active, fixed, or\n  multi-aggregated variable, scalar and constant; if the variable resolves to a fixed variable,\n  \"scalar\" will be 0.0 and the value of the sum will be stored in \"constant\"; a multi-aggregation\n  with only one active variable (this can happen due to fixings after the multi-aggregation),\n  is treated like an aggregation; if the multi-aggregation constant is infinite, \"scalar\" will be 0.0\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbvarSum(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transforms given variable, scalar and constant to the corresponding active, fixed, or\n  multi-aggregated variable, scalar and constant; if the variable resolves to a fixed variable,\n  \"scalar\" will be 0.0 and the value of the sum will be stored in \"constant\"; a multi-aggregation\n  with only one active variable (this can happen due to fixings after the multi-aggregation),\n  is treated like an aggregation; if the multi-aggregation constant is infinite, \"scalar\" will be 0.0\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbvarSumExact(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        scalar: *mut SCIP_RATIONAL,
        constant: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return for given variables all their active counterparts; all active variables will be pairwise different\n  @note It does not hold that the first output variable is the active variable for the first input variable.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetActiveVars(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the reduced costs of the variable in the current node's LP relaxation;\n  the current node has to have a feasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarRedcost(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the implied reduced costs of the variable in the current node's LP relaxation;\n  the current node has to have a feasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING\n\n  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarImplRedcost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the Farkas coefficient of the variable in the current node's LP relaxation;\n  the current node has to have an infeasible LP.\n\n  returns SCIP_INVALID if the variable is active but not in the current LP;\n  returns 0 if the variable has been aggregated out or fixed in presolving.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarFarkasCoef(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns lower bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarLbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns upper bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarUbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns lower or upper bound of variable directly before or after the bound change given by the bound change index\n  was applied"]
    pub fn SCIPgetVarBdAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the binary variable was fixed at the time given by the bound change index"]
    pub fn SCIPgetVarWasFixedAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets solution value for variable in current node\n\n  @return solution value for variable in current node\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSol(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets solution values of multiple variables in current node\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSols(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the solution value of all variables in the global relaxation solution to zero\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearRelaxSolVals(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the value of the given variable in the global relaxation solution;\n  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;\n  You can use SCIPclearRelaxSolVals() to set all values to zero, initially;\n  after setting all solution values, you have to call SCIPmarkRelaxSolValid()\n  to inform SCIP that the stored solution is valid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This method incrementally updates the objective value of the relaxation solution. If the whole solution\n        should be updated, using SCIPsetRelaxSolVals() instead or calling SCIPclearRelaxSolVals() before setting\n        the first value to reset the solution and the objective value to 0 may help the numerics."]
    pub fn SCIPsetRelaxSolVal(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the values of the given variables in the global relaxation solution and informs SCIP about the validity\n  and whether the solution can be enforced via linear cuts;\n  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;\n  the solution is automatically cleared, s.t. all other variables get value 0.0\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolVals(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the values of the variables in the global relaxation solution to the values in the given primal solution\n  and informs SCIP about the validity and whether the solution can be enforced via linear cuts;\n  the relaxation solution can be filled by the relaxation handlers and might be used by heuristics and for separation\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolValsSol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        sol: *mut SCIP_SOL,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the relaxation solution is valid\n\n  @return TRUE, if the relaxation solution is valid; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisRelaxSolValid(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " informs SCIP that the relaxation solution is valid and whether the relaxation can be enforced through linear cuts\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolValid(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs SCIP, that the relaxation solution is invalid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolInvalid(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the relaxation solution value of the given variable\n\n  @return the relaxation solution value of the given variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the relaxation solution objective value\n\n  @return the objective value of the relaxation solution\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolObj(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " determine which branching direction should be evaluated first by strong branching\n\n  @return TRUE iff strong branching should first evaluate the down child\n"]
    pub fn SCIPisStrongbranchDownFirst(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " start strong branching - call before any strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note if propagation is enabled, strong branching is not done directly on the LP, but probing nodes are created\n        which allow to perform propagation but also creates some overhead"]
    pub fn SCIPstartStrongbranch(
        scip: *mut SCIP,
        enablepropagation: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " end strong branching - call after any strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendStrongbranch(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on column variable with fractional value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarStrongbranchFrac(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information with previous domain propagation on column variable\n\n  Before calling this method, the strong branching mode must have been activated by calling SCIPstartStrongbranch();\n  after strong branching was done for all candidate variables, the strong branching mode must be ended by\n  SCIPendStrongbranch(). Since this method applies domain propagation before strongbranching, propagation has to be be\n  enabled in the SCIPstartStrongbranch() call.\n\n  Before solving the strong branching LP, domain propagation can be performed. The number of propagation rounds\n  can be specified by the parameter @p maxproprounds.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @warning When using this method, LP banching candidates and solution values must be copied beforehand, because\n           they are updated w.r.t. the strong branching LP solution."]
    pub fn SCIPgetVarStrongbranchWithPropagation(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
        lpobjval: f64,
        itlim: ::std::os::raw::c_int,
        maxproprounds: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        ndomredsdown: *mut ::std::os::raw::c_longlong,
        ndomredsup: *mut ::std::os::raw::c_longlong,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
        newlbs: *mut f64,
        newubs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on column variable x with integral LP solution value (val); that is, the down branch\n  is (val -1.0) and the up brach ins (val +1.0)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note If the integral LP solution value is the lower or upper bound of the variable, the corresponding branch will be\n        marked as infeasible. That is, the valid pointer and the infeasible pointer are set to TRUE."]
    pub fn SCIPgetVarStrongbranchInt(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on column variables with fractional values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesFrac(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on column variables with integral values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesInt(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get LP solution status of last strong branching call (currently only works for strong branching with propagation)"]
    pub fn SCIPgetLastStrongbranchLPSolStat(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
    ) -> SCIP_LPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on COLUMN variable of the last SCIPgetVarStrongbranch() call;\n  returns values of SCIP_INVALID, if strong branching was not yet called on the given variable;\n  keep in mind, that the returned old values may have nothing to do with the current LP solution\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarStrongbranchLast(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        solval: *mut f64,
        lpobjval: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets strong branching information for a column variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetVarStrongbranchData(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lpobjval: f64,
        primsol: f64,
        down: f64,
        up: f64,
        downvalid: ::std::os::raw::c_uint,
        upvalid: ::std::os::raw::c_uint,
        iter: ::std::os::raw::c_longlong,
        itlim: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " rounds the current solution and tries it afterwards; if feasible, adds it to storage\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryStrongbranchLPSol(
        scip: *mut SCIP,
        foundsol: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the\n  given variable, or -1 if strong branching was never applied to the variable in current run\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchNode(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " if strong branching was already applied on the variable at the current node, returns the number of LPs solved after\n  the LP where the strong branching on this variable was applied;\n  if strong branching was not yet applied on the variable at the current node, returns INT_MAX\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchLPAge(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarNStrongbranchs(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " adds given values to lock numbers of type @p locktype of variable for rounding\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddVarLocksType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds given values to lock numbers of variable for rounding\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note This method will always add variable locks of type model"]
    pub fn SCIPaddVarLocks(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;\n  this method should be called whenever the lock status of a variable in a constraint changes, for example if\n  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were\n  added or removed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " remove locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;\n  this method should be called whenever the lock status of a variable in a constraint changes, for example if\n  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were\n  added or removed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's objective value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPchgVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds value to variable's objective value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, addobj: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) lower bound value;\n  does not change the bounds of the variable\n\n  @return adjusted lower bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, lb: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) lower bound value;\n  does not change the bounds of the variable\n\n  @return adjusted lower bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarLbExactFloat(scip: *mut SCIP, var: *mut SCIP_VAR, lb: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) upper bound value;\n  does not change the bounds of the variable\n\n  @return adjusted upper bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, ub: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) upper bound value;\n  does not change the bounds of the variable\n\n  @return adjusted upper bound for the given variable; the bound of the variable is not changed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarUbExactFloat(scip: *mut SCIP, var: *mut SCIP_VAR, ub: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, changes lower bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, changes exact lower bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLbExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, changes upper bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, changes exact upper bound of variable in the problem, in preprocessing, or in current node;\n  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such\n  that in conflict analysis, this change is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUbExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any\n  inference information in the bound change, such that in conflict analysis, this change is treated like a branching\n  decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any\n  inference information in the bound change, such that in conflict analysis, this change is treated like a branching\n  decision\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes global lower bound of variable; if possible, adjust bound to integral value; also tightens the local bound,\n  if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes global upper bound of variable; if possible, adjust bound to integral value; also tightens the local bound,\n  if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lazy lower bound of the variable, this is only possible if the variable is not in the LP yet\n\n  Lazy bounds are bounds that are already enforced by constraints and the objective function.\n  Setting a lazy lower bound has the consequence that for variables which lower bound equals the lazy lower bound,\n  the lower bound does not need to be passed on to the LP solver.\n  This is especially useful in a column generation (branch-and-price) setting.\n\n  @attention If the variable has a global lower bound below lazylb, then the global lower bound is tightened to\n     lazylb by a call to SCIPchgVarLbGlobal().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazylb: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lazy upper bound of the variable, this is only possible if the variable is not in the LP yet\n\n  Lazy bounds are bounds that are already enforced by constraints and the objective function.\n  Setting a lazy upper bound has the consequence that for variables which upper bound equals the lazy upper bound,\n  the upper bound does not need to be passed on to the LP solver.\n  This is especially useful in a column generation (branch-and-price) setting.\n\n  @attention If the variable has a global upper bound above lazyub, then the global upper bound is tightened to\n     lazyub by a call to SCIPchgVarUbGlobal().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazyub: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes exact lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLbExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes exact upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  doesn't store any inference information in the bound change, such that in conflict analysis, this change\n  is treated like a branching decision\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUbExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening\n  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is\n  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change\n\n  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method\n        changes first the lowerbound by calling SCIPinferVarLbCons and second the upperbound by calling\n        SCIPinferVarUbCons\n\n  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via\n        SCIPgetVars()) gets re-sorted.\n\n  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason for the\n  deduction of the fixing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbConsExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  than the current bound; if possible, adjusts bound to integral value;\n  the given inference constraint is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets resorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbConsExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening\n  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is\n  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change\n\n  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method\n        changes first the lowerbound by calling SCIPinferVarLbProp and second the upperbound by calling\n        SCIPinferVarUbProp\n\n  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via\n        SCIPgetVars()) gets re-sorted.\n\n  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason\n  for the deduction of the bound change\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;\n  the given inference propagator is stored, such that the conflict analysis is able to find out the reason for the\n  deduction of the fixing\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes global lower bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;\n  also tightens the local bound, if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes global upper bound of variable in preprocessing or in the current node, if the new bound is tighter\n  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;\n  also tightens the local bound, if the global bound is better than the local bound\n\n  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via\n           SCIPgetVars()) gets re-sorted.\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global lower bound computed by adding the global bounds from all aggregation variables\n\n  This global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbGlobal.\n\n  @return the global lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global upper bound computed by adding the global bounds from all aggregation variables\n\n  This global bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbGlobal.\n\n  @return the global upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local lower bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbLocal.\n\n  @return the local lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local lower bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbLocal.\n\n  @return the local lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbLocalExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local upper bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbLocal.\n\n  @return the local upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local upper bound computed by adding the local bounds from all aggregation variables\n\n  This local bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is not updated if bounds of aggregation variables are changing\n  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbLocal.\n\n  @return the local upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbLocalExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global lower bound computed by adding the global bounds from all\n  aggregation variables, this global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global upper bound computed by adding the global bounds from all\n  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local lower bound computed by adding the local bounds from all\n  aggregation variables, this lower bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local upper bound computed by adding the local bounds from all\n  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is\n  not updated if bounds of aggregation variables are changing\n\n  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns solution value and index of variable lower bound that is closest to the variable's value in the given primal\n  solution or current LP solution if no primal solution is given; returns an index of -1 if no variable lower bound is\n  available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvlb: *mut f64,
        closestvlbidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns solution value and index of variable upper bound that is closest to the variable's value in the given primal solution;\n  or current LP solution if no primal solution is given; returns an index of -1 if no variable upper bound is available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvub: *mut f64,
        closestvubidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs variable x about a globally valid variable lower bound x >= b*z + d with integer variable z;\n  if z is binary, the corresponding valid implication for z is also added;\n  if z is non-continuous and 1/b not too small, the corresponding valid upper/lower bound\n  z <= (x-d)/b or z >= (x-d)/b (depending on the sign of of b) is added, too;\n  improves the global bounds of the variable and the vlb variable if possible\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vlbvar: *mut SCIP_VAR,
        vlbcoef: f64,
        vlbconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs variable x about a globally valid variable upper bound x <= b*z + d with integer variable z;\n  if z is binary, the corresponding valid implication for z is also added;\n  if z is non-continuous and 1/b not too small, the corresponding valid lower/upper bound\n  z >= (x-d)/b or z <= (x-d)/b (depending on the sign of of b) is added, too;\n  improves the global bounds of the variable and the vlb variable if possible\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vubvar: *mut SCIP_VAR,
        vubcoef: f64,
        vubconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs binary variable x about a globally valid implication:  x == 0 or x == 1  ==>  y <= b  or  y >= b;\n  also adds the corresponding implication or variable bound to the implied variable;\n  if the implication is conflicting, the variable is fixed to the opposite value;\n  if the variable is already fixed to the given value, the implication is performed immediately;\n  if the implication is redundant with respect to the variables' global bounds, it is ignored\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarImplication(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
        implbound: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a clique information to SCIP, stating that at most one of the given binary variables can be set to 1;\n  if a variable appears twice in the same clique, the corresponding implications are performed\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddClique(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        values: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        isequation: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into cliques; takes into account independent clique components\n\n  The algorithm performs the following steps:\n  - recomputes connected components of the clique table, if necessary\n  - computes a clique partition for every connected component greedily.\n  - relabels the resulting clique partition such that it satisfies the description below\n\n  afterwards the output array contains one value for each variable, such that two variables got the same value iff they\n  were assigned to the same clique;\n  the first variable is always assigned to clique 0, and a variable can only be assigned to clique i if at least one of\n  the preceding variables was assigned to clique i-1;\n  for each clique at most 1 variables can be set to TRUE in a feasible solution;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        probtoidxmap: *mut *mut ::std::os::raw::c_int,
        probtoidxmapsize: *mut ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into negated cliques;\n  afterwards the output array contains one value for each variable, such that two variables got the same value iff they\n  were assigned to the same negated clique;\n  the first variable is always assigned to clique 0 and a variable can only be assigned to clique i if at least one of\n  the preceding variables was assigned to clique i-1;\n  for each clique with n_c variables at least n_c-1 variables can be set to TRUE in a feasible solution;\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcNegatedCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        probtoidxmap: *mut *mut ::std::os::raw::c_int,
        probtoidxmapsize: *mut ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " force SCIP to clean up all cliques; cliques do not get automatically cleaned up after presolving. Use\n  this method to prevent inactive variables in cliques when retrieved via SCIPgetCliques()\n\n  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcleanupCliques(
        scip: *mut SCIP,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of cliques in the clique table\n\n  @return number of cliques in the clique table\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliques(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the number of cliques created so far by the cliquetable\n\n  @return number of cliques created so far by the cliquetable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliquesCreated(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the array of cliques in the clique table\n\n  @return array of cliques in the clique table\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCliques(scip: *mut SCIP) -> *mut *mut SCIP_CLIQUE;
}
unsafe extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;\n  the variables must be active binary variables;\n  if regardimplics is FALSE, only the cliques in the clique table are looked at;\n  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded\n\n  @return TRUE, if there is a clique that contains both variable/clique pairs; FALSE, otherwise\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note a variable with it's negated variable are NOT! in a clique\n  @note a variable with itself are in a clique"]
    pub fn SCIPhaveVarsCommonClique(
        scip: *mut SCIP,
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " writes the clique graph to a gml file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n\n  @note there can be duplicated arcs in the output file\n\n  If @p writenodeweights is true, only nodes corresponding to variables that have a fractional value and only edges\n  between such nodes are written."]
    pub fn SCIPwriteCliqueGraph(
        scip: *mut SCIP,
        fname: *const ::std::os::raw::c_char,
        writenodeweights: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Removes (irrelevant) variable from all its global structures, i.e. cliques, implications and variable bounds.\n  This is an advanced method which should be used with care.\n\n  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPremoveVarFromGlobalStructures(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the branch factor of the variable; this value can be used in the branching methods to scale the score\n  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchfactor: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " scales the branch factor of the variable with the given value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPscaleVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        scale: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds the given value to the branch factor of the variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addfactor: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the branch priority of the variable; variables with higher branch priority are always preferred to variables\n  with lower priority in selection of branching variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING\n\n @note the default branching priority is 0"]
    pub fn SCIPchgVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the branch priority of the variable to the given value, if it is larger than the current priority\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds the given value to the branch priority of the variable\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the branch direction of the variable (-1: prefer downwards branch, 0: automatic selection, +1: prefer upwards\n  branch)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchDirection(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdirection: SCIP_BRANCHDIR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes type of variable in the problem;\n\n  @warning This type change might change the variable array returned from SCIPgetVars() and SCIPgetVarsData();\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n\n  @note If SCIP is already beyond the SCIP_STAGE_PROBLEM and a original variable is passed, the variable type of the\n        corresponding transformed variable is changed; the type of the original variable does not change\n\n  @note If the type changes from a continuous variable to a non-continuous variable the bounds of the variable get\n        adjusted w.r.t. to integrality information"]
    pub fn SCIPchgVarType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vartype: SCIP_VARTYPE,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes implied integral type of variable in the problem\n\n  @warning This type change might change the variable array returned from SCIPgetVars() and SCIPgetVarsData();\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n\n  @note If SCIP is already beyond the SCIP_STAGE_PROBLEM and a original variable is passed, the implied integral type of the\n        corresponding transformed variable is changed; the type of the original variable does not change\n\n  @note If the implied integral type is adjusted to weak or strong for a continuous variable, the bounds of the variable get\n        adjusted w.r.t. to integrality information"]
    pub fn SCIPchgVarImplType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        impltype: SCIP_IMPLINTTYPE,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " in problem creation and solving stage, both bounds of the variable are set to the given value;\n  in presolving stage, the variable is converted into a fixed variable, and bounds are changed respectively;\n  conversion into a fixed variable changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders arrays returned from the SCIPvarGetImpl...() methods invalid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        fixed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " in problem creation and solving stage, both bounds of the variable are set to the given value;\n  in presolving stage, the variable is converted into a fixed variable, and bounds are changed respectively;\n  conversion into a fixed variable changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders arrays returned from the SCIPvarGetImpl...() methods invalid\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVarExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: *mut SCIP_RATIONAL,
        infeasible: *mut ::std::os::raw::c_uint,
        fixed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " From a given equality a*x + b*y == c, aggregates one of the variables and removes it from the set of\n  active problem variables. This changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders the arrays returned from the SCIPvarGetImpl...() methods for the two variables invalid.\n  In the first step, the equality is transformed into an equality with active problem variables\n  a'*x' + b'*y' == c'. If x' == y', this leads to the detection of redundancy if a' == -b' and c' == 0,\n  of infeasibility, if a' == -b' and c' != 0, or to a variable fixing x' == c'/(a'+b') (and possible\n  infeasibility) otherwise.\n  In the second step, the variable to be aggregated is chosen among x' and y', prefering a less strict variable\n  type as aggregation variable (i.e. continuous variables are preferred over implicit integers, implicit integers\n  over integers, and integers over binaries). If none of the variables is continuous, it is tried to find an integer\n  aggregation (i.e. integral coefficients a'' and b'', such that a''*x' + b''*y' == c''). This can lead to\n  the detection of infeasibility (e.g. if c'' is fractional), or to a rejection of the aggregation (denoted by\n  aggregated == FALSE), if the resulting integer coefficients are too large and thus numerically instable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - redundant:  the equality can be deleted from the constraint set\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaggregateVars(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        vary: *mut SCIP_VAR,
        scalarx: f64,
        scalary: f64,
        rhs: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        redundant: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " From a given equality a*x + b*y == c, aggregates one of the variables and removes it from the set of\n  active problem variables. This changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),\n  and also renders the arrays returned from the SCIPvarGetImpl...() methods for the two variables invalid.\n  In the first step, the equality is transformed into an equality with active problem variables\n  a'*x' + b'*y' == c'. If x' == y', this leads to the detection of redundancy if a' == -b' and c' == 0,\n  of infeasibility, if a' == -b' and c' != 0, or to a variable fixing x' == c'/(a'+b') (and possible\n  infeasibility) otherwise.\n  In the second step, the variable to be aggregated is chosen among x' and y', prefering a less strict variable\n  type as aggregation variable (i.e. continuous variables are preferred over implicit integers, implicit integers\n  over integers, and integers over binaries). If none of the variables is continuous, it is tried to find an integer\n  aggregation (i.e. integral coefficients a'' and b'', such that a''*x' + b''*y' == c''). This can lead to\n  the detection of infeasibility (e.g. if c'' is fractional), or to a rejection of the aggregation (denoted by\n  aggregated == FALSE), if the resulting integer coefficients are too large and thus numerically instable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - redundant:  the equality can be deleted from the constraint set\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaggregateVarsExact(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        vary: *mut SCIP_VAR,
        scalarx: *mut SCIP_RATIONAL,
        scalary: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        infeasible: *mut ::std::os::raw::c_uint,
        redundant: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " converts variable into multi-aggregated variable; this changes the variable array returned from\n  SCIPgetVars() and SCIPgetVarsData();\n\n  @warning The integrality condition is not checked anymore on the multi-aggregated variable. You must not\n           multi-aggregate an integer variable without being sure, that integrality on the aggregation variables\n           implies integrality on the aggregated variable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPmultiaggregateVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        naggvars: ::std::os::raw::c_int,
        aggvars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        constant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " converts variable into exact multi-aggregated variable; this changes the variable array returned from\n  SCIPgetVars() and SCIPgetVarsData();\n\n  @warning The integrality condition is not checked anymore on the multi-aggregated variable. You must not\n           multi-aggregate an integer variable without being sure, that integrality on the aggregation variables\n           implies integrality on the aggregated variable.\n\n  The output flags have the following meaning:\n  - infeasible: the problem is infeasible\n  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPmultiaggregateVarExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        naggvars: ::std::os::raw::c_int,
        aggvars: *mut *mut SCIP_VAR,
        scalars: *mut *mut SCIP_RATIONAL,
        constant: *mut SCIP_RATIONAL,
        infeasible: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether aggregation of variables is not allowed"]
    pub fn SCIPdoNotAggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether multi-aggregation is disabled"]
    pub fn SCIPdoNotMultaggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable is not allowed to be aggregated"]
    pub fn SCIPdoNotAggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether variable is not allowed to be multi-aggregated"]
    pub fn SCIPdoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks whether a loose variable can be used in a new aggregation with given coefficient\n\n Checks whether multiplying the bounds on the coefficient with which the variable appears in aggregations\n (SCIPvarGetMinAggrCoef(), SCIPvarGetMaxAggrCoef()) by the given scalar would exceed acceptable values\n (numerics/sumepsilon and 1.0 / numerics/sumepsilon).\n\n  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPisVarAggrCoefAcceptable(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        scalar: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether strong dual reductions are allowed during propagation and presolving\n\n  @note A reduction is called strong dual, if it may discard feasible/optimal solutions, but leaves at least one\n        optimal solution intact. Often such reductions are based on analyzing the objective function and variable\n        locks."]
    pub fn SCIPallowStrongDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether weak dual reductions are allowed during propagation and presolving\n\n  @note A reduction is called weak dual, if it may discard feasible solutions, but leaves at all optimal solutions\n        intact. Often such reductions are based on analyzing the objective function, reduced costs, and/or dual LPs."]
    pub fn SCIPallowWeakDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the variable that it must not be aggregated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n\n  @note There exists no \"unmark\" method since it has to be ensured that if a plugin requires that a variable is not\n        aggregated that this is will be the case."]
    pub fn SCIPmarkDoNotAggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks the variable that it must not be multi-aggregated\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n\n  @note There exists no \"unmark\" method since it has to be ensured that if a plugin requires that a variable is not\n        multi-aggregated that this is will be the case."]
    pub fn SCIPmarkDoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables the collection of statistics for a variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableVarHistory(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " disables the collection of any statistic for a variable\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableVarHistory(scip: *mut SCIP);
}
unsafe extern "C" {
    #[doc = " updates the pseudo costs of the given variable and the global pseudo costs after a change of \"solvaldelta\" in the\n  variable's solution value and resulting change of \"objdelta\" in the in the LP's objective value;\n  the update is ignored, if the objective value difference is infinite\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPupdateVarPseudocost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
        objdelta: f64,
        weight: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates the ancestor pseudo costs of the given variable and the global ancestor pseudo costs after a change of \"solvaldelta\" in the\n  variable's solution value and resulting change of \"objdelta\" in the in the LP's objective value;\n  the update is ignored, if the objective value difference is infinite\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPupdateVarAncPseudocost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
        objdelta: f64,
        weight: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value\n\n  @return the variable's pseudo cost value for the given change of the variable's LP value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVal(scip: *mut SCIP, var: *mut SCIP_VAR, solvaldelta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's ancestral pseudo cost value for the given change of the variable's LP value\n\n  @return the variable's ancestral pseudo cost value for the given change of the variable's LP value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAncPseudocostVal(scip: *mut SCIP, var: *mut SCIP_VAR, solvaldelta: f64)
    -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost value for the given change of the variable's LP value,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostValCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction\n\n  @return the variable's pseudo cost value for the given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocost(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost value for the given direction,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction\n\n  @return the variable's (possible fractional) number of pseudo cost updates for the given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCount(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @return the variable's (possible fractional) number of pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCountCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's (possible fractional) number of ancestor pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @return the variable's (possible fractional) number of ancestor pseudo cost updates for the given direction,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAncPseudocostCountCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " get pseudo cost variance of the variable, either for entire solve or only for current branch and bound run\n\n  @return returns the (corrected) variance of pseudo code information collected so far.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVariance(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates a confidence bound for this variable under the assumption of normally distributed pseudo costs\n\n  The confidence bound \\f$ \\theta \\geq 0\\f$ denotes the interval borders \\f$ [X - \\theta, \\ X + \\theta]\\f$, which contains\n  the true pseudo costs of the variable, i.e., the expected value of the normal distribution, with a probability\n  of 2 * clevel - 1.\n\n  @return value of confidence bound for this variable"]
    pub fn SCIPcalculatePscostConfidenceBound(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " check if variable pseudo-costs have a significant difference in location. The significance depends on\n  the choice of \\p clevel and on the kind of tested hypothesis. The one-sided hypothesis, which\n  should be rejected, is that fracy * mu_y >= fracx * mu_x, where mu_y and mu_x denote the\n  unknown location means of the underlying pseudo-cost distributions of x and y.\n\n  This method is applied best if variable x has a better pseudo-cost score than y. The method hypothesizes that y were actually\n  better than x (despite the current information), meaning that y can be expected to yield branching\n  decisions as least as good as x in the long run. If the method returns TRUE, the current history information is\n  sufficient to safely rely on the alternative hypothesis that x yields indeed a better branching score (on average)\n  than y.\n\n  @note The order of x and y matters for the one-sided hypothesis\n\n  @note set \\p onesided to FALSE if you are not sure which variable is better. The hypothesis tested then reads\n        fracy * mu_y == fracx * mu_x vs the alternative hypothesis fracy * mu_y != fracx * mu_x.\n\n  @return TRUE if the hypothesis can be safely rejected at the given confidence level"]
    pub fn SCIPsignificantVarPscostDifference(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        fracx: f64,
        vary: *mut SCIP_VAR,
        fracy: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
        onesided: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " tests at a given confidence level whether the variable pseudo-costs only have a small probability to\n  exceed a \\p threshold. This is useful to determine if past observations provide enough evidence\n  to skip an expensive strong-branching step if there is already a candidate that has been proven to yield an improvement\n  of at least \\p threshold.\n\n  @note use \\p clevel to adjust the level of confidence. For SCIP_CONFIDENCELEVEL_MIN, the method returns TRUE if\n        the estimated probability to exceed \\p threshold is less than 25 %.\n\n  @see  SCIP_Confidencelevel for a list of available levels. The used probability limits refer to the one-sided levels\n        of confidence.\n\n  @return TRUE if the variable pseudo-cost probabilistic model is likely to be smaller than \\p threshold\n          at the given confidence level \\p clevel."]
    pub fn SCIPpscostThresholdProbabilityTest(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        frac: f64,
        threshold: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " check if the current pseudo cost relative error in a direction violates the given threshold. The Relative\n  Error is calculated at a specific confidence level\n\n  @return TRUE if relative error in variable pseudo costs is smaller than \\p threshold"]
    pub fn SCIPisVarPscostRelerrorReliable(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        threshold: f64,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value\n\n  @return the variable's pseudo cost score value for the given LP solution value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScore(scip: *mut SCIP, var: *mut SCIP_VAR, solval: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's discounted pseudo cost score value for the given LP solution value.\n\n  This combines both pscost and ancpscost fields.\n\n  @return the variable's discounted pseudo cost score value for the given LP solution value,\n  combining both pscost and ancpscost fields.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarDPseudocostScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
        discountfac: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value,\n  only using the pseudo cost information of the current run\n\n  @return the variable's pseudo cost score value for the given LP solution value,\n  only using the pseudo cost information of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's VSIDS value\n\n  @return the variable's VSIDS value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDS(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's VSIDS value only using conflicts of the current run\n\n  @return the variable's VSIDS value only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDSCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's conflict score value\n\n  @return the variable's conflict score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's conflict score value only using conflicts of the current run\n\n  @return the variable's conflict score value only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's conflict length score\n\n  @return the variable's conflict length score\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's conflict length score only using conflicts of the current run\n\n  @return the variable's conflict length score only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average conflict length\n\n  @return the variable's average conflict length\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlength(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average  conflict length only using conflicts of the current run\n\n  @return the variable's average conflict length only using conflicts of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlengthCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction;\n  if branching on the variable in the given direction was yet evaluated, the average number of inferences\n  over all variables for branching in the given direction is returned\n\n  @return the average number of inferences found after branching on the variable in given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferences(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR)
    -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction in the current run;\n  if branching on the variable in the given direction was yet evaluated, the average number of inferences\n  over all variables for branching in the given direction is returned\n\n  @return the average number of inferences found after branching on the variable in given direction in the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferencesCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average inference score value\n\n  @return the variable's average inference score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average inference score value only using inferences of the current run\n\n  @return the variable's average inference score value only using inferences of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " initializes the upwards and downwards pseudocosts, conflict scores, conflict lengths, inference scores, cutoff scores\n  of a variable to the given values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downpscost: f64,
        uppscost: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initializes the upwards and downwards conflict scores, conflict lengths, inference scores, cutoff scores of a\n  variable w.r.t. a value by the given values (SCIP_VALUEHISTORY)\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarValueBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        value: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction;\n  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs\n  over all variables for branching in the given direction is returned\n\n  @return the average number of cutoffs found after branching on the variable in given direction\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffs(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction in the current run;\n  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs\n  over all variables for branching in the given direction is returned\n\n  @return the average number of cutoffs found after branching on the variable in given direction in the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffsCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average cutoff score value\n\n  @return the variable's average cutoff score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average cutoff score value, only using cutoffs of the current run\n\n  @return the variable's average cutoff score value, only using cutoffs of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given\n  factor\n\n  @return the variable's average inference/cutoff score value\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given\n  factor, only using inferences and cutoffs of the current run\n\n  @return the variable's average inference/cutoff score value, only using inferences and cutoffs of the current run\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the variable's average GMI efficacy score value\n\n  @return the variable's average GMI efficacy score value (for when it was fractional and basic in the LP)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the variable's avg GMI efficacy score value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincVarGMISumScore(scip: *mut SCIP, var: *mut SCIP_VAR, gmieff: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the variable's last GMI efficacy score value\n\n  @return the variable's last GMI efficacy score value (for when it was fractional and basic in the LP)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarLastGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the variable's last GMI efficacy score value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsetVarLastGMIScore(scip: *mut SCIP, var: *mut SCIP_VAR, gmieff: f64)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs variable information to file stream via the message system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVar(scip: *mut SCIP, var: *mut SCIP_VAR, file: *mut FILE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's exact objective value\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPchgVarObjExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newobj: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes exact global upper bound of variable;\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n"]
    pub fn SCIPchgVarUbGlobalExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes exact global lower bound of variable;\n\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n"]
    pub fn SCIPchgVarLbGlobalExact(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print the given variables and rational coefficients as linear sum in the following form\n  c1 \\<x1\\> + c2 \\<x2\\>   ... + cn \\<xn\\>\n\n  This string can be parsed by the method SCIPparseVarsLinearsum().\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_PROBLEM\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsLinearsumExact(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut *mut SCIP_RATIONAL,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Transforms a given linear sum of variables, that is a_1*x_1 + ... + a_n*x_n + c into a corresponding linear sum of\n  active variables, that is b_1*y_1 + ... + b_m*y_m + d.\n\n  If the number of needed active variables is greater than the available slots in the variable array, nothing happens\n  except that the required size is stored in the corresponding variable (requiredsize). Otherwise, the active variable\n  representation is stored in the variable array, scalar array and constant.\n\n  The reason for this approach is that we cannot reallocate memory, since we do not know how the memory has been\n  allocated (e.g., by a C++ 'new' or SCIP functions).\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  @note The resulting linear sum is stored into the given variable array, scalar array, and constant. That means the\n        given entries are overwritten.\n\n  @note That method can be used to convert a single variables into variable space of active variables. Therefore call\n        the method with the linear sum 1.0*x + 0.0."]
    pub fn SCIPgetProbvarLinearSumExact(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        scalars: *mut *mut SCIP_RATIONAL,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        constant: *mut SCIP_RATIONAL,
        requiredsize: *mut ::std::os::raw::c_int,
        mergemultiples: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Selects a variable from a set of candidates by strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n @note The variables in the lpcands array must have a fractional value in the current LP solution"]
    pub fn SCIPselectVarPseudoStrongBranching(
        scip: *mut SCIP,
        pseudocands: *mut *mut SCIP_VAR,
        skipdown: *mut ::std::os::raw::c_uint,
        skipup: *mut ::std::os::raw::c_uint,
        npseudocands: ::std::os::raw::c_int,
        npriopseudocands: ::std::os::raw::c_int,
        bestpseudocand: *mut ::std::os::raw::c_int,
        bestdown: *mut f64,
        bestup: *mut f64,
        bestscore: *mut f64,
        bestdownvalid: *mut ::std::os::raw::c_uint,
        bestupvalid: *mut ::std::os::raw::c_uint,
        provedbound: *mut f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the all variables full strong LP branching rule and includes it in SCIP"]
    pub fn SCIPincludeBranchruleAllfullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the cloud branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleCloud(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the distribution branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleDistribution(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculate the variable's distribution parameters (mean and variance) for the bounds specified in the arguments.\n  special treatment of infinite bounds necessary"]
    pub fn SCIPvarCalcDistributionParameters(
        scip: *mut SCIP,
        varlb: f64,
        varub: f64,
        vartype: SCIP_VARTYPE,
        impltype: SCIP_IMPLINTTYPE,
        mean: *mut f64,
        variance: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " calculates the cumulative distribution P(-infinity <= x <= value) that a normally distributed\n  random variable x takes a value between -infinity and parameter \\p value.\n\n  The distribution is given by the respective mean and deviation. This implementation\n  uses the error function erf()."]
    pub fn SCIPcalcCumulativeDistribution(
        scip: *mut SCIP,
        mean: f64,
        variance: f64,
        value: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the probability of satisfying an LP-row under the assumption\n  of uniformly distributed variable values.\n\n  For inequalities, we use the cumulative distribution function of the standard normal\n  distribution PHI(rhs - mu/sqrt(sigma2)) to calculate the probability\n  for a right hand side row with mean activity mu and variance sigma2 to be satisfied.\n  Similarly, 1 - PHI(lhs - mu/sqrt(sigma2)) is the probability to satisfy a left hand side row.\n  For equations (lhs==rhs), we use the centeredness measure p = min(PHI(lhs'), 1-PHI(lhs'))/max(PHI(lhs'), 1 - PHI(lhs')),\n  where lhs' = lhs - mu / sqrt(sigma2)."]
    pub fn SCIProwCalcProbability(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mu: f64,
        sigma2: f64,
        rowinfinitiesdown: ::std::os::raw::c_int,
        rowinfinitiesup: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " update the up- and downscore of a single variable after calculating the impact of branching on a\n  particular row, depending on the chosen score parameter"]
    pub fn SCIPupdateDistributionScore(
        scip: *mut SCIP,
        currentprob: f64,
        newprobup: f64,
        newprobdown: f64,
        upscore: *mut f64,
        downscore: *mut f64,
        scoreparam: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the full strong LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleFullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Selects a variable from a set of candidates by strong branching\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n @note The variables in the lpcands array must have a fractional value in the current LP solution"]
    pub fn SCIPselectVarStrongBranching(
        scip: *mut SCIP,
        lpcands: *mut *mut SCIP_VAR,
        lpcandssol: *mut f64,
        lpcandsfrac: *mut f64,
        skipdown: *mut ::std::os::raw::c_uint,
        skipup: *mut ::std::os::raw::c_uint,
        nlpcands: ::std::os::raw::c_int,
        npriolpcands: ::std::os::raw::c_int,
        ncomplete: ::std::os::raw::c_int,
        start: *mut ::std::os::raw::c_int,
        maxproprounds: ::std::os::raw::c_int,
        probingbounds: ::std::os::raw::c_uint,
        forcestrongbranch: ::std::os::raw::c_uint,
        bestcand: *mut ::std::os::raw::c_int,
        bestdown: *mut f64,
        bestup: *mut f64,
        bestscore: *mut f64,
        bestdownvalid: *mut ::std::os::raw::c_uint,
        bestupvalid: *mut ::std::os::raw::c_uint,
        provedbound: *mut f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the Gomory cut branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleGomory(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the inference history branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleInference(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the least infeasible LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleLeastinf(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the lookahead branching rule and includes it in SCIP"]
    pub fn SCIPincludeBranchruleLookahead(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the most infeasible LP branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleMostinf(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the multi-aggregated branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleMultAggr(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the nodereopt branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleNodereopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the pseudo cost branching rule and includes it in SCIP\n\n   @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchrulePscost(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " selects a branching variable, due to pseudo cost, from the given candidate array and returns this variable together\n  with a branching point"]
    pub fn SCIPselectBranchVarPscost(
        scip: *mut SCIP,
        branchcands: *mut *mut SCIP_VAR,
        branchcandssol: *mut f64,
        branchcandsscore: *mut f64,
        nbranchcands: ::std::os::raw::c_int,
        var: *mut *mut SCIP_VAR,
        brpoint: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the random branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleRandom(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the reliable pseudo cost branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleRelpscost(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " execution reliability pseudo cost branching with the given branching candidates"]
    pub fn SCIPexecRelpscostBranching(
        scip: *mut SCIP,
        branchcands: *mut *mut SCIP_VAR,
        branchcandssol: *mut f64,
        branchcandsfrac: *mut f64,
        nbranchcands: ::std::os::raw::c_int,
        executebranching: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the vanilla full strong branching rule and includes it in SCIP\n\n  @ingroup BranchingRuleIncludes"]
    pub fn SCIPincludeBranchruleVanillafullstrong(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recovers candidate variables and their scores from last vanilla full strong branching call"]
    pub fn SCIPgetVanillafullstrongData(
        scip: *mut SCIP,
        cands: *mut *mut *mut SCIP_VAR,
        candscores: *mut *mut f64,
        ncands: *mut ::std::os::raw::c_int,
        npriocands: *mut ::std::os::raw::c_int,
        bestcand: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the largestrepr tree compression and includes it in SCIP"]
    pub fn SCIPincludeComprLargestrepr(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the weakcompr tree compression and includes it in SCIP"]
    pub fn SCIPincludeComprWeakcompr(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for and constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrAnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an and constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsAnd(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsAnd(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsAnd() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicAnd(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in and constraint"]
    pub fn SCIPgetNVarsAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in and constraint"]
    pub fn SCIPgetVarsAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the resultant variable in and constraint"]
    pub fn SCIPgetResultantAnd(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " return if the variables of the AND-constraint are sorted with respect to their indices"]
    pub fn SCIPisAndConsSorted(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sort the variables of the AND-constraint with respect to their indices"]
    pub fn SCIPsortAndCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for Benders' decomposition and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBenders(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enforces Benders' constraints for given solution\n\n  This method is called from cons_benderslp and cons_benders. If the method is called from cons_benderslp, then the\n  solutions are not guaranteed to be integer feasible. This is because the default priority is set greater than the\n  integer constraint handler. If this method is called from cons_benders, then, because the default enforcement\n  priority is set less than that of the integer constraint handler, then it can be assumed that the solutions are\n  integer feasible.\n\n  The checkint flag indicates whether integer feasibility can be assumed. If it is not assumed, i.e. checkint ==\n  FALSE, then only the convex relaxations of the subproblems are solved. If integer feasibility is assumed, i.e.\n  checkint == TRUE, then the convex relaxations and the full CIP are solved to generate Benders' cuts and check\n  solution feasibility."]
    pub fn SCIPconsBendersEnforceSolution(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        conshdlr: *mut SCIP_CONSHDLR,
        result: *mut SCIP_RESULT,
        type_: SCIP_BENDERSENFOTYPE,
        checkint: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for benderslp constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBenderslp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for bound disjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrBounddisjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a bound disjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBounddisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsBounddisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsBounddisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicBounddisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a bound disjunction constraint with possibly redundant literals\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBounddisjunctionRedundant(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an and constraint with possibly redundant literals\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsBounddisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsBounddisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicBounddisjunctionRedundant(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        boundtypes: *mut SCIP_BOUNDTYPE,
        bounds: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in bound disjunction constraint"]
    pub fn SCIPgetNVarsBounddisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in bound disjunction constraint"]
    pub fn SCIPgetVarsBounddisjunction(scip: *mut SCIP, cons: *mut SCIP_CONS)
    -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array of bound types in bound disjunction constraint"]
    pub fn SCIPgetBoundtypesBounddisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut SCIP_BOUNDTYPE;
}
unsafe extern "C" {
    #[doc = " gets array of bounds in bound disjunction constraint"]
    pub fn SCIPgetBoundsBounddisjunction(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " creates the handler for cardinality constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCardinality(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an cardinality constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsCardinality(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        cardval: ::std::os::raw::c_int,
        indvars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an cardinality constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsCardinality() for the default constraint flag configuration\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be re-sorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicCardinality(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        cardval: ::std::os::raw::c_int,
        indvars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes cardinality value of cardinality constraint (i.e., right hand side of cardinality constraint)"]
    pub fn SCIPchgCardvalCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        cardval: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variable to cardinality constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        indvar: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " appends variable to cardinality constraint"]
    pub fn SCIPappendVarCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        indvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in cardinality constraint"]
    pub fn SCIPgetNVarsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in cardinality constraint"]
    pub fn SCIPgetVarsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets cardinality value of cardinality constraint (i.e., right hand side of cardinality constraint)"]
    pub fn SCIPgetCardvalCardinality(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of weights in cardinality constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsCardinality(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " creates the handler for conjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrConjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a conjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsConjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an and constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsConjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsConjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicConjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds constraint to the conjunction of constraints"]
    pub fn SCIPaddConsElemConjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        addcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for countsol constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCountsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the count command"]
    pub fn SCIPdialogExecCountPresolve(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the count command"]
    pub fn SCIPdialogExecCount(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " execution method of dialog for writing all solutions"]
    pub fn SCIPdialogExecWriteAllsolutions(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " execute counting"]
    pub fn SCIPcount(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns number of feasible solutions found as SCIP_Longint; if the number does not fit into\n  a SCIP_Longint the valid flag is set to FALSE"]
    pub fn SCIPgetNCountedSols(
        scip: *mut SCIP,
        valid: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns number of counted solutions as string"]
    pub fn SCIPgetNCountedSolsstr(
        scip: *mut SCIP,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffersize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns number of counted feasible subtrees"]
    pub fn SCIPgetNCountedFeasSubtrees(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " Method to get the sparse solution.\n\n  @note You get the pointer to the sparse solutions stored in the constraint handler (not a copy).\n\n  @note The sparse solutions are stored w.r.t. the active variables. This are the variables which got not removed\n        during presolving. For none active variables the value has to be computed depending on their aggregation\n        type. See for more details about that \\ref COLLECTALLFEASEBLES."]
    pub fn SCIPgetCountedSparseSols(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        sols: *mut *mut *mut SCIP_SPARSESOL,
        nsols: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " setting SCIP parameters for such that a valid counting process is possible"]
    pub fn SCIPsetParamsCountsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the constraint handler for cumulative constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrCumulative(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a cumulative constraint"]
    pub fn SCIPcreateConsCumulative(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an absolute power constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsCumulative(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsCumulative() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicCumulative(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set the left bound of effective horizon"]
    pub fn SCIPsetHminCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        hmin: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the left bound of the effective horizon"]
    pub fn SCIPgetHminCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " set the right bound of the effective horizon"]
    pub fn SCIPsetHmaxCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        hmax: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the right bound of effective horizon"]
    pub fn SCIPgetHmaxCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the start time variables of the cumulative constraint"]
    pub fn SCIPgetVarsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the number of start time variables of the cumulative constraint"]
    pub fn SCIPgetNVarsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the capacity of the cumulative constraint"]
    pub fn SCIPgetCapacityCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the durations of the cumulative constraint"]
    pub fn SCIPgetDurationsCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the demands of the cumulative constraint"]
    pub fn SCIPgetDemandsCumulative(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " check for the given starting time variables with their demands and durations if the cumulative conditions for the\n  given solution is satisfied"]
    pub fn SCIPcheckCumulativeCondition(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        violated: *mut ::std::os::raw::c_uint,
        cons: *mut SCIP_CONS,
        printreason: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " normalize cumulative condition"]
    pub fn SCIPnormalizeCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " searches for a time point within the cumulative condition were the cumulative condition can be split"]
    pub fn SCIPsplitCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: *mut ::std::os::raw::c_int,
        hmax: *mut ::std::os::raw::c_int,
        split: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " presolve cumulative condition w.r.t. effective horizon by detecting irrelevant variables"]
    pub fn SCIPpresolveCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        downlocks: *mut ::std::os::raw::c_uint,
        uplocks: *mut ::std::os::raw::c_uint,
        cons: *mut SCIP_CONS,
        irrelevants: *mut ::std::os::raw::c_uint,
        nfixedvars: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " propagate the given cumulative condition"]
    pub fn SCIPpropCumulativeCondition(
        scip: *mut SCIP,
        presoltiming: SCIP_PRESOLTIMING,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        cons: *mut SCIP_CONS,
        nchgbds: *mut ::std::os::raw::c_int,
        initialized: *mut ::std::os::raw::c_uint,
        explanation: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolve propagation w.r.t. the cumulative condition"]
    pub fn SCIPrespropCumulativeCondition(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        infervar: *mut SCIP_VAR,
        inferinfo: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
        explanation: *mut ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " this method visualizes the cumulative structure in GML format"]
    pub fn SCIPvisualizeConsCumulative(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets method to solve an individual cumulative condition"]
    pub fn SCIPsetSolveCumulative(
        scip: *mut SCIP,
        solveCumulative: ::std::option::Option<
            unsafe extern "C" fn(
                njobs: ::std::os::raw::c_int,
                ests: *mut f64,
                lsts: *mut f64,
                objvals: *mut f64,
                durations: *mut ::std::os::raw::c_int,
                demands: *mut ::std::os::raw::c_int,
                capacity: ::std::os::raw::c_int,
                hmin: ::std::os::raw::c_int,
                hmax: ::std::os::raw::c_int,
                timelimit: f64,
                memorylimit: f64,
                maxnodes: ::std::os::raw::c_longlong,
                solved: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                unbounded: *mut ::std::os::raw::c_uint,
                error: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves given cumulative condition as independent sub problem\n\n  @note If the problem was solved to the earliest start times (ests) and latest start times (lsts) array contain the\n        solution values; If the problem was not solved these two arrays contain the global bounds at the time the sub\n        solver was interrupted."]
    pub fn SCIPsolveCumulative(
        scip: *mut SCIP,
        njobs: ::std::os::raw::c_int,
        ests: *mut f64,
        lsts: *mut f64,
        objvals: *mut f64,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
        capacity: ::std::os::raw::c_int,
        hmin: ::std::os::raw::c_int,
        hmax: ::std::os::raw::c_int,
        timelimit: f64,
        memorylimit: f64,
        maxnodes: ::std::os::raw::c_longlong,
        solved: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        unbounded: *mut ::std::os::raw::c_uint,
        error: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the worst case resource profile, that is, all jobs are inserted with the earliest start and latest\n  completion time"]
    pub fn SCIPcreateWorstCaseProfile(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        durations: *mut ::std::os::raw::c_int,
        demands: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes w.r.t. the given worst case resource profile the first time point where the given capacity can be violated"]
    pub fn SCIPcomputeHmin(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " computes w.r.t. the given worst case resource profile the first time point where the given capacity is satisfied for sure"]
    pub fn SCIPcomputeHmax(
        scip: *mut SCIP,
        profile: *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates the handler for disjunction constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrDisjunction(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a disjunction constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsDisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        relaxcons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a cumulative constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsDisjunction(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsDisjunction() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicDisjunction(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        relaxcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds constraint to the disjunction of constraints"]
    pub fn SCIPaddConsElemDisjunction(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        addcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the fixedvar constraint handler and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrFixedvar(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for indicator constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrIndicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint in its most basic version, i. e., all constraint flags are set to their\n  basic value as explained for the method SCIPcreateConsIndicator(); all flags can be set via\n  SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsIndicator() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicIndicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a indicator constraint in a more generic version.\n\n  The key difference from SCIPcreateConsIndicator() is the activeone and lessthanineq Booleans.\n  If \\f$z = o\\f$, with \\f$o\\f$ the activeone flag, then:\n  if lessthanineq then \\f$a^T x \\leq b\\f$ holds, else the passed vectors are assumed to be of the form \\f$a^T x \\geq b\\f$.\n  The underlying linear constraint is always created as a less-than inequality."]
    pub fn SCIPcreateConsIndicatorGeneric(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        rhs: f64,
        activeone: ::std::os::raw::c_uint,
        lessthanineq: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicatorLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n  in a generic version, i. e., with a flag activeone indicating whether the constraint is active on\n  value 1 or 0 of the binary variable.\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration"]
    pub fn SCIPcreateConsIndicatorGenericLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
        activeone: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint and slack variable\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsIndicator(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note we assume that @a slackvar actually appears in @a lincons and we also assume that it takes\n  the role of a slack variable!\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicIndicatorLinCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        slackvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint in a generic version, i. e., with a flag\n  activeone indicating whether the constraint is active on value 1 or 0 of the binary variable; no slack variable is\n  specified\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note The linear constraint has to be single sided only, i.e., either rhs or lhs have to be infinite.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()\n\n  @see SCIPcreateConsIndicatorLinCons() for information about the basic constraint flag configuration"]
    pub fn SCIPcreateConsIndicatorGenericLinConsPure(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        activeone: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an indicator constraint with given linear constraint; no slack variable is specified\n\n  @note @a binvar is checked to be binary only later. This enables a change of the type in\n  procedures reading an instance.\n\n  @note The linear constraint has to be single sided only, i.e., either rhs or lhs have to be infinite.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsIndicatorLinConsPure(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        lincons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variable to the inequality of the indicator constraint"]
    pub fn SCIPaddVarIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the linear constraint corresponding to the indicator constraint (may be NULL)"]
    pub fn SCIPgetLinearConsIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " sets the linear constraint corresponding to the indicator constraint (may be NULL)"]
    pub fn SCIPsetLinearConsIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        lincons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets binary indicator variable for indicator constraint"]
    pub fn SCIPsetBinaryVarIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        binvar: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets activation value of an indicator constraint, TRUE for active on 1, FALSE for active on 0"]
    pub fn SCIPgetActiveOnIndicator(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets binary variable corresponding to indicator constraint. Returns the negative of the original binary variable if activeone was set to false"]
    pub fn SCIPgetBinaryVarIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " similar to SCIPgetBinaryVarIndicator but returns the original binary variable passed by the user."]
    pub fn SCIPgetBinaryVarIndicatorGeneric(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets slack variable corresponding to indicator constraint"]
    pub fn SCIPgetSlackVarIndicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " sets upper bound for slack variable corresponding to indicator constraint\n\n  Use with care if you know that the maximal violation of the corresponding constraint is at most @p ub. This bound\n  might be improved automatically during the solution process.\n\n  @pre This method should only be called if SCIP is in one of the following stages:\n       - \\ref SCIP_STAGE_INIT\n       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetSlackVarUb(scip: *mut SCIP, cons: *mut SCIP_CONS, ub: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether indicator constraint is violated w.r.t. sol"]
    pub fn SCIPisViolatedIndicator(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " based on values of other variables, computes slack and binary variable to turn constraint feasible"]
    pub fn SCIPmakeIndicatorFeasible(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " based on values of other variables, computes slack and binary variable to turn all constraints feasible"]
    pub fn SCIPmakeIndicatorsFeasible(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds additional linear constraint that is not connected with an indicator constraint, but can be used for separation"]
    pub fn SCIPaddLinearConsIndicator(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        lincons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds additional globally valid row that is not connected with an indicator constraint, but can be used for separation"]
    pub fn SCIPaddRowIndicator(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for the integrality constraint and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrIntegral(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for knapsack constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrKnapsack(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a knapsack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsKnapsack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a knapsack constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsKnapsack(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsKnapsack() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicKnapsack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds new item to knapsack constraint"]
    pub fn SCIPaddCoefKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the capacity of the knapsack constraint"]
    pub fn SCIPgetCapacityKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " changes capacity of the knapsack constraint\n\n  @note This method can only be called during problem creation stage (SCIP_STAGE_PROBLEM)"]
    pub fn SCIPchgCapacityKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        capacity: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of items in the knapsack constraint"]
    pub fn SCIPgetNVarsKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the array of variables in the knapsack constraint; the user must not modify this array!"]
    pub fn SCIPgetVarsKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the array of weights in the knapsack constraint; the user must not modify this array!"]
    pub fn SCIPgetWeightsKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> *mut ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the knapsack constraint in the current LP"]
    pub fn SCIPgetDualsolKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the knapsack constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given knapsack constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of the given knapsack constraint"]
    pub fn SCIPcreateRowKnapsack(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves knapsack problem in maximization form exactly using dynamic programming;\n  if needed, one can provide arrays to store all selected items and all not selected items\n\n @note in case you provide the solitems or nonsolitems array you also have to provide the counter part, as well\n\n @note the algorithm will first compute a greedy solution and terminate\n       if the greedy solution is proven to be optimal.\n       The dynamic programming algorithm runs with a time and space complexity\n       of O(nitems * capacity)."]
    pub fn SCIPsolveKnapsackExactly(
        scip: *mut SCIP,
        nitems: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        profits: *mut f64,
        capacity: ::std::os::raw::c_longlong,
        items: *mut ::std::os::raw::c_int,
        solitems: *mut ::std::os::raw::c_int,
        nonsolitems: *mut ::std::os::raw::c_int,
        nsolitems: *mut ::std::os::raw::c_int,
        nnonsolitems: *mut ::std::os::raw::c_int,
        solval: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves knapsack problem in maximization form approximately by solving the LP-relaxation of the problem using Dantzig's\n  method and rounding down the solution; if needed, one can provide arrays to store all selected items and all not\n  selected items"]
    pub fn SCIPsolveKnapsackApproximately(
        scip: *mut SCIP,
        nitems: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        profits: *mut f64,
        capacity: ::std::os::raw::c_longlong,
        items: *mut ::std::os::raw::c_int,
        solitems: *mut ::std::os::raw::c_int,
        nonsolitems: *mut ::std::os::raw::c_int,
        nsolitems: *mut ::std::os::raw::c_int,
        nnonsolitems: *mut ::std::os::raw::c_int,
        solval: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " separates different classes of valid inequalities for the 0-1 knapsack problem"]
    pub fn SCIPseparateKnapsackCuts(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sepa: *mut SCIP_SEPA,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        weights: *mut ::std::os::raw::c_longlong,
        capacity: ::std::os::raw::c_longlong,
        sol: *mut SCIP_SOL,
        usegubs: ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
        ncuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    pub fn SCIPseparateRelaxedKnapsack(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sepa: *mut SCIP_SEPA,
        nknapvars: ::std::os::raw::c_int,
        knapvars: *mut *mut SCIP_VAR,
        knapvals: *mut f64,
        valscale: f64,
        rhs: f64,
        sol: *mut SCIP_SOL,
        cutoff: *mut ::std::os::raw::c_uint,
        ncuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from knapsack constraints"]
    pub fn SCIPcleanupConssKnapsack(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        ndelconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for linear constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LinConsUpgrade {
    _unused: [u8; 0],
}
#[doc = "@addtogroup CONSHDLRS\n\n @{\n\n @name Linear Constraints\n\n This constraint handler handles linear constraints in their most general form. That is,\n \\f[\n   lhs \\leq \\sum_{i=1}^n a_i x_i \\leq rhs\n \\f]\n with \\f$a_i \\in Q, i = 1,\\dots,n\\f$, \\f$lhs\\in Q \\cup \\{-\\infty\\}\\f$, \\f$rhs\\in Q \\cup \\{\\infty\\}\\f$,\n and decision variables \\f$x_i, i = 1,\\dots,n\\f$ which can be binary, integer, or continuous.\n\n Furthermore, this header offers the upgrade functionality of a general linear constraint into a more specific\n constraint, such as a knapsack constraint, via SCIP_DECL_LINCONSUPGD() and SCIPincludeLinconsUpgrade()\n\n @{"]
pub type SCIP_LINCONSUPGRADE = SCIP_LinConsUpgrade;
unsafe extern "C" {
    #[doc = " includes a linear constraint update method into the linear constraint handler"]
    pub fn SCIPincludeLinconsUpgrade(
        scip: *mut SCIP,
        linconsupgd: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut SCIP_CONS,
                nvars: ::std::os::raw::c_int,
                vars: *mut *mut SCIP_VAR,
                vals: *mut f64,
                lhs: f64,
                rhs: f64,
                nposbin: ::std::os::raw::c_int,
                nnegbin: ::std::os::raw::c_int,
                nposint: ::std::os::raw::c_int,
                nnegint: ::std::os::raw::c_int,
                nposimpl: ::std::os::raw::c_int,
                nnegimpl: ::std::os::raw::c_int,
                nposimplbin: ::std::os::raw::c_int,
                nnegimplbin: ::std::os::raw::c_int,
                nposcont: ::std::os::raw::c_int,
                nnegcont: ::std::os::raw::c_int,
                ncoeffspone: ::std::os::raw::c_int,
                ncoeffsnone: ::std::os::raw::c_int,
                ncoeffspint: ::std::os::raw::c_int,
                ncoeffsnint: ::std::os::raw::c_int,
                ncoeffspfrac: ::std::os::raw::c_int,
                ncoeffsnfrac: ::std::os::raw::c_int,
                poscoeffsum: f64,
                negcoeffsum: f64,
                integral: ::std::os::raw::c_uint,
                upgdcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        priority: ::std::os::raw::c_int,
        conshdlrname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linear constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLinear(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLinear() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates by copying and captures a linear constraint"]
    pub fn SCIPcopyConsLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        sourcescip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        sourcevars: *mut *mut SCIP_VAR,
        sourcecoefs: *mut f64,
        lhs: f64,
        rhs: f64,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coefficient to linear constraint (if it is not zero)"]
    pub fn SCIPaddCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes coefficient of variable in linear constraint; deletes the variable if coefficient is zero; adds variable if\n  not yet contained in the constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPchgCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes variable from linear constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPdelCoefLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets left hand side of linear constraint"]
    pub fn SCIPgetLhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets right hand side of linear constraint"]
    pub fn SCIPgetRhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " changes left hand side of linear constraint"]
    pub fn SCIPchgLhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of linear constraint"]
    pub fn SCIPchgRhsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of variables in the linear constraint"]
    pub fn SCIPgetNVarsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the array of variables in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetVarsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the array of coefficient values in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetValsLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets the activity of the linear constraint in the given solution\n\n  @note if the solution contains values at infinity, this method will return SCIP_INVALID in case the activity\n        comprises positive and negative infinity contributions"]
    pub fn SCIPgetActivityLinear(scip: *mut SCIP, cons: *mut SCIP_CONS, sol: *mut SCIP_SOL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the feasibility of the linear constraint in the given solution"]
    pub fn SCIPgetFeasibilityLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the linear constraint in the current LP"]
    pub fn SCIPgetDualsolLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the linear constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given linear constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of the given linear constraint"]
    pub fn SCIPcreateRowLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to automatically convert a linear constraint into a more specific and more specialized constraint"]
    pub fn SCIPupgradeConsLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        upgdcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " performs linear constraint type classification as used for MIPLIB\n\n  iterates through all linear constraints and stores relevant statistics in the linear constraint statistics \\p linconsstats.\n\n  @note only constraints are iterated that belong to the linear constraint handler. If the problem has been presolved already,\n  constraints that were upgraded to more special types such as, e.g., varbound constraints, will not be shown correctly anymore.\n  Similarly, if specialized constraints were created through the API, these are currently not present."]
    pub fn SCIPclassifyConstraintTypesLinear(
        scip: *mut SCIP,
        linconsstats: *mut SCIP_LINCONSSTATS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from linear constraints"]
    pub fn SCIPcleanupConssLinear(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        ndelconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for linear constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrExactLinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsExactLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linear constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLinear(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLinear() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicExactLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a linear constraint from an exact linear constraint by rounding values to floating-point and captures it"]
    pub fn SCIPcopyConsExactLinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        sourcescip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        sourcevars: *mut *mut SCIP_VAR,
        sourcecoefs: *mut SCIP_INTERVAL,
        lhs: f64,
        rhs: f64,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coefficient to linear constraint (if it is not zero)"]
    pub fn SCIPaddCoefExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes coefficient of variable in linear constraint; deletes the variable if coefficient is zero; adds variable if\n  not yet contained in the constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPchgCoefExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes variable from linear constraint\n\n  @note This method may only be called during problem creation stage for an original constraint and variable.\n\n  @note This method requires linear time to search for occurences of the variable in the constraint data."]
    pub fn SCIPdelCoefExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets left hand side of linear constraint"]
    pub fn SCIPgetLhsExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets right hand side of linear constraint"]
    pub fn SCIPgetRhsExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " changes left hand side of linear constraint"]
    pub fn SCIPchgLhsExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        lhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of linear constraint"]
    pub fn SCIPchgRhsExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        rhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the number of variables in the linear constraint"]
    pub fn SCIPgetNVarsExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the array of variables in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetVarsExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the array of coefficient values in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetValsRealExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_INTERVAL;
}
unsafe extern "C" {
    #[doc = " gets the array of coefficient values in the linear constraint; the user must not modify this array!"]
    pub fn SCIPgetValsExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS)
    -> *mut *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the activity of the linear constraint in the given solution\n\n  @note if the activity comprises positive and negative infinity contributions, the result is currently undefined"]
    pub fn SCIPgetActivityExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        ret: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the feasibility of the linear constraint in the given solution"]
    pub fn SCIPgetFeasibilityExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        ret: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the linear constraint in the current LP\n\n  @note this method currently returns the value from the floating-point LP"]
    pub fn SCIPgetFpDualsolExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        ret: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the linear constraint in the current infeasible LP\n\n  @note this method currently returns the value from the floating-point LP"]
    pub fn SCIPgetFpDualfarkasExactLinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        ret: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given linear constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " returns the exact linear relaxation of the given linear constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowExactExactLinear(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROWEXACT;
}
unsafe extern "C" {
    #[doc = " prints the certificate for a given original exact linear constraint"]
    pub fn SCIPcertifyConsOrigExactLinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
#[doc = " collected values of a column which depend on the LP solution\n  We store these values in each column to recover the LP solution at start of diving or probing mode, say, without\n  having to resolve the LP.  Note that we do not store the farkascoef value since we do expect a node with infeasible\n  LP to be pruned anyway."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ColSolVals {
    #[doc = "< primal solution value in LP, is 0 if col is not in LP"]
    pub primsol: f64,
    #[doc = "< reduced cost value in LP, or SCIP_INVALID if not yet calculated"]
    pub redcost: f64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_ColSolVals"][::std::mem::size_of::<SCIP_ColSolVals>() - 24usize];
    ["Alignment of SCIP_ColSolVals"][::std::mem::align_of::<SCIP_ColSolVals>() - 8usize];
    ["Offset of field: SCIP_ColSolVals::primsol"]
        [::std::mem::offset_of!(SCIP_ColSolVals, primsol) - 0usize];
    ["Offset of field: SCIP_ColSolVals::redcost"]
        [::std::mem::offset_of!(SCIP_ColSolVals, redcost) - 8usize];
};
impl SCIP_ColSolVals {
    #[inline]
    pub fn basisstatus(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_basisstatus(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basisstatus_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_basisstatus_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        basisstatus: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let basisstatus: u32 = unsafe { ::std::mem::transmute(basisstatus) };
            basisstatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " collected values of a row which depend on the LP solution\n  We store these values in each row to recover the LP solution at start of diving or probing mode, say, without having\n  to resolve the LP.  We do not store the dualfarkas value since we expect a node with infeasible LP to be pruned\n  anyway. In this unlikely case, we have to resolve the LP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowSolVals {
    #[doc = "< dual solution value in LP, is 0 if row is not in LP"]
    pub dualsol: f64,
    #[doc = "< row activity value in LP, or SCIP_INVALID if not yet calculated"]
    pub activity: f64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_RowSolVals"][::std::mem::size_of::<SCIP_RowSolVals>() - 24usize];
    ["Alignment of SCIP_RowSolVals"][::std::mem::align_of::<SCIP_RowSolVals>() - 8usize];
    ["Offset of field: SCIP_RowSolVals::dualsol"]
        [::std::mem::offset_of!(SCIP_RowSolVals, dualsol) - 0usize];
    ["Offset of field: SCIP_RowSolVals::activity"]
        [::std::mem::offset_of!(SCIP_RowSolVals, activity) - 8usize];
};
impl SCIP_RowSolVals {
    #[inline]
    pub fn basisstatus(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_basisstatus(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basisstatus_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_basisstatus_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        basisstatus: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let basisstatus: u32 = unsafe { ::std::mem::transmute(basisstatus) };
            basisstatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " collected values of the LP data which depend on the LP solution\n  We store these values to recover the LP solution at start of diving or probing mode, say, without having to resolve\n  the LP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LpSolVals {
    #[doc = "< solution status of last LP solution"]
    pub lpsolstat: SCIP_LPSOLSTAT,
    #[doc = "< objective value of LP without loose variables, or SCIP_INVALID"]
    pub lpobjval: f64,
    #[doc = "< is current LP solution primal feasible?"]
    pub primalfeasible: ::std::os::raw::c_uint,
    #[doc = "< was current LP solution checked for primal feasibility?"]
    pub primalchecked: ::std::os::raw::c_uint,
    #[doc = "< is current LP solution dual feasible?"]
    pub dualfeasible: ::std::os::raw::c_uint,
    #[doc = "< was current LP solution checked for primal feasibility?"]
    pub dualchecked: ::std::os::raw::c_uint,
    #[doc = "< is current LP solution a basic solution?"]
    pub solisbasic: ::std::os::raw::c_uint,
    #[doc = "< is current LP solved?"]
    pub lpissolved: ::std::os::raw::c_uint,
    #[doc = "< is the current LP provably dual feasible (in exact mode)"]
    pub hasprovedboundexact: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_LpSolVals"][::std::mem::size_of::<SCIP_LpSolVals>() - 48usize];
    ["Alignment of SCIP_LpSolVals"][::std::mem::align_of::<SCIP_LpSolVals>() - 8usize];
    ["Offset of field: SCIP_LpSolVals::lpsolstat"]
        [::std::mem::offset_of!(SCIP_LpSolVals, lpsolstat) - 0usize];
    ["Offset of field: SCIP_LpSolVals::lpobjval"]
        [::std::mem::offset_of!(SCIP_LpSolVals, lpobjval) - 8usize];
    ["Offset of field: SCIP_LpSolVals::primalfeasible"]
        [::std::mem::offset_of!(SCIP_LpSolVals, primalfeasible) - 16usize];
    ["Offset of field: SCIP_LpSolVals::primalchecked"]
        [::std::mem::offset_of!(SCIP_LpSolVals, primalchecked) - 20usize];
    ["Offset of field: SCIP_LpSolVals::dualfeasible"]
        [::std::mem::offset_of!(SCIP_LpSolVals, dualfeasible) - 24usize];
    ["Offset of field: SCIP_LpSolVals::dualchecked"]
        [::std::mem::offset_of!(SCIP_LpSolVals, dualchecked) - 28usize];
    ["Offset of field: SCIP_LpSolVals::solisbasic"]
        [::std::mem::offset_of!(SCIP_LpSolVals, solisbasic) - 32usize];
    ["Offset of field: SCIP_LpSolVals::lpissolved"]
        [::std::mem::offset_of!(SCIP_LpSolVals, lpissolved) - 36usize];
    ["Offset of field: SCIP_LpSolVals::hasprovedboundexact"]
        [::std::mem::offset_of!(SCIP_LpSolVals, hasprovedboundexact) - 40usize];
};
#[doc = " LP column;\n  The row vector of the LP column is partitioned into two parts: The first col->nlprows rows in the rows array\n  are the ones that belong to the current LP (col->rows[j]->lppos >= 0) and that are linked to the column\n  (col->linkpos[j] >= 0). The remaining col->len - col->nlprows rows in the rows array are the ones that\n  don't belong to the current LP (col->rows[j]->lppos == -1) or that are not linked to the column\n  (col->linkpos[j] == -1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Col {
    #[doc = "< current objective value of column in LP (might be changed in diving or probing)"]
    pub obj: f64,
    #[doc = "< current lower bound of column in LP"]
    pub lb: f64,
    #[doc = "< current upper bound of column in LP"]
    pub ub: f64,
    #[doc = "< unchanged objective value of column (ignoring diving or probing changes)"]
    pub unchangedobj: f64,
    #[doc = "< lazy lower bound of the column; if the current lower bound is not greater than\n   the lazy lower bound, then the lower bound has not to be added to the LP"]
    pub lazylb: f64,
    #[doc = "< lazy upper bound of the column; if the current upper bound is not smaller than\n   the lazy upper bound, then the upper bound has not to be added to the LP"]
    pub lazyub: f64,
    #[doc = "< objective value of column already flushed to the LP solver"]
    pub flushedobj: f64,
    #[doc = "< lower bound of column already flushed to the LP solver"]
    pub flushedlb: f64,
    #[doc = "< upper bound of column already flushed to the LP solver"]
    pub flushedub: f64,
    #[doc = "< primal solution value in LP, is 0 if col is not in LP"]
    pub primsol: f64,
    #[doc = "< reduced cost value in LP, or SCIP_INVALID if not yet calculated"]
    pub redcost: f64,
    #[doc = "< coefficient in dual Farkas infeasibility proof (== dualfarkas^T A_c)"]
    pub farkascoef: f64,
    #[doc = "< minimal LP solution value, this column ever assumed"]
    pub minprimsol: f64,
    #[doc = "< maximal LP solution value, this column ever assumed"]
    pub maxprimsol: f64,
    #[doc = "< strong branching information for downwards branching"]
    pub sbdown: f64,
    #[doc = "< strong branching information for upwards branching"]
    pub sbup: f64,
    #[doc = "< LP solution value of column at last strong branching call"]
    pub sbsolval: f64,
    #[doc = "< LP objective value at last strong branching call on the column"]
    pub sblpobjval: f64,
    #[doc = "< node number of the last strong branching call on this column"]
    pub sbnode: ::std::os::raw::c_longlong,
    #[doc = "< last node where this column was removed due to aging"]
    pub obsoletenode: ::std::os::raw::c_longlong,
    #[doc = "< values stored before entering diving or probing mode"]
    pub storedsolvals: *mut SCIP_COLSOLVALS,
    #[doc = "< variable, this column represents; there cannot be a column without variable"]
    pub var: *mut SCIP_VAR,
    #[doc = "< rows of column entries, that may have a nonzero dual solution value"]
    pub rows: *mut *mut SCIP_ROW,
    #[doc = "< coefficients of column entries"]
    pub vals: *mut f64,
    #[doc = "< LP number for which reduced cost value is valid"]
    pub validredcostlp: ::std::os::raw::c_longlong,
    #[doc = "< LP number for which Farkas coefficient is valid"]
    pub validfarkaslp: ::std::os::raw::c_longlong,
    #[doc = "< LP number for which strong branching values are valid"]
    pub validsblp: ::std::os::raw::c_longlong,
    #[doc = "< position of col in col vector of the row, or -1 if not yet linked"]
    pub linkpos: *mut ::std::os::raw::c_int,
    #[doc = "< consecutively numbered column identifier"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< size of the row- and val-arrays"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< number of nonzeros in column"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< number of linked rows in column, that belong to the current LP"]
    pub nlprows: ::std::os::raw::c_int,
    #[doc = "< number of column entries, where the rows don't know about the column"]
    pub nunlinked: ::std::os::raw::c_int,
    #[doc = "< column position number in current LP, or -1 if not in current LP"]
    pub lppos: ::std::os::raw::c_int,
    #[doc = "< column position number in LP solver, or -1 if not in LP solver"]
    pub lpipos: ::std::os::raw::c_int,
    #[doc = "< depth level at which column entered the LP, or -1 if not in current LP"]
    pub lpdepth: ::std::os::raw::c_int,
    #[doc = "< strong branching iteration limit used to get strong branching values, or -1"]
    pub sbitlim: ::std::os::raw::c_int,
    #[doc = "< number of times, strong branching was applied on the column"]
    pub nsbcalls: ::std::os::raw::c_int,
    #[doc = "< number of successive times this variable was in LP and was 0.0 in solution"]
    pub age: ::std::os::raw::c_int,
    #[doc = "< copy of var->probindex for avoiding expensive dereferencing"]
    pub var_probindex: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Col"][::std::mem::size_of::<SCIP_Col>() - 280usize];
    ["Alignment of SCIP_Col"][::std::mem::align_of::<SCIP_Col>() - 8usize];
    ["Offset of field: SCIP_Col::obj"][::std::mem::offset_of!(SCIP_Col, obj) - 0usize];
    ["Offset of field: SCIP_Col::lb"][::std::mem::offset_of!(SCIP_Col, lb) - 8usize];
    ["Offset of field: SCIP_Col::ub"][::std::mem::offset_of!(SCIP_Col, ub) - 16usize];
    ["Offset of field: SCIP_Col::unchangedobj"]
        [::std::mem::offset_of!(SCIP_Col, unchangedobj) - 24usize];
    ["Offset of field: SCIP_Col::lazylb"][::std::mem::offset_of!(SCIP_Col, lazylb) - 32usize];
    ["Offset of field: SCIP_Col::lazyub"][::std::mem::offset_of!(SCIP_Col, lazyub) - 40usize];
    ["Offset of field: SCIP_Col::flushedobj"]
        [::std::mem::offset_of!(SCIP_Col, flushedobj) - 48usize];
    ["Offset of field: SCIP_Col::flushedlb"][::std::mem::offset_of!(SCIP_Col, flushedlb) - 56usize];
    ["Offset of field: SCIP_Col::flushedub"][::std::mem::offset_of!(SCIP_Col, flushedub) - 64usize];
    ["Offset of field: SCIP_Col::primsol"][::std::mem::offset_of!(SCIP_Col, primsol) - 72usize];
    ["Offset of field: SCIP_Col::redcost"][::std::mem::offset_of!(SCIP_Col, redcost) - 80usize];
    ["Offset of field: SCIP_Col::farkascoef"]
        [::std::mem::offset_of!(SCIP_Col, farkascoef) - 88usize];
    ["Offset of field: SCIP_Col::minprimsol"]
        [::std::mem::offset_of!(SCIP_Col, minprimsol) - 96usize];
    ["Offset of field: SCIP_Col::maxprimsol"]
        [::std::mem::offset_of!(SCIP_Col, maxprimsol) - 104usize];
    ["Offset of field: SCIP_Col::sbdown"][::std::mem::offset_of!(SCIP_Col, sbdown) - 112usize];
    ["Offset of field: SCIP_Col::sbup"][::std::mem::offset_of!(SCIP_Col, sbup) - 120usize];
    ["Offset of field: SCIP_Col::sbsolval"][::std::mem::offset_of!(SCIP_Col, sbsolval) - 128usize];
    ["Offset of field: SCIP_Col::sblpobjval"]
        [::std::mem::offset_of!(SCIP_Col, sblpobjval) - 136usize];
    ["Offset of field: SCIP_Col::sbnode"][::std::mem::offset_of!(SCIP_Col, sbnode) - 144usize];
    ["Offset of field: SCIP_Col::obsoletenode"]
        [::std::mem::offset_of!(SCIP_Col, obsoletenode) - 152usize];
    ["Offset of field: SCIP_Col::storedsolvals"]
        [::std::mem::offset_of!(SCIP_Col, storedsolvals) - 160usize];
    ["Offset of field: SCIP_Col::var"][::std::mem::offset_of!(SCIP_Col, var) - 168usize];
    ["Offset of field: SCIP_Col::rows"][::std::mem::offset_of!(SCIP_Col, rows) - 176usize];
    ["Offset of field: SCIP_Col::vals"][::std::mem::offset_of!(SCIP_Col, vals) - 184usize];
    ["Offset of field: SCIP_Col::validredcostlp"]
        [::std::mem::offset_of!(SCIP_Col, validredcostlp) - 192usize];
    ["Offset of field: SCIP_Col::validfarkaslp"]
        [::std::mem::offset_of!(SCIP_Col, validfarkaslp) - 200usize];
    ["Offset of field: SCIP_Col::validsblp"]
        [::std::mem::offset_of!(SCIP_Col, validsblp) - 208usize];
    ["Offset of field: SCIP_Col::linkpos"][::std::mem::offset_of!(SCIP_Col, linkpos) - 216usize];
    ["Offset of field: SCIP_Col::index"][::std::mem::offset_of!(SCIP_Col, index) - 224usize];
    ["Offset of field: SCIP_Col::size"][::std::mem::offset_of!(SCIP_Col, size) - 228usize];
    ["Offset of field: SCIP_Col::len"][::std::mem::offset_of!(SCIP_Col, len) - 232usize];
    ["Offset of field: SCIP_Col::nlprows"][::std::mem::offset_of!(SCIP_Col, nlprows) - 236usize];
    ["Offset of field: SCIP_Col::nunlinked"]
        [::std::mem::offset_of!(SCIP_Col, nunlinked) - 240usize];
    ["Offset of field: SCIP_Col::lppos"][::std::mem::offset_of!(SCIP_Col, lppos) - 244usize];
    ["Offset of field: SCIP_Col::lpipos"][::std::mem::offset_of!(SCIP_Col, lpipos) - 248usize];
    ["Offset of field: SCIP_Col::lpdepth"][::std::mem::offset_of!(SCIP_Col, lpdepth) - 252usize];
    ["Offset of field: SCIP_Col::sbitlim"][::std::mem::offset_of!(SCIP_Col, sbitlim) - 256usize];
    ["Offset of field: SCIP_Col::nsbcalls"][::std::mem::offset_of!(SCIP_Col, nsbcalls) - 260usize];
    ["Offset of field: SCIP_Col::age"][::std::mem::offset_of!(SCIP_Col, age) - 264usize];
    ["Offset of field: SCIP_Col::var_probindex"]
        [::std::mem::offset_of!(SCIP_Col, var_probindex) - 268usize];
};
impl SCIP_Col {
    #[inline]
    pub fn basisstatus(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_basisstatus(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basisstatus_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_basisstatus_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lprowssorted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lprowssorted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lprowssorted_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lprowssorted_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nonlprowssorted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonlprowssorted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nonlprowssorted_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nonlprowssorted_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn objchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_objchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn objchanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_objchanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lbchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lbchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lbchanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lbchanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ubchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ubchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ubchanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ubchanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn coefchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coefchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn coefchanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_coefchanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn integral(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_integral(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn integral_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_integral_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn impliedintegral(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_impliedintegral(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn impliedintegral_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_impliedintegral_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn removable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_removable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn removable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_removable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sbdownvalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sbdownvalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sbdownvalid_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sbdownvalid_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sbupvalid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sbupvalid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sbupvalid_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sbupvalid_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        basisstatus: ::std::os::raw::c_uint,
        lprowssorted: ::std::os::raw::c_uint,
        nonlprowssorted: ::std::os::raw::c_uint,
        objchanged: ::std::os::raw::c_uint,
        lbchanged: ::std::os::raw::c_uint,
        ubchanged: ::std::os::raw::c_uint,
        coefchanged: ::std::os::raw::c_uint,
        integral: ::std::os::raw::c_uint,
        impliedintegral: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        sbdownvalid: ::std::os::raw::c_uint,
        sbupvalid: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let basisstatus: u32 = unsafe { ::std::mem::transmute(basisstatus) };
            basisstatus as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lprowssorted: u32 = unsafe { ::std::mem::transmute(lprowssorted) };
            lprowssorted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nonlprowssorted: u32 = unsafe { ::std::mem::transmute(nonlprowssorted) };
            nonlprowssorted as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let objchanged: u32 = unsafe { ::std::mem::transmute(objchanged) };
            objchanged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let lbchanged: u32 = unsafe { ::std::mem::transmute(lbchanged) };
            lbchanged as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ubchanged: u32 = unsafe { ::std::mem::transmute(ubchanged) };
            ubchanged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let coefchanged: u32 = unsafe { ::std::mem::transmute(coefchanged) };
            coefchanged as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let integral: u32 = unsafe { ::std::mem::transmute(integral) };
            integral as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let impliedintegral: u32 = unsafe { ::std::mem::transmute(impliedintegral) };
            impliedintegral as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let removable: u32 = unsafe { ::std::mem::transmute(removable) };
            removable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sbdownvalid: u32 = unsafe { ::std::mem::transmute(sbdownvalid) };
            sbdownvalid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let sbupvalid: u32 = unsafe { ::std::mem::transmute(sbupvalid) };
            sbupvalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " LP row\n  The column vector of the LP row is partitioned into two parts: The first row->nlpcols columns in the cols array\n  are the ones that belong to the current LP (row->cols[j]->lppos >= 0) and that are linked to the row\n  (row->linkpos[j] >= 0). The remaining row->len - row->nlpcols columns in the cols array are the ones that\n  don't belong to the current LP (row->cols[j]->lppos == -1) or that are not linked to the row\n  (row->linkpos[j] == -1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Row {
    #[doc = "< constant shift c in row lhs <= ax + c <= rhs"]
    pub constant: f64,
    #[doc = "< left hand side of row"]
    pub lhs: f64,
    #[doc = "< right hand side of row"]
    pub rhs: f64,
    #[doc = "< left hand side minus constant of row already flushed to the LP solver"]
    pub flushedlhs: f64,
    #[doc = "< right hand side minus constant of row already flushed to the LP solver"]
    pub flushedrhs: f64,
    #[doc = "< squared Euclidean norm of row vector"]
    pub sqrnorm: f64,
    #[doc = "< sum norm of row vector (sum of absolute values of coefficients)"]
    pub sumnorm: f64,
    #[doc = "< scalar product of row vector with objective function"]
    pub objprod: f64,
    #[doc = "< maximal absolute value of row vector, only valid if nummaxval > 0"]
    pub maxval: f64,
    #[doc = "< minimal absolute non-zero value of row vector, only valid if numminval > 0"]
    pub minval: f64,
    #[doc = "< dual solution value in LP, is 0 if row is not in LP"]
    pub dualsol: f64,
    #[doc = "< row activity value in LP, or SCIP_INVALID if not yet calculated"]
    pub activity: f64,
    #[doc = "< multiplier value in dual Farkas infeasibility proof"]
    pub dualfarkas: f64,
    #[doc = "< row activity value in pseudo solution, or SCIP_INVALID if not yet calculated"]
    pub pseudoactivity: f64,
    #[doc = "< minimal activity value w.r.t. the column's bounds, or SCIP_INVALID"]
    pub minactivity: f64,
    #[doc = "< maximal activity value w.r.t. the column's bounds, or SCIP_INVALID"]
    pub maxactivity: f64,
    #[doc = "< domain change number for which pseudo activity value is valid"]
    pub validpsactivitydomchg: ::std::os::raw::c_longlong,
    #[doc = "< domain change number for which activity bound values are valid"]
    pub validactivitybdsdomchg: ::std::os::raw::c_longlong,
    #[doc = "< last node where this row was removed due to aging"]
    pub obsoletenode: ::std::os::raw::c_longlong,
    #[doc = "< counter for the number of times this row was active in an optimal LP solution"]
    pub activeinlpcounter: ::std::os::raw::c_longlong,
    #[doc = "< counter for the number of LPs after the row has been created"]
    pub nlpsaftercreation: ::std::os::raw::c_longlong,
    #[doc = "< values stored before entering diving or probing mode"]
    pub storedsolvals: *mut SCIP_ROWSOLVALS,
    #[doc = "< pointer to constraint handler or separator who created the row (NULL if unknown)"]
    pub origin: *mut ::std::os::raw::c_void,
    #[doc = "< name of the row"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< columns of row entries, that may have a nonzero primal solution value"]
    pub cols: *mut *mut SCIP_COL,
    #[doc = "< copy of cols[i]->index for avoiding expensive dereferencing"]
    pub cols_index: *mut ::std::os::raw::c_int,
    #[doc = "< coefficients of row entries"]
    pub vals: *mut f64,
    #[doc = "< position of row in row vector of the column, or -1 if not yet linked"]
    pub linkpos: *mut ::std::os::raw::c_int,
    #[doc = "< event filter for events concerning this row"]
    pub eventfilter: *mut SCIP_EVENTFILTER,
    #[doc = "< pointer to exact row if it exists, or NULL in fp-scip"]
    pub rowexact: *mut SCIP_ROWEXACT,
    #[doc = "< LP number for which activity value is valid"]
    pub validactivitylp: ::std::os::raw::c_longlong,
    #[doc = "< consecutively numbered row identifier"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< size of the col- and val-arrays"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< number of nonzeros in row"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< number of linked columns in row, that belong to the current LP"]
    pub nlpcols: ::std::os::raw::c_int,
    #[doc = "< number of row entries, where the columns don't know about the row"]
    pub nunlinked: ::std::os::raw::c_int,
    #[doc = "< number of times, this row is referenced"]
    pub nuses: ::std::os::raw::c_int,
    #[doc = "< row position number in current LP, or -1 if not in current LP"]
    pub lppos: ::std::os::raw::c_int,
    #[doc = "< row position number in LP solver, or -1 if not in LP solver"]
    pub lpipos: ::std::os::raw::c_int,
    #[doc = "< depth level at which row entered the LP, or -1 if not in current LP"]
    pub lpdepth: ::std::os::raw::c_int,
    #[doc = "< minimal column index of row entries"]
    pub minidx: ::std::os::raw::c_int,
    #[doc = "< maximal column index of row entries"]
    pub maxidx: ::std::os::raw::c_int,
    #[doc = "< number of integral columns"]
    pub numintcols: ::std::os::raw::c_int,
    #[doc = "< number of implied integral columns"]
    pub numimplintcols: ::std::os::raw::c_int,
    #[doc = "< number of coefs with absolute value equal to maxval, zero if maxval invalid"]
    pub nummaxval: ::std::os::raw::c_int,
    #[doc = "< number of coefs with absolute value equal to minval, zero if minval invalid"]
    pub numminval: ::std::os::raw::c_int,
    #[doc = "< number of successive times this row was in LP and was not sharp in solution"]
    pub age: ::std::os::raw::c_int,
    #[doc = "< rank of the row (upper bound, to be precise)"]
    pub rank: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Row"][::std::mem::size_of::<SCIP_Row>() - 320usize];
    ["Alignment of SCIP_Row"][::std::mem::align_of::<SCIP_Row>() - 8usize];
    ["Offset of field: SCIP_Row::constant"][::std::mem::offset_of!(SCIP_Row, constant) - 0usize];
    ["Offset of field: SCIP_Row::lhs"][::std::mem::offset_of!(SCIP_Row, lhs) - 8usize];
    ["Offset of field: SCIP_Row::rhs"][::std::mem::offset_of!(SCIP_Row, rhs) - 16usize];
    ["Offset of field: SCIP_Row::flushedlhs"]
        [::std::mem::offset_of!(SCIP_Row, flushedlhs) - 24usize];
    ["Offset of field: SCIP_Row::flushedrhs"]
        [::std::mem::offset_of!(SCIP_Row, flushedrhs) - 32usize];
    ["Offset of field: SCIP_Row::sqrnorm"][::std::mem::offset_of!(SCIP_Row, sqrnorm) - 40usize];
    ["Offset of field: SCIP_Row::sumnorm"][::std::mem::offset_of!(SCIP_Row, sumnorm) - 48usize];
    ["Offset of field: SCIP_Row::objprod"][::std::mem::offset_of!(SCIP_Row, objprod) - 56usize];
    ["Offset of field: SCIP_Row::maxval"][::std::mem::offset_of!(SCIP_Row, maxval) - 64usize];
    ["Offset of field: SCIP_Row::minval"][::std::mem::offset_of!(SCIP_Row, minval) - 72usize];
    ["Offset of field: SCIP_Row::dualsol"][::std::mem::offset_of!(SCIP_Row, dualsol) - 80usize];
    ["Offset of field: SCIP_Row::activity"][::std::mem::offset_of!(SCIP_Row, activity) - 88usize];
    ["Offset of field: SCIP_Row::dualfarkas"]
        [::std::mem::offset_of!(SCIP_Row, dualfarkas) - 96usize];
    ["Offset of field: SCIP_Row::pseudoactivity"]
        [::std::mem::offset_of!(SCIP_Row, pseudoactivity) - 104usize];
    ["Offset of field: SCIP_Row::minactivity"]
        [::std::mem::offset_of!(SCIP_Row, minactivity) - 112usize];
    ["Offset of field: SCIP_Row::maxactivity"]
        [::std::mem::offset_of!(SCIP_Row, maxactivity) - 120usize];
    ["Offset of field: SCIP_Row::validpsactivitydomchg"]
        [::std::mem::offset_of!(SCIP_Row, validpsactivitydomchg) - 128usize];
    ["Offset of field: SCIP_Row::validactivitybdsdomchg"]
        [::std::mem::offset_of!(SCIP_Row, validactivitybdsdomchg) - 136usize];
    ["Offset of field: SCIP_Row::obsoletenode"]
        [::std::mem::offset_of!(SCIP_Row, obsoletenode) - 144usize];
    ["Offset of field: SCIP_Row::activeinlpcounter"]
        [::std::mem::offset_of!(SCIP_Row, activeinlpcounter) - 152usize];
    ["Offset of field: SCIP_Row::nlpsaftercreation"]
        [::std::mem::offset_of!(SCIP_Row, nlpsaftercreation) - 160usize];
    ["Offset of field: SCIP_Row::storedsolvals"]
        [::std::mem::offset_of!(SCIP_Row, storedsolvals) - 168usize];
    ["Offset of field: SCIP_Row::origin"][::std::mem::offset_of!(SCIP_Row, origin) - 176usize];
    ["Offset of field: SCIP_Row::name"][::std::mem::offset_of!(SCIP_Row, name) - 184usize];
    ["Offset of field: SCIP_Row::cols"][::std::mem::offset_of!(SCIP_Row, cols) - 192usize];
    ["Offset of field: SCIP_Row::cols_index"]
        [::std::mem::offset_of!(SCIP_Row, cols_index) - 200usize];
    ["Offset of field: SCIP_Row::vals"][::std::mem::offset_of!(SCIP_Row, vals) - 208usize];
    ["Offset of field: SCIP_Row::linkpos"][::std::mem::offset_of!(SCIP_Row, linkpos) - 216usize];
    ["Offset of field: SCIP_Row::eventfilter"]
        [::std::mem::offset_of!(SCIP_Row, eventfilter) - 224usize];
    ["Offset of field: SCIP_Row::rowexact"][::std::mem::offset_of!(SCIP_Row, rowexact) - 232usize];
    ["Offset of field: SCIP_Row::validactivitylp"]
        [::std::mem::offset_of!(SCIP_Row, validactivitylp) - 240usize];
    ["Offset of field: SCIP_Row::index"][::std::mem::offset_of!(SCIP_Row, index) - 248usize];
    ["Offset of field: SCIP_Row::size"][::std::mem::offset_of!(SCIP_Row, size) - 252usize];
    ["Offset of field: SCIP_Row::len"][::std::mem::offset_of!(SCIP_Row, len) - 256usize];
    ["Offset of field: SCIP_Row::nlpcols"][::std::mem::offset_of!(SCIP_Row, nlpcols) - 260usize];
    ["Offset of field: SCIP_Row::nunlinked"]
        [::std::mem::offset_of!(SCIP_Row, nunlinked) - 264usize];
    ["Offset of field: SCIP_Row::nuses"][::std::mem::offset_of!(SCIP_Row, nuses) - 268usize];
    ["Offset of field: SCIP_Row::lppos"][::std::mem::offset_of!(SCIP_Row, lppos) - 272usize];
    ["Offset of field: SCIP_Row::lpipos"][::std::mem::offset_of!(SCIP_Row, lpipos) - 276usize];
    ["Offset of field: SCIP_Row::lpdepth"][::std::mem::offset_of!(SCIP_Row, lpdepth) - 280usize];
    ["Offset of field: SCIP_Row::minidx"][::std::mem::offset_of!(SCIP_Row, minidx) - 284usize];
    ["Offset of field: SCIP_Row::maxidx"][::std::mem::offset_of!(SCIP_Row, maxidx) - 288usize];
    ["Offset of field: SCIP_Row::numintcols"]
        [::std::mem::offset_of!(SCIP_Row, numintcols) - 292usize];
    ["Offset of field: SCIP_Row::numimplintcols"]
        [::std::mem::offset_of!(SCIP_Row, numimplintcols) - 296usize];
    ["Offset of field: SCIP_Row::nummaxval"]
        [::std::mem::offset_of!(SCIP_Row, nummaxval) - 300usize];
    ["Offset of field: SCIP_Row::numminval"]
        [::std::mem::offset_of!(SCIP_Row, numminval) - 304usize];
    ["Offset of field: SCIP_Row::age"][::std::mem::offset_of!(SCIP_Row, age) - 308usize];
    ["Offset of field: SCIP_Row::rank"][::std::mem::offset_of!(SCIP_Row, rank) - 312usize];
};
impl SCIP_Row {
    #[inline]
    pub fn fromcutpool(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fromcutpool(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fromcutpool_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fromcutpool_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn basisstatus(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_basisstatus(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn basisstatus_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_basisstatus_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpcolssorted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpcolssorted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpcolssorted_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpcolssorted_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nonlpcolssorted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonlpcolssorted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nonlpcolssorted_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nonlpcolssorted_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delaysort(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delaysort(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delaysort_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delaysort_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn validminmaxidx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_validminmaxidx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn validminmaxidx_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_validminmaxidx_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lhschanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lhschanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lhschanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lhschanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rhschanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rhschanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rhschanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rhschanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn coefchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coefchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn coefchanged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_coefchanged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn integral(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_integral(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn integral_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_integral_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn local(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_local(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn local_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_local_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn modifiable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_modifiable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn modifiable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_modifiable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn removable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_removable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn removable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_removable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inglobalcutpool(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inglobalcutpool(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inglobalcutpool_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inglobalcutpool_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn normunreliable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_normunreliable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn normunreliable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_normunreliable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nlocks(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_nlocks(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nlocks_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nlocks_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn origintype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_origintype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn origintype_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_origintype_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fromcutpool: ::std::os::raw::c_uint,
        basisstatus: ::std::os::raw::c_uint,
        lpcolssorted: ::std::os::raw::c_uint,
        nonlpcolssorted: ::std::os::raw::c_uint,
        delaysort: ::std::os::raw::c_uint,
        validminmaxidx: ::std::os::raw::c_uint,
        lhschanged: ::std::os::raw::c_uint,
        rhschanged: ::std::os::raw::c_uint,
        coefchanged: ::std::os::raw::c_uint,
        integral: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        inglobalcutpool: ::std::os::raw::c_uint,
        normunreliable: ::std::os::raw::c_uint,
        nlocks: ::std::os::raw::c_uint,
        origintype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fromcutpool: u32 = unsafe { ::std::mem::transmute(fromcutpool) };
            fromcutpool as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let basisstatus: u32 = unsafe { ::std::mem::transmute(basisstatus) };
            basisstatus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lpcolssorted: u32 = unsafe { ::std::mem::transmute(lpcolssorted) };
            lpcolssorted as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nonlpcolssorted: u32 = unsafe { ::std::mem::transmute(nonlpcolssorted) };
            nonlpcolssorted as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let delaysort: u32 = unsafe { ::std::mem::transmute(delaysort) };
            delaysort as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let validminmaxidx: u32 = unsafe { ::std::mem::transmute(validminmaxidx) };
            validminmaxidx as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lhschanged: u32 = unsafe { ::std::mem::transmute(lhschanged) };
            lhschanged as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rhschanged: u32 = unsafe { ::std::mem::transmute(rhschanged) };
            rhschanged as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let coefchanged: u32 = unsafe { ::std::mem::transmute(coefchanged) };
            coefchanged as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let integral: u32 = unsafe { ::std::mem::transmute(integral) };
            integral as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let local: u32 = unsafe { ::std::mem::transmute(local) };
            local as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let modifiable: u32 = unsafe { ::std::mem::transmute(modifiable) };
            modifiable as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let removable: u32 = unsafe { ::std::mem::transmute(removable) };
            removable as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inglobalcutpool: u32 = unsafe { ::std::mem::transmute(inglobalcutpool) };
            inglobalcutpool as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let normunreliable: u32 = unsafe { ::std::mem::transmute(normunreliable) };
            normunreliable as u64
        });
        __bindgen_bitfield_unit.set(16usize, 13u8, {
            let nlocks: u32 = unsafe { ::std::mem::transmute(nlocks) };
            nlocks as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let origintype: u32 = unsafe { ::std::mem::transmute(origintype) };
            origintype as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " current LP data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Lp {
    #[doc = "< objective value of LP without loose variables, or SCIP_INVALID"]
    pub lpobjval: f64,
    #[doc = "< current solution value of all loose variables set to their best bounds,\n   ignoring variables, with infinite best bound"]
    pub looseobjval: f64,
    #[doc = "< last reliable solution value of all loose variables set to their best bounds,\n   ignoring variables, with infinite best bound"]
    pub rellooseobjval: f64,
    #[doc = "< global pseudo solution value with all variables set to their best global bounds,\n   ignoring variables, with infinite best bound"]
    pub glbpseudoobjval: f64,
    #[doc = "< last reliable global pseudo solution value"]
    pub relglbpseudoobjval: f64,
    #[doc = "< current pseudo solution value with all variables set to their best bounds,\n   ignoring variables, with infinite best bound"]
    pub pseudoobjval: f64,
    #[doc = "< last reliable pseudo solution value"]
    pub relpseudoobjval: f64,
    #[doc = "< objective value of root LP without loose variables, or SCIP_INVALID"]
    pub rootlpobjval: f64,
    #[doc = "< objective value of loose variables in root node, or SCIP_INVALID"]
    pub rootlooseobjval: f64,
    #[doc = "< upper objective limit of LP (copy of primal->cutoffbound)"]
    pub cutoffbound: f64,
    #[doc = "< current feasibility tolerance"]
    pub feastol: f64,
    #[doc = "< current objective limit in LPI"]
    pub lpiobjlim: f64,
    #[doc = "< current feasibility tolerance in LPI"]
    pub lpifeastol: f64,
    #[doc = "< current reduced costs feasibility tolerance in LPI"]
    pub lpidualfeastol: f64,
    #[doc = "< current convergence tolerance used in barrier algorithm in LPI"]
    pub lpibarrierconvtol: f64,
    #[doc = "< current condition number limit in LPI"]
    pub lpiconditionlimit: f64,
    #[doc = "< current markowitz threshold"]
    pub lpimarkowitz: f64,
    #[doc = "< squared Euclidean norm of objective function vector of problem variables"]
    pub objsqrnorm: f64,
    #[doc = "< sum norm of objective function vector of problem variables"]
    pub objsumnorm: f64,
    #[doc = "< share of degenerate non-basic variables in the current LP"]
    pub degeneracy: f64,
    #[doc = "< variable-constraint ratio of the optimal face"]
    pub varconsratio: f64,
    #[doc = "< LP solver interface"]
    pub lpi: *mut SCIP_LPI,
    #[doc = "< array with columns currently stored in the LP solver"]
    pub lpicols: *mut *mut SCIP_COL,
    #[doc = "< array with rows currently stored in the LP solver"]
    pub lpirows: *mut *mut SCIP_ROW,
    #[doc = "< array of changed columns not yet applied to the LP solver"]
    pub chgcols: *mut *mut SCIP_COL,
    #[doc = "< array of changed rows not yet applied to the LP solver"]
    pub chgrows: *mut *mut SCIP_ROW,
    #[doc = "< array with current LP columns in correct order"]
    pub cols: *mut *mut SCIP_COL,
    #[doc = "< array with current LP lazy columns"]
    pub lazycols: *mut *mut SCIP_COL,
    #[doc = "< array with current LP rows in correct order"]
    pub rows: *mut *mut SCIP_ROW,
    #[doc = "< pointer to exact rational lp, or null if in normal fp soliving mode"]
    pub lpexact: *mut SCIP_LPEXACT,
    #[doc = "< normalized vector in direction of primal solution from current LP solution"]
    pub soldirection: *mut f64,
    #[doc = "< stores LPI state (basis information) before diving starts"]
    pub divelpistate: *mut SCIP_LPISTATE,
    #[doc = "< stores the lhs/rhs changed in the current diving"]
    pub divechgsides: *mut f64,
    #[doc = "< stores the side type of the changes done in the current diving"]
    pub divechgsidetypes: *mut SCIP_SIDETYPE,
    #[doc = "< stores the rows changed in the current diving"]
    pub divechgrows: *mut *mut SCIP_ROW,
    #[doc = "< collected values of the LP data which depend on the LP solution"]
    pub storedsolvals: *mut SCIP_LPSOLVALS,
    #[doc = "< primal solution for which the currently stored solution direction vector is valid"]
    pub validsoldirsol: *mut SCIP_SOL,
    #[doc = "< LP number for which the currently stored solution values are valid"]
    pub validsollp: ::std::os::raw::c_longlong,
    #[doc = "< LP number for which the currently stored Farkas row multipliers are valid"]
    pub validfarkaslp: ::std::os::raw::c_longlong,
    #[doc = "< LP number for which the currently stored solution direction vector is valid"]
    pub validsoldirlp: ::std::os::raw::c_longlong,
    #[doc = "< LP number for which the currently stored degeneracy information is valid"]
    pub validdegeneracylp: ::std::os::raw::c_longlong,
    #[doc = "< number of domain changes before diving has started"]
    pub divenolddomchgs: ::std::os::raw::c_longlong,
    #[doc = "< available slots in lpicols vector"]
    pub lpicolssize: ::std::os::raw::c_int,
    #[doc = "< number of columns in the LP solver"]
    pub nlpicols: ::std::os::raw::c_int,
    #[doc = "< first column of the LP which differs from the column in the LP solver"]
    pub lpifirstchgcol: ::std::os::raw::c_int,
    #[doc = "< available slots in lpirows vector"]
    pub lpirowssize: ::std::os::raw::c_int,
    #[doc = "< number of rows in the LP solver"]
    pub nlpirows: ::std::os::raw::c_int,
    #[doc = "< first row of the LP which differs from the row in the LP solver"]
    pub lpifirstchgrow: ::std::os::raw::c_int,
    #[doc = "< available slots in chgcols vector"]
    pub chgcolssize: ::std::os::raw::c_int,
    #[doc = "< current number of chgcols (number of used slots in chgcols vector)"]
    pub nchgcols: ::std::os::raw::c_int,
    #[doc = "< available slots in chgrows vector"]
    pub chgrowssize: ::std::os::raw::c_int,
    #[doc = "< current number of chgrows (number of used slots in chgrows vector)"]
    pub nchgrows: ::std::os::raw::c_int,
    #[doc = "< available slots in cols vector"]
    pub colssize: ::std::os::raw::c_int,
    #[doc = "< available slots in soldirection vector"]
    pub soldirectionsize: ::std::os::raw::c_int,
    #[doc = "< current number of LP columns (number of used slots in cols vector)"]
    pub ncols: ::std::os::raw::c_int,
    #[doc = "< available slots in lazycols vector"]
    pub lazycolssize: ::std::os::raw::c_int,
    #[doc = "< current number of LP lazy columns (number of used slots in lazycols vector)"]
    pub nlazycols: ::std::os::raw::c_int,
    #[doc = "< number of removable columns in the LP"]
    pub nremovablecols: ::std::os::raw::c_int,
    #[doc = "< first column added at the current node"]
    pub firstnewcol: ::std::os::raw::c_int,
    #[doc = "< available slots in rows vector"]
    pub rowssize: ::std::os::raw::c_int,
    #[doc = "< current number of LP rows (number of used slots in rows vector)"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< number of removable rows in the LP"]
    pub nremovablerows: ::std::os::raw::c_int,
    #[doc = "< first row added at the current node"]
    pub firstnewrow: ::std::os::raw::c_int,
    #[doc = "< number of loose variables with infinite best bound in current solution"]
    pub looseobjvalinf: ::std::os::raw::c_int,
    #[doc = "< number of loose variables in LP"]
    pub nloosevars: ::std::os::raw::c_int,
    #[doc = "< number of variables with infinite best bound in global pseudo solution"]
    pub glbpseudoobjvalinf: ::std::os::raw::c_int,
    #[doc = "< number of variables with infinite best bound in current pseudo solution"]
    pub pseudoobjvalinf: ::std::os::raw::c_int,
    #[doc = "< number of rows when entering diving mode"]
    pub ndivingrows: ::std::os::raw::c_int,
    #[doc = "< number of side changes in current diving"]
    pub ndivechgsides: ::std::os::raw::c_int,
    #[doc = "< size of the arrays"]
    pub divechgsidessize: ::std::os::raw::c_int,
    #[doc = "< LPI iteration limit when entering diving mode"]
    pub divinglpiitlim: ::std::os::raw::c_int,
    #[doc = "< current iteration limit setting in LPI"]
    pub lpiitlim: ::std::os::raw::c_int,
    #[doc = "< current FASTMIP setting in LPI"]
    pub lpifastmip: ::std::os::raw::c_int,
    #[doc = "< current THREADS setting in LPI"]
    pub lpithreads: ::std::os::raw::c_int,
    #[doc = "< current timing type in LPI"]
    pub lpitiming: ::std::os::raw::c_int,
    #[doc = "< current initial random seed in LPI"]
    pub lpirandomseed: ::std::os::raw::c_int,
    #[doc = "< current SCALING setting in LPI"]
    pub lpiscaling: ::std::os::raw::c_int,
    #[doc = "< current refactorization interval"]
    pub lpirefactorinterval: ::std::os::raw::c_int,
    #[doc = "< current pricing setting in LPI"]
    pub lpipricing: SCIP_PRICING,
    #[doc = "< solution status of last LP solution"]
    pub lpsolstat: SCIP_LPSOLSTAT,
    #[doc = "< algorithm used for last LP solve"]
    pub lastlpalgo: SCIP_LPALGO,
    #[doc = "< is squared Euclidean norm of objective function vector of problem\n   variables unreliable and need recalculation?"]
    pub objsqrnormunreliable: ::std::os::raw::c_uint,
    #[doc = "< LP solution polishing method (0: disabled, 1: enabled)"]
    pub lpisolutionpolishing: ::std::os::raw::c_uint,
    #[doc = "< is the loose objective value valid or should it be recomputed from scratch?"]
    pub looseobjvalid: ::std::os::raw::c_uint,
    #[doc = "< is the global pseudo solution value valid or should it be recomputed from scratch?"]
    pub glbpseudoobjvalid: ::std::os::raw::c_uint,
    #[doc = "< is the pseudo solution value valid or should it be recomputed from scratch?"]
    pub pseudoobjvalid: ::std::os::raw::c_uint,
    #[doc = "< have LPI-columns been deleted in the last lpFlush() call?"]
    pub flushdeletedcols: ::std::os::raw::c_uint,
    #[doc = "< have LPI-columns been added in the last lpFlush() call?"]
    pub flushaddedcols: ::std::os::raw::c_uint,
    #[doc = "< have LPI-rows been deleted in the last lpFlush() call?"]
    pub flushdeletedrows: ::std::os::raw::c_uint,
    #[doc = "< have LPI-rows been added in the last lpFlush() call?"]
    pub flushaddedrows: ::std::os::raw::c_uint,
    #[doc = "< does integrality information need to be updated?"]
    pub updateintegrality: ::std::os::raw::c_uint,
    #[doc = "< are all cached changes applied to the LP solver?"]
    pub flushed: ::std::os::raw::c_uint,
    #[doc = "< is current LP solved?"]
    pub solved: ::std::os::raw::c_uint,
    #[doc = "< is current LP solution (rather LPI state) primal feasible?"]
    pub primalfeasible: ::std::os::raw::c_uint,
    #[doc = "< was current LP solution checked for primal feasibility??"]
    pub primalchecked: ::std::os::raw::c_uint,
    #[doc = "< is current LP solution (rather LPI state) dual feasible?"]
    pub dualfeasible: ::std::os::raw::c_uint,
    #[doc = "< was current LP solution checked for primal feasibility??"]
    pub dualchecked: ::std::os::raw::c_uint,
    #[doc = "< is current LP solution a basic solution?"]
    pub solisbasic: ::std::os::raw::c_uint,
    #[doc = "< is root LP a relaxation of the problem and its solution value a valid global lower bound?"]
    pub rootlpisrelax: ::std::os::raw::c_uint,
    #[doc = "< is the current LP a relaxation of the problem for which it has been solved and its\n   solution value a valid local lower bound?"]
    pub isrelax: ::std::os::raw::c_uint,
    #[doc = "< whether the solution process is in stalling"]
    pub installing: ::std::os::raw::c_uint,
    #[doc = "< whether the lp is used for strong branching"]
    pub strongbranching: ::std::os::raw::c_uint,
    #[doc = "< are we currently in probing mode?"]
    pub probing: ::std::os::raw::c_uint,
    #[doc = "< are we currently in probing mode for strong branching?"]
    pub strongbranchprobing: ::std::os::raw::c_uint,
    #[doc = "< LP is used for diving: col bounds and obj don't correspond to variables"]
    pub diving: ::std::os::raw::c_uint,
    #[doc = "< objective values were changed in diving or probing: LP objective is invalid"]
    pub divingobjchg: ::std::os::raw::c_uint,
    #[doc = "< lazy bounds were applied to the LP during diving"]
    pub divinglazyapplied: ::std::os::raw::c_uint,
    #[doc = "< an error occurred during resolving the LP after diving or probing"]
    pub resolvelperror: ::std::os::raw::c_uint,
    #[doc = "< does an infinite LP objective value has been adjusted so far?"]
    pub adjustlpval: ::std::os::raw::c_uint,
    #[doc = "< current FROMSCRATCH setting in LPI"]
    pub lpifromscratch: ::std::os::raw::c_uint,
    #[doc = "< current PRESOLVING setting in LPI"]
    pub lpipresolving: ::std::os::raw::c_uint,
    #[doc = "< current LPINFO setting in LPI"]
    pub lpilpinfo: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the FEASTOL parameter?"]
    pub lpihasfeastol: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the DUALFEASTOL parameter?"]
    pub lpihasdualfeastol: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the BARRIERCONVTOL parameter?"]
    pub lpihasbarrierconvtol: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the FASTMIP parameter?"]
    pub lpihasfastmip: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the SCALING parameter?"]
    pub lpihasscaling: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support the PRESOLVING parameter?"]
    pub lpihaspresolving: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support row representation of a simplex basis?"]
    pub lpihasrowrep: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support solution polishing?"]
    pub lpihaspolishing: ::std::os::raw::c_uint,
    #[doc = "< does the LPI support changing the refactorization interval?"]
    pub lpihasrefactor: ::std::os::raw::c_uint,
    #[doc = "< simplex algorithm shall use row representation of the basis\n   if number of rows divided by number of columns exceeds this value"]
    pub lpirowrepswitch: f64,
    #[doc = "< primal feasibility when diving started"]
    pub divelpwasprimfeas: ::std::os::raw::c_uint,
    #[doc = "< primal feasibility was checked when diving started"]
    pub divelpwasprimchecked: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility when diving started"]
    pub divelpwasdualfeas: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility was checked when diving started"]
    pub divelpwasdualchecked: ::std::os::raw::c_uint,
    #[doc = "< is the bound of the lp proved to be exactly dual feasible"]
    pub hasprovedbound: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Lp"][::std::mem::size_of::<SCIP_Lp>() - 688usize];
    ["Alignment of SCIP_Lp"][::std::mem::align_of::<SCIP_Lp>() - 8usize];
    ["Offset of field: SCIP_Lp::lpobjval"][::std::mem::offset_of!(SCIP_Lp, lpobjval) - 0usize];
    ["Offset of field: SCIP_Lp::looseobjval"]
        [::std::mem::offset_of!(SCIP_Lp, looseobjval) - 8usize];
    ["Offset of field: SCIP_Lp::rellooseobjval"]
        [::std::mem::offset_of!(SCIP_Lp, rellooseobjval) - 16usize];
    ["Offset of field: SCIP_Lp::glbpseudoobjval"]
        [::std::mem::offset_of!(SCIP_Lp, glbpseudoobjval) - 24usize];
    ["Offset of field: SCIP_Lp::relglbpseudoobjval"]
        [::std::mem::offset_of!(SCIP_Lp, relglbpseudoobjval) - 32usize];
    ["Offset of field: SCIP_Lp::pseudoobjval"]
        [::std::mem::offset_of!(SCIP_Lp, pseudoobjval) - 40usize];
    ["Offset of field: SCIP_Lp::relpseudoobjval"]
        [::std::mem::offset_of!(SCIP_Lp, relpseudoobjval) - 48usize];
    ["Offset of field: SCIP_Lp::rootlpobjval"]
        [::std::mem::offset_of!(SCIP_Lp, rootlpobjval) - 56usize];
    ["Offset of field: SCIP_Lp::rootlooseobjval"]
        [::std::mem::offset_of!(SCIP_Lp, rootlooseobjval) - 64usize];
    ["Offset of field: SCIP_Lp::cutoffbound"]
        [::std::mem::offset_of!(SCIP_Lp, cutoffbound) - 72usize];
    ["Offset of field: SCIP_Lp::feastol"][::std::mem::offset_of!(SCIP_Lp, feastol) - 80usize];
    ["Offset of field: SCIP_Lp::lpiobjlim"][::std::mem::offset_of!(SCIP_Lp, lpiobjlim) - 88usize];
    ["Offset of field: SCIP_Lp::lpifeastol"][::std::mem::offset_of!(SCIP_Lp, lpifeastol) - 96usize];
    ["Offset of field: SCIP_Lp::lpidualfeastol"]
        [::std::mem::offset_of!(SCIP_Lp, lpidualfeastol) - 104usize];
    ["Offset of field: SCIP_Lp::lpibarrierconvtol"]
        [::std::mem::offset_of!(SCIP_Lp, lpibarrierconvtol) - 112usize];
    ["Offset of field: SCIP_Lp::lpiconditionlimit"]
        [::std::mem::offset_of!(SCIP_Lp, lpiconditionlimit) - 120usize];
    ["Offset of field: SCIP_Lp::lpimarkowitz"]
        [::std::mem::offset_of!(SCIP_Lp, lpimarkowitz) - 128usize];
    ["Offset of field: SCIP_Lp::objsqrnorm"]
        [::std::mem::offset_of!(SCIP_Lp, objsqrnorm) - 136usize];
    ["Offset of field: SCIP_Lp::objsumnorm"]
        [::std::mem::offset_of!(SCIP_Lp, objsumnorm) - 144usize];
    ["Offset of field: SCIP_Lp::degeneracy"]
        [::std::mem::offset_of!(SCIP_Lp, degeneracy) - 152usize];
    ["Offset of field: SCIP_Lp::varconsratio"]
        [::std::mem::offset_of!(SCIP_Lp, varconsratio) - 160usize];
    ["Offset of field: SCIP_Lp::lpi"][::std::mem::offset_of!(SCIP_Lp, lpi) - 168usize];
    ["Offset of field: SCIP_Lp::lpicols"][::std::mem::offset_of!(SCIP_Lp, lpicols) - 176usize];
    ["Offset of field: SCIP_Lp::lpirows"][::std::mem::offset_of!(SCIP_Lp, lpirows) - 184usize];
    ["Offset of field: SCIP_Lp::chgcols"][::std::mem::offset_of!(SCIP_Lp, chgcols) - 192usize];
    ["Offset of field: SCIP_Lp::chgrows"][::std::mem::offset_of!(SCIP_Lp, chgrows) - 200usize];
    ["Offset of field: SCIP_Lp::cols"][::std::mem::offset_of!(SCIP_Lp, cols) - 208usize];
    ["Offset of field: SCIP_Lp::lazycols"][::std::mem::offset_of!(SCIP_Lp, lazycols) - 216usize];
    ["Offset of field: SCIP_Lp::rows"][::std::mem::offset_of!(SCIP_Lp, rows) - 224usize];
    ["Offset of field: SCIP_Lp::lpexact"][::std::mem::offset_of!(SCIP_Lp, lpexact) - 232usize];
    ["Offset of field: SCIP_Lp::soldirection"]
        [::std::mem::offset_of!(SCIP_Lp, soldirection) - 240usize];
    ["Offset of field: SCIP_Lp::divelpistate"]
        [::std::mem::offset_of!(SCIP_Lp, divelpistate) - 248usize];
    ["Offset of field: SCIP_Lp::divechgsides"]
        [::std::mem::offset_of!(SCIP_Lp, divechgsides) - 256usize];
    ["Offset of field: SCIP_Lp::divechgsidetypes"]
        [::std::mem::offset_of!(SCIP_Lp, divechgsidetypes) - 264usize];
    ["Offset of field: SCIP_Lp::divechgrows"]
        [::std::mem::offset_of!(SCIP_Lp, divechgrows) - 272usize];
    ["Offset of field: SCIP_Lp::storedsolvals"]
        [::std::mem::offset_of!(SCIP_Lp, storedsolvals) - 280usize];
    ["Offset of field: SCIP_Lp::validsoldirsol"]
        [::std::mem::offset_of!(SCIP_Lp, validsoldirsol) - 288usize];
    ["Offset of field: SCIP_Lp::validsollp"]
        [::std::mem::offset_of!(SCIP_Lp, validsollp) - 296usize];
    ["Offset of field: SCIP_Lp::validfarkaslp"]
        [::std::mem::offset_of!(SCIP_Lp, validfarkaslp) - 304usize];
    ["Offset of field: SCIP_Lp::validsoldirlp"]
        [::std::mem::offset_of!(SCIP_Lp, validsoldirlp) - 312usize];
    ["Offset of field: SCIP_Lp::validdegeneracylp"]
        [::std::mem::offset_of!(SCIP_Lp, validdegeneracylp) - 320usize];
    ["Offset of field: SCIP_Lp::divenolddomchgs"]
        [::std::mem::offset_of!(SCIP_Lp, divenolddomchgs) - 328usize];
    ["Offset of field: SCIP_Lp::lpicolssize"]
        [::std::mem::offset_of!(SCIP_Lp, lpicolssize) - 336usize];
    ["Offset of field: SCIP_Lp::nlpicols"][::std::mem::offset_of!(SCIP_Lp, nlpicols) - 340usize];
    ["Offset of field: SCIP_Lp::lpifirstchgcol"]
        [::std::mem::offset_of!(SCIP_Lp, lpifirstchgcol) - 344usize];
    ["Offset of field: SCIP_Lp::lpirowssize"]
        [::std::mem::offset_of!(SCIP_Lp, lpirowssize) - 348usize];
    ["Offset of field: SCIP_Lp::nlpirows"][::std::mem::offset_of!(SCIP_Lp, nlpirows) - 352usize];
    ["Offset of field: SCIP_Lp::lpifirstchgrow"]
        [::std::mem::offset_of!(SCIP_Lp, lpifirstchgrow) - 356usize];
    ["Offset of field: SCIP_Lp::chgcolssize"]
        [::std::mem::offset_of!(SCIP_Lp, chgcolssize) - 360usize];
    ["Offset of field: SCIP_Lp::nchgcols"][::std::mem::offset_of!(SCIP_Lp, nchgcols) - 364usize];
    ["Offset of field: SCIP_Lp::chgrowssize"]
        [::std::mem::offset_of!(SCIP_Lp, chgrowssize) - 368usize];
    ["Offset of field: SCIP_Lp::nchgrows"][::std::mem::offset_of!(SCIP_Lp, nchgrows) - 372usize];
    ["Offset of field: SCIP_Lp::colssize"][::std::mem::offset_of!(SCIP_Lp, colssize) - 376usize];
    ["Offset of field: SCIP_Lp::soldirectionsize"]
        [::std::mem::offset_of!(SCIP_Lp, soldirectionsize) - 380usize];
    ["Offset of field: SCIP_Lp::ncols"][::std::mem::offset_of!(SCIP_Lp, ncols) - 384usize];
    ["Offset of field: SCIP_Lp::lazycolssize"]
        [::std::mem::offset_of!(SCIP_Lp, lazycolssize) - 388usize];
    ["Offset of field: SCIP_Lp::nlazycols"][::std::mem::offset_of!(SCIP_Lp, nlazycols) - 392usize];
    ["Offset of field: SCIP_Lp::nremovablecols"]
        [::std::mem::offset_of!(SCIP_Lp, nremovablecols) - 396usize];
    ["Offset of field: SCIP_Lp::firstnewcol"]
        [::std::mem::offset_of!(SCIP_Lp, firstnewcol) - 400usize];
    ["Offset of field: SCIP_Lp::rowssize"][::std::mem::offset_of!(SCIP_Lp, rowssize) - 404usize];
    ["Offset of field: SCIP_Lp::nrows"][::std::mem::offset_of!(SCIP_Lp, nrows) - 408usize];
    ["Offset of field: SCIP_Lp::nremovablerows"]
        [::std::mem::offset_of!(SCIP_Lp, nremovablerows) - 412usize];
    ["Offset of field: SCIP_Lp::firstnewrow"]
        [::std::mem::offset_of!(SCIP_Lp, firstnewrow) - 416usize];
    ["Offset of field: SCIP_Lp::looseobjvalinf"]
        [::std::mem::offset_of!(SCIP_Lp, looseobjvalinf) - 420usize];
    ["Offset of field: SCIP_Lp::nloosevars"]
        [::std::mem::offset_of!(SCIP_Lp, nloosevars) - 424usize];
    ["Offset of field: SCIP_Lp::glbpseudoobjvalinf"]
        [::std::mem::offset_of!(SCIP_Lp, glbpseudoobjvalinf) - 428usize];
    ["Offset of field: SCIP_Lp::pseudoobjvalinf"]
        [::std::mem::offset_of!(SCIP_Lp, pseudoobjvalinf) - 432usize];
    ["Offset of field: SCIP_Lp::ndivingrows"]
        [::std::mem::offset_of!(SCIP_Lp, ndivingrows) - 436usize];
    ["Offset of field: SCIP_Lp::ndivechgsides"]
        [::std::mem::offset_of!(SCIP_Lp, ndivechgsides) - 440usize];
    ["Offset of field: SCIP_Lp::divechgsidessize"]
        [::std::mem::offset_of!(SCIP_Lp, divechgsidessize) - 444usize];
    ["Offset of field: SCIP_Lp::divinglpiitlim"]
        [::std::mem::offset_of!(SCIP_Lp, divinglpiitlim) - 448usize];
    ["Offset of field: SCIP_Lp::lpiitlim"][::std::mem::offset_of!(SCIP_Lp, lpiitlim) - 452usize];
    ["Offset of field: SCIP_Lp::lpifastmip"]
        [::std::mem::offset_of!(SCIP_Lp, lpifastmip) - 456usize];
    ["Offset of field: SCIP_Lp::lpithreads"]
        [::std::mem::offset_of!(SCIP_Lp, lpithreads) - 460usize];
    ["Offset of field: SCIP_Lp::lpitiming"][::std::mem::offset_of!(SCIP_Lp, lpitiming) - 464usize];
    ["Offset of field: SCIP_Lp::lpirandomseed"]
        [::std::mem::offset_of!(SCIP_Lp, lpirandomseed) - 468usize];
    ["Offset of field: SCIP_Lp::lpiscaling"]
        [::std::mem::offset_of!(SCIP_Lp, lpiscaling) - 472usize];
    ["Offset of field: SCIP_Lp::lpirefactorinterval"]
        [::std::mem::offset_of!(SCIP_Lp, lpirefactorinterval) - 476usize];
    ["Offset of field: SCIP_Lp::lpipricing"]
        [::std::mem::offset_of!(SCIP_Lp, lpipricing) - 480usize];
    ["Offset of field: SCIP_Lp::lpsolstat"][::std::mem::offset_of!(SCIP_Lp, lpsolstat) - 484usize];
    ["Offset of field: SCIP_Lp::lastlpalgo"]
        [::std::mem::offset_of!(SCIP_Lp, lastlpalgo) - 488usize];
    ["Offset of field: SCIP_Lp::objsqrnormunreliable"]
        [::std::mem::offset_of!(SCIP_Lp, objsqrnormunreliable) - 492usize];
    ["Offset of field: SCIP_Lp::lpisolutionpolishing"]
        [::std::mem::offset_of!(SCIP_Lp, lpisolutionpolishing) - 496usize];
    ["Offset of field: SCIP_Lp::looseobjvalid"]
        [::std::mem::offset_of!(SCIP_Lp, looseobjvalid) - 500usize];
    ["Offset of field: SCIP_Lp::glbpseudoobjvalid"]
        [::std::mem::offset_of!(SCIP_Lp, glbpseudoobjvalid) - 504usize];
    ["Offset of field: SCIP_Lp::pseudoobjvalid"]
        [::std::mem::offset_of!(SCIP_Lp, pseudoobjvalid) - 508usize];
    ["Offset of field: SCIP_Lp::flushdeletedcols"]
        [::std::mem::offset_of!(SCIP_Lp, flushdeletedcols) - 512usize];
    ["Offset of field: SCIP_Lp::flushaddedcols"]
        [::std::mem::offset_of!(SCIP_Lp, flushaddedcols) - 516usize];
    ["Offset of field: SCIP_Lp::flushdeletedrows"]
        [::std::mem::offset_of!(SCIP_Lp, flushdeletedrows) - 520usize];
    ["Offset of field: SCIP_Lp::flushaddedrows"]
        [::std::mem::offset_of!(SCIP_Lp, flushaddedrows) - 524usize];
    ["Offset of field: SCIP_Lp::updateintegrality"]
        [::std::mem::offset_of!(SCIP_Lp, updateintegrality) - 528usize];
    ["Offset of field: SCIP_Lp::flushed"][::std::mem::offset_of!(SCIP_Lp, flushed) - 532usize];
    ["Offset of field: SCIP_Lp::solved"][::std::mem::offset_of!(SCIP_Lp, solved) - 536usize];
    ["Offset of field: SCIP_Lp::primalfeasible"]
        [::std::mem::offset_of!(SCIP_Lp, primalfeasible) - 540usize];
    ["Offset of field: SCIP_Lp::primalchecked"]
        [::std::mem::offset_of!(SCIP_Lp, primalchecked) - 544usize];
    ["Offset of field: SCIP_Lp::dualfeasible"]
        [::std::mem::offset_of!(SCIP_Lp, dualfeasible) - 548usize];
    ["Offset of field: SCIP_Lp::dualchecked"]
        [::std::mem::offset_of!(SCIP_Lp, dualchecked) - 552usize];
    ["Offset of field: SCIP_Lp::solisbasic"]
        [::std::mem::offset_of!(SCIP_Lp, solisbasic) - 556usize];
    ["Offset of field: SCIP_Lp::rootlpisrelax"]
        [::std::mem::offset_of!(SCIP_Lp, rootlpisrelax) - 560usize];
    ["Offset of field: SCIP_Lp::isrelax"][::std::mem::offset_of!(SCIP_Lp, isrelax) - 564usize];
    ["Offset of field: SCIP_Lp::installing"]
        [::std::mem::offset_of!(SCIP_Lp, installing) - 568usize];
    ["Offset of field: SCIP_Lp::strongbranching"]
        [::std::mem::offset_of!(SCIP_Lp, strongbranching) - 572usize];
    ["Offset of field: SCIP_Lp::probing"][::std::mem::offset_of!(SCIP_Lp, probing) - 576usize];
    ["Offset of field: SCIP_Lp::strongbranchprobing"]
        [::std::mem::offset_of!(SCIP_Lp, strongbranchprobing) - 580usize];
    ["Offset of field: SCIP_Lp::diving"][::std::mem::offset_of!(SCIP_Lp, diving) - 584usize];
    ["Offset of field: SCIP_Lp::divingobjchg"]
        [::std::mem::offset_of!(SCIP_Lp, divingobjchg) - 588usize];
    ["Offset of field: SCIP_Lp::divinglazyapplied"]
        [::std::mem::offset_of!(SCIP_Lp, divinglazyapplied) - 592usize];
    ["Offset of field: SCIP_Lp::resolvelperror"]
        [::std::mem::offset_of!(SCIP_Lp, resolvelperror) - 596usize];
    ["Offset of field: SCIP_Lp::adjustlpval"]
        [::std::mem::offset_of!(SCIP_Lp, adjustlpval) - 600usize];
    ["Offset of field: SCIP_Lp::lpifromscratch"]
        [::std::mem::offset_of!(SCIP_Lp, lpifromscratch) - 604usize];
    ["Offset of field: SCIP_Lp::lpipresolving"]
        [::std::mem::offset_of!(SCIP_Lp, lpipresolving) - 608usize];
    ["Offset of field: SCIP_Lp::lpilpinfo"][::std::mem::offset_of!(SCIP_Lp, lpilpinfo) - 612usize];
    ["Offset of field: SCIP_Lp::lpihasfeastol"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasfeastol) - 616usize];
    ["Offset of field: SCIP_Lp::lpihasdualfeastol"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasdualfeastol) - 620usize];
    ["Offset of field: SCIP_Lp::lpihasbarrierconvtol"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasbarrierconvtol) - 624usize];
    ["Offset of field: SCIP_Lp::lpihasfastmip"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasfastmip) - 628usize];
    ["Offset of field: SCIP_Lp::lpihasscaling"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasscaling) - 632usize];
    ["Offset of field: SCIP_Lp::lpihaspresolving"]
        [::std::mem::offset_of!(SCIP_Lp, lpihaspresolving) - 636usize];
    ["Offset of field: SCIP_Lp::lpihasrowrep"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasrowrep) - 640usize];
    ["Offset of field: SCIP_Lp::lpihaspolishing"]
        [::std::mem::offset_of!(SCIP_Lp, lpihaspolishing) - 644usize];
    ["Offset of field: SCIP_Lp::lpihasrefactor"]
        [::std::mem::offset_of!(SCIP_Lp, lpihasrefactor) - 648usize];
    ["Offset of field: SCIP_Lp::lpirowrepswitch"]
        [::std::mem::offset_of!(SCIP_Lp, lpirowrepswitch) - 656usize];
    ["Offset of field: SCIP_Lp::divelpwasprimfeas"]
        [::std::mem::offset_of!(SCIP_Lp, divelpwasprimfeas) - 664usize];
    ["Offset of field: SCIP_Lp::divelpwasprimchecked"]
        [::std::mem::offset_of!(SCIP_Lp, divelpwasprimchecked) - 668usize];
    ["Offset of field: SCIP_Lp::divelpwasdualfeas"]
        [::std::mem::offset_of!(SCIP_Lp, divelpwasdualfeas) - 672usize];
    ["Offset of field: SCIP_Lp::divelpwasdualchecked"]
        [::std::mem::offset_of!(SCIP_Lp, divelpwasdualchecked) - 676usize];
    ["Offset of field: SCIP_Lp::hasprovedbound"]
        [::std::mem::offset_of!(SCIP_Lp, hasprovedbound) - 680usize];
};
unsafe extern "C" {
    #[doc = " insert column coefficients in corresponding rows"]
    pub fn colLink(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes column coefficients from corresponding rows"]
    pub fn colUnlink(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " insert row coefficients in corresponding columns"]
    pub fn rowLink(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes row coefficients from corresponding columns"]
    pub fn rowUnlink(row: *mut SCIP_ROW, set: *mut SCIP_SET, lp: *mut SCIP_LP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an LP column"]
    pub fn SCIPcolCreate(
        col: *mut *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
        len: ::std::os::raw::c_int,
        rows: *mut *mut SCIP_ROW,
        vals: *mut f64,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees an LP column"]
    pub fn SCIPcolFree(
        col: *mut *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " output column to file stream"]
    pub fn SCIPcolPrint(col: *mut SCIP_COL, messagehdlr: *mut SCIP_MESSAGEHDLR, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " adds a previously non existing coefficient to an LP column"]
    pub fn SCIPcolAddCoef(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        row: *mut SCIP_ROW,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes coefficient from column"]
    pub fn SCIPcolDelCoef(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes or adds a coefficient to an LP column"]
    pub fn SCIPcolChgCoef(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        row: *mut SCIP_ROW,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of an existing or nonexisting coefficient in an LP column"]
    pub fn SCIPcolIncCoef(
        col: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        row: *mut SCIP_ROW,
        incval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes objective value of column"]
    pub fn SCIPcolChgObj(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        newobj: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of column"]
    pub fn SCIPcolChgLb(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        newlb: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of column"]
    pub fn SCIPcolChgUb(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        newub: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates the reduced costs of a column using the given dual solution vector"]
    pub fn SCIPcolCalcRedcost(col: *mut SCIP_COL, dualsol: *mut f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the reduced costs of a column in last LP or after recalculation"]
    pub fn SCIPcolGetRedcost(col: *mut SCIP_COL, stat: *mut SCIP_STAT, lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the feasibility of (the dual row of) a column in last LP or after recalculation"]
    pub fn SCIPcolGetFeasibility(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the Farkas coefficient y^T A_i of a column i using the given dual Farkas vector y"]
    pub fn SCIPcolCalcFarkasCoef(col: *mut SCIP_COL, dualfarkas: *mut f64) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the Farkas coefficient y^T A_i of a column i in last LP (which must be infeasible)"]
    pub fn SCIPcolGetFarkasCoef(col: *mut SCIP_COL, stat: *mut SCIP_STAT, lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the Farkas value of a column in last LP (which must be infeasible), i.e. the Farkas coefficient y^T A_i times\n  the best bound for this coefficient, i.e. max{y^T A_i x_i | lb <= x_i <= ub}"]
    pub fn SCIPcolGetFarkasValue(col: *mut SCIP_COL, stat: *mut SCIP_STAT, lp: *mut SCIP_LP)
    -> f64;
}
unsafe extern "C" {
    #[doc = " start strong branching - call before any strong branching"]
    pub fn SCIPlpStartStrongbranch(lp: *mut SCIP_LP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " end strong branching - call after any strong branching"]
    pub fn SCIPlpEndStrongbranch(lp: *mut SCIP_LP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets strong branching information for a column variable"]
    pub fn SCIPcolSetStrongbranchData(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
        lpobjval: f64,
        primsol: f64,
        sbdown: f64,
        sbup: f64,
        sbdownvalid: ::std::os::raw::c_uint,
        sbupvalid: ::std::os::raw::c_uint,
        iter: ::std::os::raw::c_longlong,
        itlim: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " invalidates strong branching information for a column variable"]
    pub fn SCIPcolInvalidateStrongbranchData(
        col: *mut SCIP_COL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
    );
}
unsafe extern "C" {
    #[doc = " gets strong branching information on a column variable"]
    pub fn SCIPcolGetStrongbranch(
        col: *mut SCIP_COL,
        integral: ::std::os::raw::c_uint,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        itlim: ::std::os::raw::c_int,
        updatecol: ::std::os::raw::c_uint,
        updatestat: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets strong branching information on column variables"]
    pub fn SCIPcolGetStrongbranches(
        cols: *mut *mut SCIP_COL,
        ncols: ::std::os::raw::c_int,
        integral: ::std::os::raw::c_uint,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets last strong branching information available for a column variable;\n  returns values of SCIP_INVALID, if strong branching was not yet called on the given column;\n  keep in mind, that the returned old values may have nothing to do with the current LP solution"]
    pub fn SCIPcolGetStrongbranchLast(
        col: *mut SCIP_COL,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        solval: *mut f64,
        lpobjval: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " if strong branching was already applied on the column at the current node, returns the number of LPs solved after\n  the LP where the strong branching on this column was applied;\n  if strong branching was not yet applied on the column at the current node, returns INT_MAX"]
    pub fn SCIPcolGetStrongbranchLPAge(
        col: *mut SCIP_COL,
        stat: *mut SCIP_STAT,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " marks a column to be not removable from the LP in the current node because it became obsolete"]
    pub fn SCIPcolMarkNotRemovableLocal(col: *mut SCIP_COL, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row"]
    pub fn SCIProwCreate(
        row: *mut *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        origintype: SCIP_ROWORIGINTYPE,
        origin: *mut ::std::os::raw::c_void,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees an LP row"]
    pub fn SCIProwFree(
        row: *mut *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " output row to file stream"]
    pub fn SCIProwPrint(row: *mut SCIP_ROW, messagehdlr: *mut SCIP_MESSAGEHDLR, file: *mut FILE);
}
unsafe extern "C" {
    #[doc = " ensures, that column array of row can store at least num entries"]
    pub fn SCIProwEnsureSize(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        num: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of LP row"]
    pub fn SCIProwCapture(row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary"]
    pub fn SCIProwRelease(
        row: *mut *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enables delaying of row sorting"]
    pub fn SCIProwDelaySort(row: *mut SCIP_ROW);
}
unsafe extern "C" {
    #[doc = " disables delaying of row sorting, sorts row and merges coefficients with equal columns"]
    pub fn SCIProwForceSort(row: *mut SCIP_ROW, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " adds a previously non existing coefficient to an LP row"]
    pub fn SCIProwAddCoef(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        col: *mut SCIP_COL,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes coefficient from row"]
    pub fn SCIProwDelCoef(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        col: *mut SCIP_COL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes or adds a coefficient to an LP row"]
    pub fn SCIProwChgCoef(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        col: *mut SCIP_COL,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of an existing or nonexisting coefficient in an LP column"]
    pub fn SCIProwIncCoef(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        col: *mut SCIP_COL,
        incval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes constant value of a row"]
    pub fn SCIProwChgConstant(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        constant: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add constant value to a row"]
    pub fn SCIProwAddConstant(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        addval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left hand side of LP row"]
    pub fn SCIProwChgLhs(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        lhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of LP row"]
    pub fn SCIProwChgRhs(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the local flag of LP row"]
    pub fn SCIProwChgLocal(row: *mut SCIP_ROW, local: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to find a value, such that all row coefficients, if scaled with this value become integral"]
    pub fn SCIProwCalcIntegralScalar(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " tries to scale row, s.t. all coefficients become integral"]
    pub fn SCIProwMakeIntegral(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recalculates norms of a row"]
    pub fn SCIProwRecalcNorms(row: *mut SCIP_ROW, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " recalculates the current activity of a row"]
    pub fn SCIProwRecalcLPActivity(row: *mut SCIP_ROW, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " returns the activity of a row in the current LP solution"]
    pub fn SCIProwGetLPActivity(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the current LP solution: negative value means infeasibility"]
    pub fn SCIProwGetLPFeasibility(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the current relaxed solution: negative value means infeasibility"]
    pub fn SCIProwGetRelaxFeasibility(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the current NLP solution: negative value means infeasibility"]
    pub fn SCIProwGetNLPFeasibility(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates the current pseudo activity of a row"]
    pub fn SCIProwRecalcPseudoActivity(row: *mut SCIP_ROW, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " returns the pseudo activity of a row in the current pseudo solution"]
    pub fn SCIProwGetPseudoActivity(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the pseudo feasibility of a row in the current pseudo solution: negative value means infeasibility"]
    pub fn SCIProwGetPseudoFeasibility(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for a given solution"]
    pub fn SCIProwGetSolActivity(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row for the given solution"]
    pub fn SCIProwGetSolFeasibility(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the minimal activity of a row w.r.t. the columns' bounds"]
    pub fn SCIProwGetMinActivity(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the maximal activity of a row w.r.t. the columns' bounds"]
    pub fn SCIProwGetMaxActivity(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the row is unmodifiable and redundant w.r.t. the columns' bounds"]
    pub fn SCIProwIsRedundant(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets maximal absolute value of row vector coefficients"]
    pub fn SCIProwGetMaxval(row: *mut SCIP_ROW, set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " gets minimal absolute value of row vector's non-zero coefficients"]
    pub fn SCIProwGetMinval(row: *mut SCIP_ROW, set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " gets maximal column index of row entries"]
    pub fn SCIProwGetMaxidx(row: *mut SCIP_ROW, set: *mut SCIP_SET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets minimal column index of row entries"]
    pub fn SCIProwGetMinidx(row: *mut SCIP_ROW, set: *mut SCIP_SET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of integral columns in row"]
    pub fn SCIProwGetNumIntCols(row: *mut SCIP_ROW, set: *mut SCIP_SET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of implied integral columns in row"]
    pub fn SCIProwGetNumImpliedIntCols(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns row's cutoff distance in the direction of the given primal solution"]
    pub fn SCIProwGetLPSolCutoffDistance(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns row's efficacy with respect to the current LP solution: e = -feasibility/norm"]
    pub fn SCIProwGetLPEfficacy(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the row's efficacy with respect to the current LP solution is greater than the minimal cut efficacy"]
    pub fn SCIProwIsLPEfficacious(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lp: *mut SCIP_LP,
        root: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns row's efficacy with respect to the given primal solution: e = -feasibility/norm"]
    pub fn SCIProwGetSolEfficacy(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns whether the row's efficacy with respect to the given primal solution is greater than the minimal cut\n  efficacy"]
    pub fn SCIProwIsSolEfficacious(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
        root: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns row's efficacy with respect to the relaxed solution: e = -feasibility/norm"]
    pub fn SCIProwGetRelaxEfficacy(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns row's efficacy with respect to the NLP solution: e = -feasibility/norm"]
    pub fn SCIProwGetNLPEfficacy(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets parallelism of row with objective function: if the returned value is 1, the row is parallel to the objective\n  function, if the value is 0, it is orthogonal to the objective function"]
    pub fn SCIProwGetObjParallelism(
        row: *mut SCIP_ROW,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " includes event handler with given data in row's event filter"]
    pub fn SCIProwCatchEvent(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes event handler with given data from row's event filter"]
    pub fn SCIProwDropEvent(
        row: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks a row to be not removable from the LP in the current node"]
    pub fn SCIProwMarkNotRemovableLocal(row: *mut SCIP_ROW, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " creates empty LP data object"]
    pub fn SCIPlpCreate(
        lp: *mut *mut SCIP_LP,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees LP data object"]
    pub fn SCIPlpFree(
        lp: *mut *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets the LP to the empty LP by removing all columns and rows from LP, releasing all rows, and flushing the\n  changes to the LP solver"]
    pub fn SCIPlpReset(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a column to the LP and captures the variable"]
    pub fn SCIPlpAddCol(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        col: *mut SCIP_COL,
        depth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a row to the LP and captures it"]
    pub fn SCIPlpAddRow(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        row: *mut SCIP_ROW,
        depth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all columns after the given number of columns from the LP"]
    pub fn SCIPlpShrinkCols(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        newncols: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes and releases all rows after the given number of rows from the LP"]
    pub fn SCIPlpShrinkRows(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        newnrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all columns and rows from LP, releases all rows"]
    pub fn SCIPlpClear(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " remembers number of columns and rows to track the newly added ones"]
    pub fn SCIPlpMarkSize(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " sets the remembered number of columns and rows to the given values"]
    pub fn SCIPlpSetSizeMark(
        lp: *mut SCIP_LP,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " gets all indices of basic columns and rows: index i >= 0 corresponds to column i, index i < 0 to row -i-1"]
    pub fn SCIPlpGetBasisInd(
        lp: *mut SCIP_LP,
        basisind: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current basis status for columns and rows; arrays must be large enough to store the basis status"]
    pub fn SCIPlpGetBase(
        lp: *mut SCIP_LP,
        cstat: *mut ::std::os::raw::c_int,
        rstat: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a row from the inverse basis matrix B^-1"]
    pub fn SCIPlpGetBInvRow(
        lp: *mut SCIP_LP,
        r: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a column from the inverse basis matrix B^-1"]
    pub fn SCIPlpGetBInvCol(
        lp: *mut SCIP_LP,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a row from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A)"]
    pub fn SCIPlpGetBInvARow(
        lp: *mut SCIP_LP,
        r: ::std::os::raw::c_int,
        binvrow: *mut f64,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets a column from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A),\n  i.e., it computes B^-1 * A_c with A_c being the c'th column of A"]
    pub fn SCIPlpGetBInvACol(
        lp: *mut SCIP_LP,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates a weighted sum of all LP rows; for negative weights, the left and right hand side of the corresponding\n  LP row are swapped in the summation"]
    pub fn SCIPlpSumRows(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        weights: *mut f64,
        sumcoef: *mut SCIP_REALARRAY,
        sumlhs: *mut f64,
        sumrhs: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores LP state (like basis information) into LP state object"]
    pub fn SCIPlpGetState(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads LP state (like basis information) into solver"]
    pub fn SCIPlpSetState(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpistate: *mut SCIP_LPISTATE,
        wasprimfeas: ::std::os::raw::c_uint,
        wasprimchecked: ::std::os::raw::c_uint,
        wasdualfeas: ::std::os::raw::c_uint,
        wasdualchecked: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees LP state information"]
    pub fn SCIPlpFreeState(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " interrupts the currently ongoing lp solve or disables the interrupt"]
    pub fn SCIPlpInterrupt(lp: *mut SCIP_LP, interrupt: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores pricing norms into LP norms object"]
    pub fn SCIPlpGetNorms(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads pricing norms from LP norms object into solver"]
    pub fn SCIPlpSetNorms(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees pricing norms information"]
    pub fn SCIPlpFreeNorms(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return the current cutoff bound of the lp"]
    pub fn SCIPlpGetCutoffbound(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the upper objective limit of the LP solver"]
    pub fn SCIPlpSetCutoffbound(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets current primal feasibility tolerance of LP solver"]
    pub fn SCIPlpGetFeastol(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " sets primal feasibility tolerance of LP solver"]
    pub fn SCIPlpSetFeastol(lp: *mut SCIP_LP, set: *mut SCIP_SET, newfeastol: f64);
}
unsafe extern "C" {
    #[doc = " resets primal feasibility tolerance of LP solver\n\n Sets primal feasibility tolerance to min of numerics/lpfeastolfactor * numerics/feastol and relaxfeastol."]
    pub fn SCIPlpResetFeastol(lp: *mut SCIP_LP, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " applies all cached changes to the LP solver"]
    pub fn SCIPlpFlush(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        eventqueue: *mut SCIP_EVENTQUEUE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks the LP to be flushed, even if the LP thinks it is not flushed"]
    pub fn SCIPlpMarkFlushed(lp: *mut SCIP_LP, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the LP with simplex algorithm, and copy the solution into the column's data"]
    pub fn SCIPlpSolveAndEval(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        prob: *mut SCIP_PROB,
        itlim: ::std::os::raw::c_longlong,
        limitresolveiters: ::std::os::raw::c_uint,
        aging: ::std::os::raw::c_uint,
        keepsol: ::std::os::raw::c_uint,
        forcedlpsolve: ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets solution status of current LP"]
    pub fn SCIPlpGetSolstat(lp: *mut SCIP_LP) -> SCIP_LPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " sets whether the root LP is a relaxation of the problem and its optimal objective value is a global lower bound"]
    pub fn SCIPlpSetRootLPIsRelax(lp: *mut SCIP_LP, isrelax: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " returns whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound"]
    pub fn SCIPlpIsRootLPRelax(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets objective value of current LP\n\n  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible\n        if a limit was hit during solving. It must not be used as a dual bound if the LP solution status is\n        SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT."]
    pub fn SCIPlpGetObjval(lp: *mut SCIP_LP, set: *mut SCIP_SET, prob: *mut SCIP_PROB) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of objective value of current LP that results from COLUMN variables only"]
    pub fn SCIPlpGetColumnObjval(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of objective value of current LP that results from LOOSE variables only"]
    pub fn SCIPlpGetLooseObjval(lp: *mut SCIP_LP, set: *mut SCIP_SET, prob: *mut SCIP_PROB) -> f64;
}
unsafe extern "C" {
    #[doc = " remembers the current LP objective value as root solution value"]
    pub fn SCIPlpStoreRootObjval(lp: *mut SCIP_LP, set: *mut SCIP_SET, prob: *mut SCIP_PROB);
}
unsafe extern "C" {
    #[doc = " invalidates the root LP solution value"]
    pub fn SCIPlpInvalidateRootObjval(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " gets the global pseudo objective value; that is all variables set to their best (w.r.t. the objective function)\n  global bound"]
    pub fn SCIPlpGetGlobalPseudoObjval(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " recomputes local and global pseudo objective values"]
    pub fn SCIPlpRecomputeLocalAndGlobalPseudoObjval(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
    );
}
unsafe extern "C" {
    #[doc = " gets the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound"]
    pub fn SCIPlpGetPseudoObjval(lp: *mut SCIP_LP, set: *mut SCIP_SET, prob: *mut SCIP_PROB)
    -> f64;
}
unsafe extern "C" {
    #[doc = " gets pseudo objective value, if a bound of the given variable would be modified in the given way"]
    pub fn SCIPlpGetModifiedPseudoObjval(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        var: *mut SCIP_VAR,
        oldbound: f64,
        newbound: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " updates current pseudo and loose objective value for a change in a variable's objective coefficient"]
    pub fn SCIPlpUpdateVarObj(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldobj: f64,
        newobj: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current root pseudo objective value for a global change in a variable's lower bound"]
    pub fn SCIPlpUpdateVarLbGlobal(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldlb: f64,
        newlb: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current pseudo and loose objective value for a change in a variable's lower bound"]
    pub fn SCIPlpUpdateVarLb(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldlb: f64,
        newlb: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current root pseudo objective value for a global change in a variable's upper bound"]
    pub fn SCIPlpUpdateVarUbGlobal(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldub: f64,
        newub: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current pseudo objective value for a change in a variable's upper bound"]
    pub fn SCIPlpUpdateVarUb(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldub: f64,
        newub: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given variable was added to the problem"]
    pub fn SCIPlpUpdateAddVar(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given variable is to be deleted from the problem"]
    pub fn SCIPlpUpdateDelVar(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given formerly loose problem variable is now a column variable"]
    pub fn SCIPlpUpdateVarColumn(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given formerly column problem variable is now again a loose variable"]
    pub fn SCIPlpUpdateVarLoose(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decrease the number of loose variables by one"]
    pub fn SCIPlpDecNLoosevars(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " stores the LP solution in the columns and rows"]
    pub fn SCIPlpGetSol(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primalfeasible: *mut ::std::os::raw::c_uint,
        dualfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores LP solution with infinite objective value in the columns and rows"]
    pub fn SCIPlpGetUnboundedSol(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primalfeasible: *mut ::std::os::raw::c_uint,
        rayfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns primal ray proving the unboundedness of the current LP"]
    pub fn SCIPlpGetPrimalRay(lp: *mut SCIP_LP, set: *mut SCIP_SET, ray: *mut f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores the dual Farkas multipliers for infeasibility proof in rows. besides, the proof is checked for validity if\n  lp/checkfarkas = TRUE.\n\n  @note the check will not be performed if @p valid is NULL."]
    pub fn SCIPlpGetDualfarkas(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        forcedlpsolve: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get number of iterations used in last LP solve"]
    pub fn SCIPlpGetIterations(
        lp: *mut SCIP_LP,
        iterations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases age of columns with solution value 0.0 and rows with activity not at its bounds,\n  resets age of non-zero columns and sharp rows"]
    pub fn SCIPlpUpdateAges(lp: *mut SCIP_LP, stat: *mut SCIP_STAT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all non-basic columns and basic rows in the part of the LP created at the current node, that are too old"]
    pub fn SCIPlpRemoveNewObsoletes(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all non-basic columns and basic rows in whole LP, that are too old"]
    pub fn SCIPlpRemoveAllObsoletes(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all non-basic columns at 0.0 and basic rows in the part of the LP created at the current node"]
    pub fn SCIPlpCleanupNew(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        root: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all non-basic columns at 0.0 and basic rows in the whole LP"]
    pub fn SCIPlpCleanupAll(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        root: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all redundant rows that were added at the current node"]
    pub fn SCIPlpRemoveRedundantRows(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initiates LP diving"]
    pub fn SCIPlpStartDive(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " quits LP diving and resets bounds and objective values of columns to the current node's values"]
    pub fn SCIPlpEndDive(
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        prob: *mut SCIP_PROB,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " records a current row side such that any change will be undone after diving"]
    pub fn SCIPlpRecordOldRowSideDive(
        lp: *mut SCIP_LP,
        row: *mut SCIP_ROW,
        sidetype: SCIP_SIDETYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs the LP that probing mode was initiated"]
    pub fn SCIPlpStartProbing(lp: *mut SCIP_LP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs the LP that probing mode was finished"]
    pub fn SCIPlpEndProbing(lp: *mut SCIP_LP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs the LP that the probing mode is now used for strongbranching"]
    pub fn SCIPlpStartStrongbranchProbing(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " informs the LP that the probing mode is not used for strongbranching anymore"]
    pub fn SCIPlpEndStrongbranchProbing(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " gets proven lower (dual) bound of last LP solution"]
    pub fn SCIPlpGetProvedLowerbound(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        bound: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets proven dual bound of last LP solution"]
    pub fn SCIPlpIsInfeasibilityProved(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        proved: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes LP to a file"]
    pub fn SCIPlpWrite(lp: *mut SCIP_LP, fname: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes MIP to a file"]
    pub fn SCIPlpWriteMip(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        fname: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
        origobj: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        lazyconss: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recalculates Euclidean norm of objective function vector of column variables if it have gotten unreliable during calculation"]
    pub fn SCIPlpRecalculateObjSqrNorm(set: *mut SCIP_SET, lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " compute relative interior point"]
    pub fn SCIPlpComputeRelIntPoint(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        lp: *mut SCIP_LP,
        prob: *mut SCIP_PROB,
        relaxrows: ::std::os::raw::c_uint,
        inclobjcutoff: ::std::os::raw::c_uint,
        timelimit: f64,
        iterlimit: ::std::os::raw::c_int,
        point: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes two measures for dual degeneracy (dual degeneracy rate and variable-constraint ratio)\n  based on the changes applied when reducing the problem to the optimal face\n\n  returns the dual degeneracy rate, i.e., the share of nonbasic variables with reduced cost 0\n  and the variable-constraint ratio, i.e., the number of unfixed variables in relation to the basis size"]
    pub fn SCIPlpGetDualDegeneracy(
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        degeneracy: *mut f64,
        varconsratio: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets array with columns of the LP"]
    pub fn SCIPlpGetCols(lp: *mut SCIP_LP) -> *mut *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets current number of columns in LP"]
    pub fn SCIPlpGetNCols(lp: *mut SCIP_LP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets current number of unfixed columns in LP"]
    pub fn SCIPlpGetNUnfixedCols(lp: *mut SCIP_LP, eps: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with rows of the LP"]
    pub fn SCIPlpGetRows(lp: *mut SCIP_LP) -> *mut *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets current number of rows in LP"]
    pub fn SCIPlpGetNRows(lp: *mut SCIP_LP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with newly added columns after the last mark"]
    pub fn SCIPlpGetNewcols(lp: *mut SCIP_LP) -> *mut *mut SCIP_COL;
}
unsafe extern "C" {
    #[doc = " gets number of newly added columns after the last mark"]
    pub fn SCIPlpGetNNewcols(lp: *mut SCIP_LP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array with newly added rows after the last mark"]
    pub fn SCIPlpGetNewrows(lp: *mut SCIP_LP) -> *mut *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " gets number of newly added rows after the last mark"]
    pub fn SCIPlpGetNNewrows(lp: *mut SCIP_LP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets Euclidean norm of objective function vector of column variables, only use this method if\n  lp->objsqrnormunreliable == FALSE, so probably you have to call SCIPlpRecalculateObjSqrNorm before"]
    pub fn SCIPlpGetObjNorm(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the objective value of the root node LP; returns SCIP_INVALID if the root node LP was not (yet) solved"]
    pub fn SCIPlpGetRootObjval(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from COLUMN variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved"]
    pub fn SCIPlpGetRootColumnObjval(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from LOOSE variables only;\n  returns SCIP_INVALID if the root node LP was not (yet) solved"]
    pub fn SCIPlpGetRootLooseObjval(lp: *mut SCIP_LP) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the LP solver interface"]
    pub fn SCIPlpGetLPI(lp: *mut SCIP_LP) -> *mut SCIP_LPI;
}
unsafe extern "C" {
    #[doc = " sets whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound"]
    pub fn SCIPlpSetIsRelax(lp: *mut SCIP_LP, relax: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " returns whether the current LP is a relaxation of the problem for which it has been solved and its\n  solution value a valid local lower bound?"]
    pub fn SCIPlpIsRelax(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current LP is flushed and solved"]
    pub fn SCIPlpIsSolved(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " return whether the current LP solution passed the primal feasibility check"]
    pub fn SCIPlpIsPrimalReliable(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " return whether the current LP solution passed the dual feasibility check"]
    pub fn SCIPlpIsDualReliable(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current LP solution is a basic solution"]
    pub fn SCIPlpIsSolBasic(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the LP is in diving mode"]
    pub fn SCIPlpDiving(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the LP is in diving mode and the objective value of at least one column was changed"]
    pub fn SCIPlpDivingObjChanged(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the diving LP to have a changed objective function"]
    pub fn SCIPlpMarkDivingObjChanged(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    #[doc = " marks the diving LP to not have a changed objective function anymore"]
    pub fn SCIPlpUnmarkDivingObjChanged(lp: *mut SCIP_LP);
}
unsafe extern "C" {
    pub fn SCIPlpDivingRowsChanged(lp: *mut SCIP_LP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if absolute difference of values is in range of LP primal feastol"]
    pub fn SCIPlpIsFeasEQ(
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        val1: f64,
        val2: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if absolute difference of val1 and val2 is lower than LP primal feastol"]
    pub fn SCIPlpIsFeasLT(
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        val1: f64,
        val2: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if absolute difference of val1 and val2 is not greater than LP primal feastol"]
    pub fn SCIPlpIsFeasLE(
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        val1: f64,
        val2: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if absolute difference of val1 and val2 is greater than LP primal feastol"]
    pub fn SCIPlpIsFeasGT(
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        val1: f64,
        val2: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if absolute difference of val1 and val2 is not lower than -LP primal feastol"]
    pub fn SCIPlpIsFeasGE(
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        val1: f64,
        val2: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range LP primal feasibility tolerance of 0.0"]
    pub fn SCIPlpIsFeasZero(lp: *mut SCIP_LP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than LP primal feasibility tolerance"]
    pub fn SCIPlpIsFeasPositive(lp: *mut SCIP_LP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -LP primal feasibility tolerance"]
    pub fn SCIPlpIsFeasNegative(lp: *mut SCIP_LP, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates a rational using standard memory allocation"]
    pub fn SCIPrationalCreate(rational: *mut *mut SCIP_RATIONAL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a rational using buffer memory"]
    pub fn SCIPrationalCreateBuffer(
        bufmem: *mut BMS_BUFMEM,
        rational: *mut *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a rational using block memory"]
    pub fn SCIPrationalCreateBlock(
        blkmem: *mut BMS_BLKMEM,
        rational: *mut *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a rational using ordinary memory"]
    pub fn SCIPrationalCopy(
        result: *mut *mut SCIP_RATIONAL,
        src: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a rational using block memory"]
    pub fn SCIPrationalCopyBlock(
        mem: *mut BMS_BLKMEM,
        result: *mut *mut SCIP_RATIONAL,
        src: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a rational"]
    pub fn SCIPrationalCopyBuffer(
        bufmem: *mut BMS_BUFMEM,
        result: *mut *mut SCIP_RATIONAL,
        src: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an array of rationals using ordinary memory"]
    pub fn SCIPrationalCreateArray(
        rational: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an array of rationals using block memory"]
    pub fn SCIPrationalCreateBlockArray(
        mem: *mut BMS_BLKMEM,
        rational: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an array of rationals using buffer memory"]
    pub fn SCIPrationalCreateBufferArray(
        mem: *mut BMS_BUFMEM,
        rational: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies an array of rationals using ordinary memory"]
    pub fn SCIPrationalCopyArray(
        target: *mut *mut *mut SCIP_RATIONAL,
        src: *mut *mut SCIP_RATIONAL,
        len: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies an array of rationals using block memory"]
    pub fn SCIPrationalCopyBlockArray(
        mem: *mut BMS_BLKMEM,
        target: *mut *mut *mut SCIP_RATIONAL,
        src: *mut *mut SCIP_RATIONAL,
        len: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copy an array of rationals using buffer memory"]
    pub fn SCIPrationalCopyBufferArray(
        mem: *mut BMS_BUFMEM,
        result: *mut *mut *mut SCIP_RATIONAL,
        src: *mut *mut SCIP_RATIONAL,
        len: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " realloc a rational ordinary array"]
    pub fn SCIPrationalReallocArray(
        result: *mut *mut *mut SCIP_RATIONAL,
        oldlen: ::std::os::raw::c_int,
        newlen: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " realloc a rational buffer arrray"]
    pub fn SCIPrationalReallocBufferArray(
        mem: *mut BMS_BUFMEM,
        result: *mut *mut *mut SCIP_RATIONAL,
        oldlen: ::std::os::raw::c_int,
        newlen: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " realloc a rational block arrray"]
    pub fn SCIPrationalReallocBlockArray(
        mem: *mut BMS_BLKMEM,
        result: *mut *mut *mut SCIP_RATIONAL,
        oldlen: ::std::os::raw::c_int,
        newlen: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes a rational and frees the allocated ordinary memory"]
    pub fn SCIPrationalFree(rational: *mut *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " deletes a rational and frees the allocated block memory"]
    pub fn SCIPrationalFreeBlock(mem: *mut BMS_BLKMEM, rational: *mut *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " deletes a rational and frees the allocated buffer memory"]
    pub fn SCIPrationalFreeBuffer(bufmem: *mut BMS_BUFMEM, rational: *mut *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " deletes an array of rationals and frees the allocated ordinary memory"]
    pub fn SCIPrationalFreeArray(
        ratarray: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes an array of rationals and frees the allocated block memory"]
    pub fn SCIPrationalFreeBlockArray(
        mem: *mut BMS_BLKMEM,
        ratblockarray: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " deletes an array of rationals and frees the allocated buffer memory"]
    pub fn SCIPrationalFreeBufferArray(
        mem: *mut BMS_BUFMEM,
        ratbufarray: *mut *mut *mut SCIP_RATIONAL,
        size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets a rational to the value of another rational"]
    pub fn SCIPrationalSetRational(res: *mut SCIP_RATIONAL, src: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " sets a rational to a nom/denom value"]
    pub fn SCIPrationalSetFraction(
        res: *mut SCIP_RATIONAL,
        nom: ::std::os::raw::c_longlong,
        denom: ::std::os::raw::c_longlong,
    );
}
unsafe extern "C" {
    #[doc = " sets a rational to the value of another a real"]
    pub fn SCIPrationalSetReal(res: *mut SCIP_RATIONAL, real: f64);
}
unsafe extern "C" {
    #[doc = " sets a rational to positive infinity"]
    pub fn SCIPrationalSetInfinity(res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " sets a rational to negative infinity"]
    pub fn SCIPrationalSetNegInfinity(res: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " checks if a string describes a rational number"]
    pub fn SCIPrationalIsString(desc: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets a rational to the value described by a string"]
    pub fn SCIPrationalSetString(res: *mut SCIP_RATIONAL, desc: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " allocates and creates a rational from a string if known, otherwise assigns a null pointer"]
    pub fn SCIPrationalCreateString(
        mem: *mut BMS_BLKMEM,
        rational: *mut *mut SCIP_RATIONAL,
        desc: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " extract the next token as a rational value if it is one; in case no value is parsed the endptr is set to @p desc\n\n  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToRationalValue(
        desc: *mut ::std::os::raw::c_char,
        value: *mut SCIP_RATIONAL,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " resets the flag isfprepresentable to SCIP_ISFPREPRESENTABLE_UNKNOWN"]
    pub fn SCIPrationalResetFloatingPointRepresentable(rat: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    pub fn SCIPrationalCanonicalize(rational: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    pub fn SCIPrationalCheckInfByValue(rational: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " adds two rationals and saves the result in res"]
    pub fn SCIPrationalAdd(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " adds a rational and a real and saves the result in res"]
    pub fn SCIPrationalAddReal(res: *mut SCIP_RATIONAL, rat: *mut SCIP_RATIONAL, real: f64);
}
unsafe extern "C" {
    #[doc = " subtracts two rationals and saves the result in res"]
    pub fn SCIPrationalDiff(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " subtracts a rational and a real and saves the result in res"]
    pub fn SCIPrationalDiffReal(res: *mut SCIP_RATIONAL, rat: *mut SCIP_RATIONAL, real: f64);
}
unsafe extern "C" {
    #[doc = " returns the relative difference: (val1-val2)/max(|val1|,|val2|,1.0) of two rationals\n\n  @note this method handles infinity like finite numbers"]
    pub fn SCIPrationalRelDiff(
        res: *mut SCIP_RATIONAL,
        val1: *mut SCIP_RATIONAL,
        val2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " multiplies two rationals and saves the result in res"]
    pub fn SCIPrationalMult(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " multiply a rational and a real and save the result in res"]
    pub fn SCIPrationalMultReal(res: *mut SCIP_RATIONAL, op1: *mut SCIP_RATIONAL, op2: f64);
}
unsafe extern "C" {
    #[doc = " divide two rationals and save the result in res"]
    pub fn SCIPrationalDiv(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " divide a rational by a real and save the result in res"]
    pub fn SCIPrationalDivReal(res: *mut SCIP_RATIONAL, op1: *mut SCIP_RATIONAL, op2: f64);
}
unsafe extern "C" {
    pub fn SCIPrationalAddProd(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    pub fn SCIPrationalAddProdReal(res: *mut SCIP_RATIONAL, op1: *mut SCIP_RATIONAL, op2: f64);
}
unsafe extern "C" {
    pub fn SCIPrationalDiffProd(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    pub fn SCIPrationalDiffProdReal(res: *mut SCIP_RATIONAL, op1: *mut SCIP_RATIONAL, op2: f64);
}
unsafe extern "C" {
    #[doc = " set res to -op"]
    pub fn SCIPrationalNegate(res: *mut SCIP_RATIONAL, op: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " set res to Abs(op)"]
    pub fn SCIPrationalAbs(res: *mut SCIP_RATIONAL, op: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " set res to 1/op"]
    pub fn SCIPrationalInvert(res: *mut SCIP_RATIONAL, op: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " compute the minimum of two rationals"]
    pub fn SCIPrationalMin(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " compute the maximum of two rationals"]
    pub fn SCIPrationalMax(
        res: *mut SCIP_RATIONAL,
        op1: *mut SCIP_RATIONAL,
        op2: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " checks if two rationals are equal"]
    pub fn SCIPrationalIsEQ(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if two rationals are equal"]
    pub fn SCIPrationalIsAbsEQ(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational and real are equal"]
    pub fn SCIPrationalIsEQReal(rat: *mut SCIP_RATIONAL, real: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if real approx of rational and real are equal"]
    pub fn SCIPrationalIsApproxEQReal(
        set: *mut SCIP_SET,
        rat: *mut SCIP_RATIONAL,
        real: f64,
        roundmode: SCIP_ROUNDMODE_RAT,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if first rational is greater than second rational"]
    pub fn SCIPrationalIsGT(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if first rational is smaller than second rational"]
    pub fn SCIPrationalIsLT(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if first rational is greater or equal than second rational"]
    pub fn SCIPrationalIsGE(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if first rational is less or equal than second rational"]
    pub fn SCIPrationalIsLE(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if first rational is greater than second rational"]
    pub fn SCIPrationalIsAbsGT(
        rat1: *mut SCIP_RATIONAL,
        rat2: *mut SCIP_RATIONAL,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is greater than real"]
    pub fn SCIPrationalIsGTReal(rat: *mut SCIP_RATIONAL, real: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is less than real"]
    pub fn SCIPrationalIsLTReal(rat: *mut SCIP_RATIONAL, real: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is greater or equal than real"]
    pub fn SCIPrationalIsGEReal(rat: *mut SCIP_RATIONAL, real: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is less or equal than real"]
    pub fn SCIPrationalIsLEReal(rat: *mut SCIP_RATIONAL, real: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is zero"]
    pub fn SCIPrationalIsZero(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is positive"]
    pub fn SCIPrationalIsPositive(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is negative"]
    pub fn SCIPrationalIsNegative(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is positive infinity"]
    pub fn SCIPrationalIsInfinity(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is negative infinity"]
    pub fn SCIPrationalIsNegInfinity(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is negative infinity"]
    pub fn SCIPrationalIsAbsInfinity(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is integral"]
    pub fn SCIPrationalIsIntegral(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if rational is exactly representable as real"]
    pub fn SCIPrationalIsFpRepresentable(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " converts a rational to a string for printing, returns the number of copied characters.\n\n  @return number of characters printed into string, see also SCIPstrncpy()\n\n  @note If return value is equal to strlen, it means the string was truncated."]
    pub fn SCIPrationalToString(
        rational: *mut SCIP_RATIONAL,
        str_: *mut ::std::os::raw::c_char,
        strlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the strlen of a rational number"]
    pub fn SCIPrationalStrLen(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " prints rational into a file using message handler"]
    pub fn SCIPrationalMessage(
        msg: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        rational: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " prints rational depending on the verbosity level"]
    pub fn SCIPrationalPrintVerbInfo(
        msg: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        rational: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " prints a rational to command line (for debugging)"]
    pub fn SCIPrationalPrint(rational: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " printf extension for rationals (does not support all format options yet)"]
    pub fn SCIPrationalPrintf(formatstr: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    #[doc = " prints a debug message"]
    pub fn SCIPrationalPrintDebugMessage(
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " returns the numerator of a rational as a long"]
    pub fn SCIPrationalNumerator(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " returns the denominator of a rational as a long"]
    pub fn SCIPrationalDenominator(rational: *mut SCIP_RATIONAL) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " compares denominator of a rational to a long"]
    pub fn SCIPrationalDenominatorIsLE(
        rational: *mut SCIP_RATIONAL,
        val: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the sign of the rational (1 if positive, -1 if negative, 0 if zero)"]
    pub fn SCIPrationalGetSign(rational: *const SCIP_RATIONAL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " computes fractional part of a rational number"]
    pub fn SCIPrationalGetFrac(res: *mut SCIP_RATIONAL, src: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " returns approximation of rational as SCIP_Real"]
    pub fn SCIPrationalGetReal(rational: *mut SCIP_RATIONAL) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the relaxation of a rational as a real\n\n  @note Requires MPFR if rational is not fp-representable and roundmode is different from SCIP_R_ROUND_NEAREST."]
    pub fn SCIPrationalRoundReal(
        rational: *mut SCIP_RATIONAL,
        roundmode: SCIP_ROUNDMODE_RAT,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds a rational to an integer and saves it as a rational"]
    pub fn SCIPrationalRoundInteger(
        res: *mut SCIP_RATIONAL,
        src: *mut SCIP_RATIONAL,
        roundmode: SCIP_ROUNDMODE_RAT,
    );
}
unsafe extern "C" {
    #[doc = " rounds rational to next integer in direction of roundmode\n\n  @return FALSE if rational outside of long-range"]
    pub fn SCIPrationalRoundLong(
        res: *mut ::std::os::raw::c_longlong,
        src: *mut SCIP_RATIONAL,
        roundmode: SCIP_ROUNDMODE_RAT,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compute an approximate number with denominator <= maxdenom, closest to src and save it in res using continued fractions"]
    pub fn SCIPrationalComputeApproximation(
        res: *mut SCIP_RATIONAL,
        src: *mut SCIP_RATIONAL,
        maxdenom: ::std::os::raw::c_longlong,
        forcegreater: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " creates a dynamic array of real values"]
    pub fn SCIPrationalarrayCreate(
        rationalarray: *mut *mut SCIP_RATIONALARRAY,
        blkmem: *mut BMS_BLKMEM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resizes a dynamic array of real values"]
    pub fn SCIPrationalarrayResize(
        rationalarray: *mut SCIP_RATIONALARRAY,
        newsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a dynamic array of real values"]
    pub fn SCIPrationalarrayCopy(
        rationalarray: *mut *mut SCIP_RATIONALARRAY,
        blkmem: *mut BMS_BLKMEM,
        sourcerationalarray: *mut SCIP_RATIONALARRAY,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees a dynamic array of real values"]
    pub fn SCIPrationalarrayFree(
        rationalarray: *mut *mut SCIP_RATIONALARRAY,
        blkmem: *mut BMS_BLKMEM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPrationalarrayGetVal(
        rationalarray: *mut SCIP_RATIONALARRAY,
        idx: ::std::os::raw::c_int,
        result: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " sets value of entry in dynamic array"]
    pub fn SCIPrationalarraySetVal(
        rationalarray: *mut SCIP_RATIONALARRAY,
        idx: ::std::os::raw::c_int,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of entry in dynamic array"]
    pub fn SCIPrationalarrayIncVal(
        rationalarray: *mut SCIP_RATIONALARRAY,
        idx: ::std::os::raw::c_int,
        incval: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " prints a rationalarray to std out"]
    pub fn SCIPrationalarrayPrint(rationalarray: *mut SCIP_RATIONALARRAY) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements"]
    pub fn SCIPrationalarrayGetMinIdx(
        rationalarray: *mut SCIP_RATIONALARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements"]
    pub fn SCIPrationalarrayGetMaxIdx(
        rationalarray: *mut SCIP_RATIONALARRAY,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " changes the infinity threshold to new value"]
    pub fn SCIPrationalChgInfinity(inf: f64);
}
unsafe extern "C" {
    #[doc = " return the infinity threshold for rationals"]
    pub fn SCIPrationalGetInfinity() -> f64;
}
unsafe extern "C" {
    #[doc = " creates an LP column"]
    pub fn SCIPcolExactCreate(
        col: *mut *mut SCIP_COLEXACT,
        fpcol: *mut SCIP_COL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
        len: ::std::os::raw::c_int,
        rows: *mut *mut SCIP_ROWEXACT,
        vals: *mut *mut SCIP_RATIONAL,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees an LP column"]
    pub fn SCIPcolExactFree(col: *mut *mut SCIP_COLEXACT, blkmem: *mut BMS_BLKMEM) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " output column to file stream"]
    pub fn SCIPcolExactPrint(
        col: *mut SCIP_COLEXACT,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " adds a previously non existing coefficient to an LP column"]
    pub fn SCIPcolExactAddCoef(
        col: *mut SCIP_COLEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        row: *mut SCIP_ROWEXACT,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes coefficient from column"]
    pub fn SCIPcolExactDelCoef(
        col: *mut SCIP_COLEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        row: *mut SCIP_ROWEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes or adds a coefficient to an LP column"]
    pub fn SCIPcolExactChgCoef(
        col: *mut SCIP_COLEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        row: *mut SCIP_ROWEXACT,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of an existing or nonexisting coefficient in an LP column"]
    pub fn SCIPcolExactIncCoef(
        col: *mut SCIP_COLEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        row: *mut SCIP_ROWEXACT,
        incval: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes objective value of column"]
    pub fn SCIPcolExactChgObj(
        col: *mut SCIP_COLEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        newobj: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes lower bound of column"]
    pub fn SCIPcolExactChgLb(
        col: *mut SCIP_COLEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        newlb: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes upper bound of column"]
    pub fn SCIPcolExactChgUb(
        col: *mut SCIP_COLEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        newub: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of LP row"]
    pub fn SCIProwExactCapture(row: *mut SCIP_ROWEXACT);
}
unsafe extern "C" {
    #[doc = " output column to file stream"]
    pub fn SCIProwExactPrint(
        row: *mut SCIP_ROWEXACT,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
unsafe extern "C" {
    #[doc = " get the index of an exact row"]
    pub fn SCIProwExactGetIndex(row: *mut SCIP_ROWEXACT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return TRUE iff row is modifiable"]
    pub fn SCIProwExactIsModifiable(row: *mut SCIP_ROWEXACT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns true, if an exact row for this fprow was already created"]
    pub fn SCIProwHasExRow(
        lpexact: *mut SCIP_LPEXACT,
        row: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " changes left hand side of exact LP row"]
    pub fn SCIProwExactChgLhs(
        rowexact: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        lhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of exact LP row"]
    pub fn SCIProwExactChgRhs(
        rowexact: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        rhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns exact col corresponding to fpcol, if it exists. Otherwise returns NULL"]
    pub fn SCIPcolGetColExact(col: *mut SCIP_COL) -> *mut SCIP_COLEXACT;
}
unsafe extern "C" {
    #[doc = " calculates the Farkas coefficient or reduced cost of a column i using the given dual Farkas vector y"]
    pub fn SCIPcolExactCalcFarkasRedcostCoef(
        col: *mut SCIP_COLEXACT,
        set: *mut SCIP_SET,
        result: *mut SCIP_RATIONAL,
        dual: *mut *mut SCIP_RATIONAL,
        usefarkas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row"]
    pub fn SCIProwExactCreate(
        row: *mut *mut SCIP_ROWEXACT,
        fprow: *mut SCIP_ROW,
        fprowrhs: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lpexact: *mut SCIP_LPEXACT,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COLEXACT,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        isfprelaxable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an exact LP row from a fp row\n\n  @note This may change the floating-point coefficients slightly if the rational representation is rounded to smaller\n  denominators according to parameter exact/cutmaxdenom."]
    pub fn SCIProwExactCreateFromRow(
        fprow: *mut SCIP_ROW,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        prob: *mut SCIP_PROB,
        lpexact: *mut SCIP_LPEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " populate data of two empty fp rows with data from exact row"]
    pub fn SCIProwExactGenerateFpRows(
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        prob: *mut SCIP_PROB,
        row: *mut SCIP_ROWEXACT,
        rowlhs: *mut SCIP_ROW,
        rowrhs: *mut SCIP_ROW,
        onerowrelax: *mut ::std::os::raw::c_uint,
        hasfprelax: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " applies all cached changes to the LP solver"]
    pub fn SCIPlpExactFlush(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " ensures all rows/columns are correctly updated, but changes are not yet communicated to the exact LP solver"]
    pub fn SCIPlpExactLink(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the success rate of the Neumaier-Shcherbina safe bounding method is sufficiently high"]
    pub fn SCIPlpExactBoundShiftUseful(lpexact: *mut SCIP_LPEXACT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether it is possible to use project and shift bounding method"]
    pub fn SCIPlpExactProjectShiftPossible(lpexact: *mut SCIP_LPEXACT) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks that lp and fplp are properly synced"]
    pub fn SCIPlpExactIsSynced(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        msg: *mut SCIP_MESSAGEHDLR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates empty LP data object"]
    pub fn SCIPlpExactCreate(
        lpexact: *mut *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        fplp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees LP data object"]
    pub fn SCIPlpExactFree(
        lpexact: *mut *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a column to the LP and captures the variable"]
    pub fn SCIPlpExactAddCol(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        col: *mut SCIP_COLEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a row to the LP and captures it"]
    pub fn SCIPlpExactAddRow(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        rowexact: *mut SCIP_ROWEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row for the given solution"]
    pub fn SCIProwExactGetSolFeasibility(
        row: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " does activity computation with running error analysis for a row, return TRUE on success"]
    pub fn SCIProwExactGetSolActivityWithErrorbound(
        rowexact: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
        errorbound: *mut f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for a given solution"]
    pub fn SCIProwExactGetSolActivity(
        rowexact: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        sol: *mut SCIP_SOL,
        useexact: ::std::os::raw::c_uint,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary"]
    pub fn SCIProwExactRelease(
        row: *mut *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees an LP row"]
    pub fn SCIProwExactFree(
        row: *mut *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " ensuresr, that column array of row can store at least num entries"]
    pub fn SCIProwExactEnsureSize(
        row: *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        num: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " add constant value to a row"]
    pub fn SCIProwExactAddConstant(
        row: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lpexact: *mut SCIP_LPEXACT,
        addval: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a previously non existing coefficient to an LP row"]
    pub fn SCIProwExactAddCoef(
        rowexact: *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        colexact: *mut SCIP_COLEXACT,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes coefficient from row"]
    pub fn SCIProwExactDelCoef(
        row: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        col: *mut SCIP_COLEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes or adds a coefficient to an LP row"]
    pub fn SCIProwExactChgCoef(
        row: *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        col: *mut SCIP_COLEXACT,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of an existing or nonexisting coefficient in an LP column"]
    pub fn SCIProwExactIncCoef(
        row: *mut SCIP_ROWEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpexact: *mut SCIP_LPEXACT,
        col: *mut SCIP_COLEXACT,
        incval: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes constant value of a row"]
    pub fn SCIProwExactChgConstant(
        row: *mut SCIP_ROWEXACT,
        stat: *mut SCIP_STAT,
        lpexact: *mut SCIP_LPEXACT,
        constant: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row in the current LP solution: negative value means infeasibility"]
    pub fn SCIProwExactGetLPFeasibility(
        row: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        lpexact: *mut SCIP_LPEXACT,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the pseudo feasibility of a row in the current pseudo solution: negative value means infeasibility"]
    pub fn SCIProwExactGetPseudoFeasibility(
        row: *mut SCIP_ROWEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row in the current LP solution"]
    pub fn SCIProwExactGetLPActivity(
        row: *mut SCIP_ROWEXACT,
        stat: *mut SCIP_STAT,
        lpexact: *mut SCIP_LPEXACT,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " returns the pseudo activity of a row in the current pseudo solution"]
    pub fn SCIProwExactGetPseudoActivity(
        row: *mut SCIP_ROWEXACT,
        stat: *mut SCIP_STAT,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " enables delaying of row sorting"]
    pub fn SCIProwExactDelaySort(rowexact: *mut SCIP_ROWEXACT);
}
unsafe extern "C" {
    #[doc = " disables delaying of row sorting, sorts row and merges coefficients with equal columns"]
    pub fn SCIProwExactForceSort(rowexact: *mut SCIP_ROWEXACT, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " recalculates the current activity of a row"]
    pub fn SCIProwExactRecalcLPActivity(rowexact: *mut SCIP_ROWEXACT, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " calculates the current pseudo activity of a row"]
    pub fn SCIProwExactRecalcPseudoActivity(rowexact: *mut SCIP_ROWEXACT, stat: *mut SCIP_STAT);
}
unsafe extern "C" {
    #[doc = " gets objective value of column"]
    pub fn SCIPcolExactGetObj(col: *mut SCIP_COLEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets lower bound of column"]
    pub fn SCIPcolExactGetLb(col: *mut SCIP_COLEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets upper bound of column"]
    pub fn SCIPcolExactGetUb(col: *mut SCIP_COLEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets best bound of column with respect to the objective function"]
    pub fn SCIPcolExactGetBestBound(col: *mut SCIP_COLEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the primal LP solution of a column"]
    pub fn SCIPcolExactGetPrimsol(col: *mut SCIP_COLEXACT) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " updates current pseudo and loose objective value for a change in a variable's objective value"]
    pub fn SCIPlpExactUpdateVarObj(
        set: *mut SCIP_SET,
        lpexact: *mut SCIP_LPEXACT,
        var: *mut SCIP_VAR,
        oldobj: *mut SCIP_RATIONAL,
        newobj: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current root pseudo objective value for a global change in a variable's lower bound"]
    pub fn SCIPlpExactUpdateVarLbGlobal(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldlb: *mut SCIP_RATIONAL,
        newlb: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current pseudo and loose objective value for a change in a variable's lower bound"]
    pub fn SCIPlpExactUpdateVarLb(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldlb: *mut SCIP_RATIONAL,
        newlb: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current root pseudo objective value for a global change in a variable's upper bound"]
    pub fn SCIPlpExactUpdateVarUbGlobal(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldub: *mut SCIP_RATIONAL,
        newub: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates current pseudo objective value for a change in a variable's upper bound"]
    pub fn SCIPlpExactUpdateVarUb(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
        oldub: *mut SCIP_RATIONAL,
        newub: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given variable was added to the problem"]
    pub fn SCIPlpExactUpdateAddVar(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given variable is to be deleted from the problem"]
    pub fn SCIPlpExactUpdateDelVar(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given formerly loose problem variable is now a column variable"]
    pub fn SCIPlpExactUpdateVarColumn(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs LP, that given formerly column problem variable is now again a loose variable"]
    pub fn SCIPlpExactUpdateVarLoose(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decrease the number of loose variables by one"]
    pub fn SCIPlpExactDecNLoosevars(lpexact: *mut SCIP_LPEXACT);
}
unsafe extern "C" {
    pub fn SCIPlpExactGetNRows(lpexact: *mut SCIP_LPEXACT) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " stores the LP solution in the columns and rows"]
    pub fn SCIPlpExactGetSol(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primalfeasible: *mut ::std::os::raw::c_uint,
        dualfeasible: *mut ::std::os::raw::c_uint,
        overwritefplp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores LP solution with infinite objective value in the columns and rows"]
    pub fn SCIPlpExactGetUnboundedSol(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primalfeasible: *mut ::std::os::raw::c_uint,
        rayfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns primal ray proving the unboundedness of the current LP"]
    pub fn SCIPlpExactGetPrimalRay(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        ray: *mut *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores the dual Farkas multipliers for infeasibility proof in rows. besides\n\n  @note The Farkas proof is checked for validity if lp/checkfarkas = TRUE and @p valid is not NULL."]
    pub fn SCIPlpExactGetDualfarkas(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        valid: *mut ::std::os::raw::c_uint,
        overwritefplp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get number of iterations used in last LP solve"]
    pub fn SCIPlpExactGetIterations(
        lpexact: *mut SCIP_LPEXACT,
        iterations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets objective value of current LP\n\n  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible\n        if a limit was hit during solving. It must not be used as a dual bound if the LP solution status is\n        SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT."]
    pub fn SCIPlpExactGetObjval(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        res: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " gets the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the\n  objective function) local bound"]
    pub fn SCIPlpExactGetPseudoObjval(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        res: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " removes all columns after the given number of cols from the LP"]
    pub fn SCIPlpExactShrinkCols(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        newncols: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes and releases all rows after the given number of rows from the LP"]
    pub fn SCIPlpExactShrinkRows(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        newnrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    pub fn SCIPlpExactDelRowset(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        rowdstat: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets the LP to the empty LP by removing all columns and rows from LP, releasing all rows, and flushing the\n  changes to the LP solver"]
    pub fn SCIPlpExactReset(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes all columns and rows from LP, releases all rows"]
    pub fn SCIPlpExactClear(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " forces an exact lp to be solved in the next exact bound computation"]
    pub fn SCIPlpExactForceExactSolve(lpexact: *mut SCIP_LPEXACT, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " forces the next exact bound computation to be executed even in probing mode"]
    pub fn SCIPlpExactForceSafeBound(lpexact: *mut SCIP_LPEXACT, set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " allows an exact lp to be solved in the next exact bound computation"]
    pub fn SCIPlpExactAllowExactSolve(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        allowexact: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " gets solution status of current exact LP"]
    pub fn SCIPlpExactGetSolstat(lpexact: *mut SCIP_LPEXACT) -> SCIP_LPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " sets the upper objective limit of the exact LP solver"]
    pub fn SCIPlpExactSetCutoffbound(
        lpexact: *mut SCIP_LPEXACT,
        set: *mut SCIP_SET,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the LP with simplex algorithm, and copy the solution into the column's data"]
    pub fn SCIPlpExactSolveAndEval(
        lpexact: *mut SCIP_LPEXACT,
        lp: *mut SCIP_LP,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        prob: *mut SCIP_PROB,
        itlim: ::std::os::raw::c_longlong,
        lperror: *mut ::std::os::raw::c_uint,
        usefarkas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores exact LP state (like basis information) into LP state object"]
    pub fn SCIPlpExactGetState(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads exact LP state (like basis information) into solver"]
    pub fn SCIPlpExactSetState(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lpistate: *mut SCIP_LPISTATE,
        wasprimfeas: ::std::os::raw::c_uint,
        wasprimchecked: ::std::os::raw::c_uint,
        wasdualfeas: ::std::os::raw::c_uint,
        wasdualchecked: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees exact LP state information"]
    pub fn SCIPlpExactFreeState(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " starts exact LP diving and saves bounds and objective values of columns to the current nodes's values"]
    pub fn SCIPlpExactStartDive(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " quits exact LP diving and resets bounds and objective values of columns to the current node's values"]
    pub fn SCIPlpExactEndDive(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes exact LP to a file"]
    pub fn SCIPlpExactWrite(
        lpexact: *mut SCIP_LPEXACT,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " overwrites the dual values stored in the fp lp with exact values"]
    pub fn SCIPlpExactOverwriteFpDualSol(
        lpexact: *mut SCIP_LPEXACT,
        dualfarkas: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " synchronizes the exact LP with cuts from the floating-point LP"]
    pub fn SCIPlpExactSyncLPs(
        lpexact: *mut SCIP_LPEXACT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint handler\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowConsExact(
        scip: *mut SCIP,
        rowexact: *mut *mut SCIP_ROWEXACT,
        fprow: *mut SCIP_ROW,
        fprowrhs: *mut SCIP_ROW,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        isfprelaxable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an exact LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowExact(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROWEXACT,
        fprow: *mut SCIP_ROW,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COLEXACT,
        vals: *mut *mut SCIP_RATIONAL,
        lhs: *mut SCIP_RATIONAL,
        rhs: *mut SCIP_RATIONAL,
        isfprelaxable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an exact LP row from an existing fp row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowExactFromRow(scip: *mut SCIP, fprow: *mut SCIP_ROW) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " generates two fprows that are a relaxation of the exact row wrt the lhs/rhs, respectively\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgenerateFpRowsFromRowExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        rowlhs: *mut SCIP_ROW,
        rowrhs: *mut SCIP_ROW,
        onerowrelax: *mut ::std::os::raw::c_uint,
        hasfprelax: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases usage counter of exact LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureRowExact(scip: *mut SCIP, row: *mut SCIP_ROWEXACT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseRowExact(scip: *mut SCIP, row: *mut *mut SCIP_ROWEXACT) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left hand side of exact LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowExactLhs(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        lhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of exact LP row\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowExactRhs(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        rhs: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resolves variables to columns and adds them with the coefficients to the row;\n  this method caches the row extensions and flushes them afterwards to gain better performance\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @attention If a coefficients absolute value is below the SCIP epsilon tolerance, the variable with its value is not added.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRowExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for the given primal solution with running error analysis\n\n  @return the activitiy of a row for the given primal solution and the error bound of the activity; returns true on success\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolActivityWithErrorboundExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
        errorbound: *mut f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the activity of a row for the given primal solution\n\n  @return the activitiy of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolActivityExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        sol: *mut SCIP_SOL,
        useexact: ::std::os::raw::c_uint,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the feasibility of a row for the given primal solution\n\n  @return the feasibility of a row for the given primal solution\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolFeasibilityExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " output exact row to file stream via the message handler system\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre this method can be called in one of the following stages of the SCIP solving process:\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRowExact(
        scip: *mut SCIP,
        row: *mut SCIP_ROWEXACT,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the exact lp was solved"]
    pub fn SCIPlpExactIsSolved(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets solution status of current exact LP\n\n  @return the solution status of current exact LP.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPExactSolstat(scip: *mut SCIP) -> SCIP_LPSOLSTAT;
}
unsafe extern "C" {
    #[doc = " gets objective value of current exact LP (which is the sum of column and loose objective value)\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible\n        if a limit was hit during solving. It must not be used as a dual bound if the exact LP solution status\n        returned by SCIPgetLPExactSolstat() is SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT.\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPExactObjval(scip: *mut SCIP, result: *mut SCIP_RATIONAL);
}
unsafe extern "C" {
    #[doc = " changes variable's lower bound in current exact dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarLbExactDive(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes variable's upper bound in current exact dive\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarUbExactDive(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves the exact LP of the current dive; no separation or pricing is applied\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolveExactDiveLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initiates exact LP diving, making methods SCIPchgVarObjExactDive(), SCIPchgVarLbExactDive(), and SCIPchgVarUbExactDive() available\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note In parallel to exact LP diving, this method also starts the regular LP diving mode by calling SCIPstartDive()."]
    pub fn SCIPstartExactDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks if exact diving mode is possible at this point in time\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages.\n\n  @note In parallel to exact LP diving, this method also starts the regular LP diving mode by calling SCIPstartDive()."]
    pub fn SCIPisExactDivePossible(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether we are in exact diving mode\n\n  @return whether we are in exact diving mode.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_TRANSFORMING\n       - \\ref SCIP_STAGE_TRANSFORMED\n       - \\ref SCIP_STAGE_INITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVING\n       - \\ref SCIP_STAGE_EXITPRESOLVE\n       - \\ref SCIP_STAGE_PRESOLVED\n       - \\ref SCIP_STAGE_INITSOLVE\n       - \\ref SCIP_STAGE_SOLVING\n       - \\ref SCIP_STAGE_SOLVED\n       - \\ref SCIP_STAGE_EXITSOLVE\n       - \\ref SCIP_STAGE_FREETRANS\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinExactDive(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " quits exact LP diving and resets bounds and objective values of columns to the current node's values\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPendExactDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes current exact LP to a file\n\n  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref\n          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes.\n\n  @pre This method can be called if @p scip is in one of the following stages:\n       - \\ref SCIP_STAGE_SOLVING\n\n  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteLPexact(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DebugSolData {
    _unused: [u8; 0],
}
#[doc = " solution data for debugging purposes"]
pub type SCIP_DEBUGSOLDATA = SCIP_DebugSolData;
#[doc = " global SCIP settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Set {
    #[doc = "< SCIP operation stage"]
    pub stage: SCIP_STAGE,
    #[doc = "< very ugly: pointer to scip main data structure for callback methods"]
    pub scip: *mut SCIP,
    #[doc = "< set of parameters"]
    pub paramset: *mut SCIP_PARAMSET,
    #[doc = "< memory buffers for short living temporary objects"]
    pub buffer: *mut BMS_BUFMEM,
    #[doc = "< memory buffers for short living temporary objects init. to all zero"]
    pub cleanbuffer: *mut BMS_BUFMEM,
    #[doc = "< file readers"]
    pub readers: *mut *mut SCIP_READER,
    #[doc = "< variable pricers"]
    pub pricers: *mut *mut SCIP_PRICER,
    #[doc = "< constraint handlers (sorted by check priority)"]
    pub conshdlrs: *mut *mut SCIP_CONSHDLR,
    #[doc = "< constraint handlers (sorted by separation priority)"]
    pub conshdlrs_sepa: *mut *mut SCIP_CONSHDLR,
    #[doc = "< constraint handlers (sorted by enforcement priority)"]
    pub conshdlrs_enfo: *mut *mut SCIP_CONSHDLR,
    #[doc = "< constraint handlers (sorted by inclusion order)"]
    pub conshdlrs_include: *mut *mut SCIP_CONSHDLR,
    #[doc = "< conflict handlers"]
    pub conflicthdlrs: *mut *mut SCIP_CONFLICTHDLR,
    #[doc = "< presolvers"]
    pub presols: *mut *mut SCIP_PRESOL,
    #[doc = "< relaxators"]
    pub relaxs: *mut *mut SCIP_RELAX,
    #[doc = "< separators"]
    pub sepas: *mut *mut SCIP_SEPA,
    #[doc = "< cut selectors"]
    pub cutsels: *mut *mut SCIP_CUTSEL,
    #[doc = "< propagators"]
    pub props: *mut *mut SCIP_PROP,
    #[doc = "< propagators (sorted by presol priority)"]
    pub props_presol: *mut *mut SCIP_PROP,
    #[doc = "< primal heuristics"]
    pub heurs: *mut *mut SCIP_HEUR,
    #[doc = "< tree compressions"]
    pub comprs: *mut *mut SCIP_COMPR,
    #[doc = "< event handlers"]
    pub eventhdlrs: *mut *mut SCIP_EVENTHDLR,
    #[doc = "< node selectors"]
    pub nodesels: *mut *mut SCIP_NODESEL,
    #[doc = "< currently used node selector, or NULL if invalid"]
    pub nodesel: *mut SCIP_NODESEL,
    #[doc = "< branching rules"]
    pub branchrules: *mut *mut SCIP_BRANCHRULE,
    #[doc = "< irreducible infeasible subsystem (IIS) rules"]
    pub iisfinders: *mut *mut SCIP_IISFINDER,
    #[doc = "< display columns"]
    pub disps: *mut *mut SCIP_DISP,
    #[doc = "< statistics tables"]
    pub tables: *mut *mut SCIP_TABLE,
    #[doc = "< dialogs"]
    pub dialogs: *mut *mut SCIP_DIALOG,
    #[doc = "< expression handlers"]
    pub exprhdlrs: *mut *mut SCIP_EXPRHDLR,
    #[doc = "< expression handler for variables (for quick access)"]
    pub exprhdlrvar: *mut SCIP_EXPRHDLR,
    #[doc = "< expression handler for constant values (for quick access)"]
    pub exprhdlrval: *mut SCIP_EXPRHDLR,
    #[doc = "< expression handler for sums (for quick access)"]
    pub exprhdlrsum: *mut SCIP_EXPRHDLR,
    #[doc = "< expression handler for products (for quick access)"]
    pub exprhdlrproduct: *mut SCIP_EXPRHDLR,
    #[doc = "< expression handler for power (for quick access)"]
    pub exprhdlrpow: *mut SCIP_EXPRHDLR,
    #[doc = "< interfaces to NLP solvers"]
    pub nlpis: *mut *mut SCIP_NLPI,
    #[doc = "< concurrent solver types"]
    pub concsolvertypes: *mut *mut SCIP_CONCSOLVERTYPE,
    #[doc = "< the concurrent solvers used for solving"]
    pub concsolvers: *mut *mut SCIP_CONCSOLVER,
    #[doc = "< the data structures managing the Benders' decomposition algorithm"]
    pub benders: *mut *mut SCIP_BENDERS,
    #[doc = "< data for debug solutions"]
    pub debugsoldata: *mut SCIP_DEBUGSOLDATA,
    #[doc = "< virtual function tables for bandit algorithms"]
    pub banditvtables: *mut *mut SCIP_BANDITVTABLE,
    #[doc = "< names of externals codes"]
    pub extcodenames: *mut *mut ::std::os::raw::c_char,
    #[doc = "< descriptions of external codes"]
    pub extcodedescs: *mut *mut ::std::os::raw::c_char,
    #[doc = "< number of file readers"]
    pub nreaders: ::std::os::raw::c_int,
    #[doc = "< size of readers array"]
    pub readerssize: ::std::os::raw::c_int,
    #[doc = "< number of variable pricers"]
    pub npricers: ::std::os::raw::c_int,
    #[doc = "< number of variable pricers used in the current problem"]
    pub nactivepricers: ::std::os::raw::c_int,
    #[doc = "< size of pricers array"]
    pub pricerssize: ::std::os::raw::c_int,
    #[doc = "< number of constraint handlers"]
    pub nconshdlrs: ::std::os::raw::c_int,
    #[doc = "< size of conshdlrs array"]
    pub conshdlrssize: ::std::os::raw::c_int,
    #[doc = "< number of conflict handlers"]
    pub nconflicthdlrs: ::std::os::raw::c_int,
    #[doc = "< size of conflicthdlrs array"]
    pub conflicthdlrssize: ::std::os::raw::c_int,
    #[doc = "< number of presolvers"]
    pub npresols: ::std::os::raw::c_int,
    #[doc = "< size of presols array"]
    pub presolssize: ::std::os::raw::c_int,
    #[doc = "< number of relaxators"]
    pub nrelaxs: ::std::os::raw::c_int,
    #[doc = "< size of relaxs array"]
    pub relaxssize: ::std::os::raw::c_int,
    #[doc = "< number of separators"]
    pub nsepas: ::std::os::raw::c_int,
    #[doc = "< size of sepas array"]
    pub sepassize: ::std::os::raw::c_int,
    #[doc = "< number of cut selectors"]
    pub ncutsels: ::std::os::raw::c_int,
    #[doc = "< size of cutsels array"]
    pub cutselssize: ::std::os::raw::c_int,
    #[doc = "< number of propagators"]
    pub nprops: ::std::os::raw::c_int,
    #[doc = "< size of props array"]
    pub propssize: ::std::os::raw::c_int,
    #[doc = "< number of primal heuristics"]
    pub nheurs: ::std::os::raw::c_int,
    #[doc = "< size of heurs array"]
    pub heurssize: ::std::os::raw::c_int,
    #[doc = "< number of tree compressions"]
    pub ncomprs: ::std::os::raw::c_int,
    #[doc = "< size of comprs array"]
    pub comprssize: ::std::os::raw::c_int,
    #[doc = "< number of event handlers"]
    pub neventhdlrs: ::std::os::raw::c_int,
    #[doc = "< size of eventhdlrs array"]
    pub eventhdlrssize: ::std::os::raw::c_int,
    #[doc = "< number of node selectors"]
    pub nnodesels: ::std::os::raw::c_int,
    #[doc = "< size of nodesels array"]
    pub nodeselssize: ::std::os::raw::c_int,
    #[doc = "< number of branching rules"]
    pub nbranchrules: ::std::os::raw::c_int,
    #[doc = "< size of branchrules array"]
    pub branchrulessize: ::std::os::raw::c_int,
    #[doc = "< number of IIS rules"]
    pub niisfinders: ::std::os::raw::c_int,
    #[doc = "< size of IIS finders array"]
    pub iisfinderssize: ::std::os::raw::c_int,
    #[doc = "< number of display columns"]
    pub ndisps: ::std::os::raw::c_int,
    #[doc = "< size of disps array"]
    pub dispssize: ::std::os::raw::c_int,
    #[doc = "< number of statistics tables"]
    pub ntables: ::std::os::raw::c_int,
    #[doc = "< size of tables array"]
    pub tablessize: ::std::os::raw::c_int,
    #[doc = "< number of dialogs"]
    pub ndialogs: ::std::os::raw::c_int,
    #[doc = "< size of dialogs array"]
    pub dialogssize: ::std::os::raw::c_int,
    #[doc = "< number of expression handlers"]
    pub nexprhdlrs: ::std::os::raw::c_int,
    #[doc = "< size of expression handlers array"]
    pub exprhdlrssize: ::std::os::raw::c_int,
    #[doc = "< number of NLPIs"]
    pub nnlpis: ::std::os::raw::c_int,
    #[doc = "< size of NLPIs array"]
    pub nlpissize: ::std::os::raw::c_int,
    #[doc = "< number of concurrent solver types"]
    pub nconcsolvertypes: ::std::os::raw::c_int,
    #[doc = "< size of concurrent solver types array"]
    pub concsolvertypessize: ::std::os::raw::c_int,
    #[doc = "< number of concurrent solvers used for solving"]
    pub nconcsolvers: ::std::os::raw::c_int,
    #[doc = "< size of concurrent solvers array"]
    pub concsolverssize: ::std::os::raw::c_int,
    #[doc = "< number of Benders' decomposition algorithms"]
    pub nbenders: ::std::os::raw::c_int,
    #[doc = "< number of Benders' decomposition algorithms that are used"]
    pub nactivebenders: ::std::os::raw::c_int,
    #[doc = "< size of Benders' decomposition algorithms array"]
    pub benderssize: ::std::os::raw::c_int,
    #[doc = "< number of external codes"]
    pub nextcodes: ::std::os::raw::c_int,
    #[doc = "< size of external code arrays"]
    pub extcodessize: ::std::os::raw::c_int,
    #[doc = "< number of bandit algorithm virtual function tables"]
    pub nbanditvtables: ::std::os::raw::c_int,
    #[doc = "< size of banditvtables array"]
    pub banditvtablessize: ::std::os::raw::c_int,
    #[doc = "< are the pricers sorted by activity and priority?"]
    pub pricerssorted: ::std::os::raw::c_uint,
    #[doc = "< are the pricers sorted by name?"]
    pub pricersnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the conflict handlers sorted by priority?"]
    pub conflicthdlrssorted: ::std::os::raw::c_uint,
    #[doc = "< are the conflict handlers sorted by name?"]
    pub conflicthdlrsnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the presolvers sorted by priority?"]
    pub presolssorted: ::std::os::raw::c_uint,
    #[doc = "< are the presolvers sorted by name?"]
    pub presolsnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the relaxators sorted by priority?"]
    pub relaxssorted: ::std::os::raw::c_uint,
    #[doc = "< are the relaxators sorted by name?"]
    pub relaxsnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the separators sorted by priority?"]
    pub sepassorted: ::std::os::raw::c_uint,
    #[doc = "< are the separators sorted by name?"]
    pub sepasnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the cutsels sorted by priority?"]
    pub cutselssorted: ::std::os::raw::c_uint,
    #[doc = "< are the propagators sorted by priority?"]
    pub propssorted: ::std::os::raw::c_uint,
    #[doc = "< are the propagators in prop_presol sorted?"]
    pub propspresolsorted: ::std::os::raw::c_uint,
    #[doc = "< are the propagators sorted by name?"]
    pub propsnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the heuristics sorted by priority?"]
    pub heurssorted: ::std::os::raw::c_uint,
    #[doc = "< are the heuristics sorted by name?"]
    pub heursnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the compressions sorted by priority?"]
    pub comprssorted: ::std::os::raw::c_uint,
    #[doc = "< are the compressions sorted by name?"]
    pub comprsnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the branching rules sorted by priority?"]
    pub branchrulessorted: ::std::os::raw::c_uint,
    #[doc = "< are the branching rules sorted by name?"]
    pub branchrulesnamesorted: ::std::os::raw::c_uint,
    #[doc = "< are the IIS rules sorted by priority"]
    pub iisfinderssorted: ::std::os::raw::c_uint,
    #[doc = "< are the tables sorted by position?"]
    pub tablessorted: ::std::os::raw::c_uint,
    #[doc = "< are the expression handlers sorted by name?"]
    pub exprhdlrssorted: ::std::os::raw::c_uint,
    #[doc = "< are the NLPIs sorted by priority?"]
    pub nlpissorted: ::std::os::raw::c_uint,
    #[doc = "< are the Benders' algorithms sorted by activity and priority?"]
    pub benderssorted: ::std::os::raw::c_uint,
    #[doc = "< are the Benders' algorithms sorted by name?"]
    pub bendersnamesorted: ::std::os::raw::c_uint,
    #[doc = "< marks whether any of the limit parameters was changed"]
    pub limitchanged: ::std::os::raw::c_uint,
    #[doc = "< marks whether the sub-SCIPs have been deactivated"]
    pub subscipsoff: ::std::os::raw::c_uint,
    #[doc = "< branching score function ('s'um, 'p'roduct, 'q'uotient)"]
    pub branch_scorefunc: ::std::os::raw::c_char,
    #[doc = "< child node to be regarded first during strong branching (only with propagation): 'u'p child, 'd'own child, 'h'istory-based, or 'a'utomatic"]
    pub branch_firstsbchild: ::std::os::raw::c_char,
    #[doc = "< branching score factor to weigh downward and upward gain prediction\n   in sum score function"]
    pub branch_scorefac: f64,
    #[doc = "< should branching on binary variables be preferred?"]
    pub branch_preferbinary: ::std::os::raw::c_uint,
    #[doc = "< minimal fractional distance of branching point to a continuous variable' bounds; a value of 0.5 leads to branching always in the middle of a bounded domain"]
    pub branch_clamp: f64,
    #[doc = "< fraction by which to move branching point of a continuous variable towards the middle of the domain; a value of 1.0 leads to branching always in the middle of the domain"]
    pub branch_midpull: f64,
    #[doc = "< multiply midpull by relative domain width if the latter is below this value"]
    pub branch_midpullreldomtrig: f64,
    #[doc = "< strategy for normalizing LP gain when updating pseudo costs of continuous variables"]
    pub branch_lpgainnorm: ::std::os::raw::c_char,
    #[doc = "< whether to delay pseudo costs updates for continuous variables to after separation"]
    pub branch_delaypscost: ::std::os::raw::c_uint,
    #[doc = "< should pseudo costs be updated also in diving and probing mode?"]
    pub branch_divingpscost: ::std::os::raw::c_uint,
    #[doc = "< should ancestral pseudo costs be updated?"]
    pub branch_collectancpscost: ::std::os::raw::c_uint,
    #[doc = "< should all strong branching children be regarded even if\n   one is detected to be infeasible? (only with propagation)"]
    pub branch_forceall: ::std::os::raw::c_uint,
    #[doc = "< should LP solutions during strong branching with propagation be checked for feasibility?"]
    pub branch_checksbsol: ::std::os::raw::c_uint,
    #[doc = "< should LP solutions during strong branching with propagation be rounded? (only when checksbsol=TRUE)"]
    pub branch_roundsbsol: ::std::os::raw::c_uint,
    #[doc = "< score adjustment near zero by \\b adding epsilon (TRUE) or using maximum (FALSE)"]
    pub branch_sumadjustscore: ::std::os::raw::c_uint,
    #[doc = "< maximal fraction of variables involved in a conflict constraint"]
    pub conf_maxvarsfac: f64,
    #[doc = "< maximal fraction of variables involved in a resolution conflict constraint"]
    pub conf_maxvarsfracres: f64,
    #[doc = "< minimal absolute maximum of variables involved in a conflict constraint"]
    pub conf_minmaxvars: ::std::os::raw::c_int,
    #[doc = "< maximal number of LP resolving loops during conflict analysis\n   (-1: no limit)"]
    pub conf_maxlploops: ::std::os::raw::c_int,
    #[doc = "< maximal number of LP iterations in each LP resolving loop\n   (-1: no limit)"]
    pub conf_lpiterations: ::std::os::raw::c_int,
    #[doc = "< number of depth levels up to which first UIP's are used in conflict\n   analysis (-1: use All-FirstUIP rule)"]
    pub conf_fuiplevels: ::std::os::raw::c_int,
    #[doc = "< number of depth levels up to which first UIP's are used in resolution\n   conflict analysis (-1: use All-FirstUIP rule)"]
    pub conf_resfuiplevels: ::std::os::raw::c_int,
    #[doc = "< maximal number of intermediate conflict constraints generated in conflict\n   graph (-1: use every intermediate constraint)"]
    pub conf_interconss: ::std::os::raw::c_int,
    #[doc = "< maximal number of conflict constraints accepted at an infeasible node\n   (-1: use all generated conflict constraints)"]
    pub conf_maxconss: ::std::os::raw::c_int,
    #[doc = "< maximal size of conflict store"]
    pub conf_maxstoresize: ::std::os::raw::c_int,
    #[doc = "< number of depth levels up to which UIP reconvergence constraints are\n   generated (-1: generate reconvergence constraints in all depth levels)"]
    pub conf_reconvlevels: ::std::os::raw::c_int,
    #[doc = "< should conflict analysis be enabled?"]
    pub conf_enable: ::std::os::raw::c_uint,
    #[doc = "< should conflicts related to an old cutoff bound be removed?"]
    pub conf_cleanbnddepend: ::std::os::raw::c_uint,
    #[doc = "< should propagation conflict analysis be used? (uses conflict graph only)"]
    pub conf_useprop: ::std::os::raw::c_uint,
    #[doc = "< should generalized resolution conflict analysis be used?"]
    pub conf_usegenres: ::std::os::raw::c_uint,
    #[doc = "< should infeasible LP conflict analysis be used?\n   ('o'ff, 'c'onflict graph, 'd'ual ray, 'b'oth conflict graph and dual ray)"]
    pub conf_useinflp: ::std::os::raw::c_char,
    #[doc = "< should bound exceeding LP conflict analysis be used?\n   ('o'ff, 'c'onflict graph, 'd'ual ray, 'b'oth conflict graph and dual ray)"]
    pub conf_useboundlp: ::std::os::raw::c_char,
    #[doc = "< should infeasible/bound exceeding strong branching conflict analysis be\n   used?"]
    pub conf_usesb: ::std::os::raw::c_uint,
    #[doc = "< which reduction should be used?\n ('o'ff, 'm'ir)"]
    pub conf_reduction: ::std::os::raw::c_char,
    #[doc = "< should apply the mixed binary reduction?"]
    pub conf_mbreduction: ::std::os::raw::c_uint,
    #[doc = "< should pseudo solution conflict analysis be used?"]
    pub conf_usepseudo: ::std::os::raw::c_uint,
    #[doc = "< prefer infeasibility proof to boundexceeding proof"]
    pub conf_prefinfproof: ::std::os::raw::c_uint,
    #[doc = "< should binary conflicts be preferred?"]
    pub conf_preferbinary: ::std::os::raw::c_uint,
    #[doc = "< should conflict constraints be generated that are only valid locally?"]
    pub conf_allowlocal: ::std::os::raw::c_uint,
    #[doc = "< should conflict constraints be attached only to the local subtree where\n   they can be useful?"]
    pub conf_settlelocal: ::std::os::raw::c_uint,
    #[doc = "< should earlier nodes be repropagated in order to replace branching\n   decisions by deductions?"]
    pub conf_repropagate: ::std::os::raw::c_uint,
    #[doc = "< should constraints be kept for repropagation even if they are too long?"]
    pub conf_keepreprop: ::std::os::raw::c_uint,
    #[doc = "< should the conflict constraints be separated?"]
    pub conf_separate: ::std::os::raw::c_uint,
    #[doc = "< should the conflict constraints be subject to aging?"]
    pub conf_dynamic: ::std::os::raw::c_uint,
    #[doc = "< should the conflict's relaxations be subject to LP aging and cleanup?"]
    pub conf_removable: ::std::os::raw::c_uint,
    #[doc = "< score factor for depth level in bound relaxation heuristic"]
    pub conf_depthscorefac: f64,
    #[doc = "< score factor for contribution to infeasibility proof in bound relaxation heuristic"]
    pub conf_proofscorefac: f64,
    #[doc = "< score factor for number of up locks in bound relaxation heuristic"]
    pub conf_uplockscorefac: f64,
    #[doc = "< score factor for number of down locks in bound relaxation heuristic"]
    pub conf_downlockscorefac: f64,
    #[doc = "< factor to decrease importance of variables' earlier conflict scores"]
    pub conf_scorefac: f64,
    #[doc = "< number of successful conflict analysis calls that trigger a restart\n   (0: disable conflict restarts)"]
    pub conf_restartnum: ::std::os::raw::c_int,
    #[doc = "< factor to increase restartnum with after each restart"]
    pub conf_restartfac: f64,
    #[doc = "< should relaxed bounds be ignored?"]
    pub conf_ignorerelaxedbd: ::std::os::raw::c_uint,
    #[doc = "< maximal number of variables to try to detect global bound\n   implications and shorten the whole conflict set (0:\n   disabled )"]
    pub conf_maxvarsdetectimpliedbounds: ::std::os::raw::c_int,
    #[doc = "< try to shorten the whole conflict set or terminate early\n   (depending on the 'maxvarsdetectimpliedbounds' parameter)"]
    pub conf_fullshortenconflict: ::std::os::raw::c_uint,
    #[doc = "< the weight the VSIDS score is weight by updating the VSIDS for a\n   variable if it is part of a conflict"]
    pub conf_conflictweight: f64,
    #[doc = "< the weight the VSIDS score is weight by updating the VSIDS for a\n   variable if it is part of a conflict graph"]
    pub conf_conflictgraphweight: f64,
    #[doc = "< weight of the size of a conflict used in score calculation"]
    pub conf_weightsize: f64,
    #[doc = "< weight of the prepropagtion depth of a conflict used in score calculation"]
    pub conf_weightrepropdepth: f64,
    #[doc = "< weight of the valid depth of a conflict used in score calculation"]
    pub conf_weightvaliddepth: f64,
    #[doc = "< separate valid inequalities from dualray proofs"]
    pub conf_sepaaltproofs: ::std::os::raw::c_uint,
    #[doc = "< minimal improvement of primal bound to remove conflicts depending on\n   a previous incumbent."]
    pub conf_minimprove: f64,
    #[doc = "< use local rows to construct infeasibility proofs"]
    pub conf_uselocalrows: ::std::os::raw::c_uint,
    #[doc = "< largest allowed quotient of max, min coefficient in a conflict\n   constraint generated by generalized resolution."]
    pub conf_maxcoefquot: f64,
    #[doc = "< should we fix unresolvable bound changes and continue?"]
    pub conf_fixandcontinue: ::std::os::raw::c_uint,
    #[doc = "< maximum age an unnecessary constraint can reach before it is deleted\n   (0: dynamic, -1: disable aging)"]
    pub cons_agelimit: ::std::os::raw::c_int,
    #[doc = "< age of a constraint after which it is marked obsolete\n   (0: dynamic, -1: disable obsoletion)"]
    pub cons_obsoleteage: ::std::os::raw::c_int,
    #[doc = "< should enforcement of pseudo solution be disabled?"]
    pub cons_disableenfops: ::std::os::raw::c_uint,
    #[doc = "< verbosity level of output"]
    pub disp_verblevel: SCIP_VERBLEVEL,
    #[doc = "< maximal number of characters in a node information line"]
    pub disp_width: ::std::os::raw::c_int,
    #[doc = "< frequency for displaying node information lines"]
    pub disp_freq: ::std::os::raw::c_int,
    #[doc = "< frequency for displaying header lines (every n'th node information line)"]
    pub disp_headerfreq: ::std::os::raw::c_int,
    #[doc = "< should the LP solver display status messages?"]
    pub disp_lpinfo: ::std::os::raw::c_uint,
    #[doc = "< display all violations of the best solution after the solving process finished?"]
    pub disp_allviols: ::std::os::raw::c_uint,
    #[doc = "< should the relevant statistics be displayed at the end of solving?"]
    pub disp_relevantstats: ::std::os::raw::c_uint,
    #[doc = "< should setting of common subscip parameters include the activation of the UCT node selector?"]
    pub heur_useuctsubscip: ::std::os::raw::c_uint,
    #[doc = "< should statistics be collected for variable domain value pairs?"]
    pub history_valuebased: ::std::os::raw::c_uint,
    #[doc = "< should variable histories be merged from sub-SCIPs whenever possible?"]
    pub history_allowmerge: ::std::os::raw::c_uint,
    #[doc = "< should variable histories be transferred to initialize SCIP copies?"]
    pub history_allowtransfer: ::std::os::raw::c_uint,
    #[doc = "< should the resultant infeasible set be irreducible, i.e., an IIS not an IS"]
    pub iisfinder_irreducible: ::std::os::raw::c_uint,
    #[doc = "< should bounds of the problem be considered for removal"]
    pub iisfinder_removebounds: ::std::os::raw::c_uint,
    #[doc = "< should the IIS finders be run silently"]
    pub iisfinder_silent: ::std::os::raw::c_uint,
    #[doc = "< should the IIS search stop after a single IIS finder is run (excluding post processing)"]
    pub iisfinder_stopafterone: ::std::os::raw::c_uint,
    #[doc = "< should vars that do not feature in any constraints be removed at the end of the IIS process"]
    pub iisfinder_removeunusedvars: ::std::os::raw::c_uint,
    #[doc = "< maximal time in seconds for all IIS finders to run"]
    pub iisfinder_time: f64,
    #[doc = "< maximal number of nodes to process for all IIS finders (-1: no limit)"]
    pub iisfinder_nodes: ::std::os::raw::c_longlong,
    #[doc = "< maximal time in seconds to run"]
    pub limit_time: f64,
    #[doc = "< maximal memory usage in MB"]
    pub limit_memory: f64,
    #[doc = "< solving stops, if the given gap is reached"]
    pub limit_gap: f64,
    #[doc = "< solving stops, if the absolute difference between primal and dual bound\n   reaches this value"]
    pub limit_absgap: f64,
    #[doc = "< solving stops, if primal bound is at least as good as given value"]
    pub limit_primal: f64,
    #[doc = "< solving stops, if dual bound is at least as good as given value"]
    pub limit_dual: f64,
    #[doc = "< maximal number of nodes to process (-1: no limit)"]
    pub limit_nodes: ::std::os::raw::c_longlong,
    #[doc = "< maximal number of total nodes (incl. restarts) to process (-1: no limit)"]
    pub limit_totalnodes: ::std::os::raw::c_longlong,
    #[doc = "< solving stops, if the given number of nodes was processed since the\n   last improvement of the primal solution value (-1: no limit)"]
    pub limit_stallnodes: ::std::os::raw::c_longlong,
    #[doc = "< solving stops, if the given number of solutions were found; this limit is first checked in presolving (-1: no limit)"]
    pub limit_solutions: ::std::os::raw::c_int,
    #[doc = "< solving stops, if the given number of solution improvements were found\n   (-1: no limit)"]
    pub limit_bestsol: ::std::os::raw::c_int,
    #[doc = "< maximal number of solutions to store in the solution storage"]
    pub limit_maxsol: ::std::os::raw::c_int,
    #[doc = "< maximal number of solutions candidates to store in the solution storage of the original problem"]
    pub limit_maxorigsol: ::std::os::raw::c_int,
    #[doc = "< solving stops, if the given number of restarts was triggered (-1: no limit)"]
    pub limit_restarts: ::std::os::raw::c_int,
    #[doc = "< nodes to trigger automatic restart"]
    pub limit_autorestartnodes: ::std::os::raw::c_int,
    #[doc = "< is the time limit finite"]
    pub istimelimitfinite: ::std::os::raw::c_uint,
    #[doc = "< frequency for solving LP at the nodes (-1: never; 0: only root LP)"]
    pub lp_solvefreq: ::std::os::raw::c_int,
    #[doc = "< iteration limit for each single LP solve; -1: no limit"]
    pub lp_iterlim: ::std::os::raw::c_longlong,
    #[doc = "< iteration limit for initial root LP solve; -1: no limit"]
    pub lp_rootiterlim: ::std::os::raw::c_longlong,
    #[doc = "< maximal depth for solving LP at the nodes (-1: no depth limit)"]
    pub lp_solvedepth: ::std::os::raw::c_int,
    #[doc = "< minimal depth for solving LP at the nodes"]
    pub lp_minsolvedepth: ::std::os::raw::c_int,
    #[doc = "< LP algorithm for solving initial LP relaxations ('s'implex, 'b'arrier,\n   barrier with 'c'rossover)"]
    pub lp_initalgorithm: ::std::os::raw::c_char,
    #[doc = "< LP algorithm for resolving LP relaxations if a starting basis exists\n   ('s'implex, 'b'arrier, barrier with 'c'rossover)"]
    pub lp_resolvealgorithm: ::std::os::raw::c_char,
    #[doc = "< LP pricing strategy ('a'uto, 'f'ull pricing, 's'teepest edge pricing,\n   'q'uickstart steepest edge pricing, 'd'evex pricing)"]
    pub lp_pricing: ::std::os::raw::c_char,
    #[doc = "< should lp state be cleared at the end of probing mode when LP\n   was initially unsolved, e.g., when called right after presolving?"]
    pub lp_clearinitialprobinglp: ::std::os::raw::c_uint,
    #[doc = "< should the LP be resolved to restore the state at start of diving (if\n   FALSE we buffer the solution values)?"]
    pub lp_resolverestore: ::std::os::raw::c_uint,
    #[doc = "< should the buffers for storing LP solution values during diving be\n   freed at end of diving?"]
    pub lp_freesolvalbuffers: ::std::os::raw::c_uint,
    #[doc = "< maximum age a column can reach before it is deleted from the SCIP_LP\n   (-1: don't delete columns due to aging)"]
    pub lp_colagelimit: ::std::os::raw::c_int,
    #[doc = "< maximum age a row can reach before it is deleted from the LP\n   (-1: don't delete rows due to aging)"]
    pub lp_rowagelimit: ::std::os::raw::c_int,
    #[doc = "< should new non-basic columns be removed after LP solving?"]
    pub lp_cleanupcols: ::std::os::raw::c_uint,
    #[doc = "< should new non-basic columns be removed after root LP solving?"]
    pub lp_cleanupcolsroot: ::std::os::raw::c_uint,
    #[doc = "< should new basic rows be removed after LP solving?"]
    pub lp_cleanuprows: ::std::os::raw::c_uint,
    #[doc = "< should new basic rows be removed after root LP solving?"]
    pub lp_cleanuprowsroot: ::std::os::raw::c_uint,
    #[doc = "< should LP solver's return status be checked for stability?"]
    pub lp_checkstability: ::std::os::raw::c_uint,
    #[doc = "< maximum condition number of LP basis counted as stable (-1.0: no check)"]
    pub lp_conditionlimit: f64,
    #[doc = "< minimal Markowitz threshold to control sparsity/stability in LU factorization"]
    pub lp_markowitz: f64,
    #[doc = "< should LP solutions be checked for primal feasibility, resolving LP when numerical troubles occur?"]
    pub lp_checkprimfeas: ::std::os::raw::c_uint,
    #[doc = "< should LP solutions be checked for dual feasibility, resolving LP when numerical troubles occur?"]
    pub lp_checkdualfeas: ::std::os::raw::c_uint,
    #[doc = "< should infeasibility proofs from the LP be checked?"]
    pub lp_checkfarkas: ::std::os::raw::c_uint,
    #[doc = "< which FASTMIP setting of LP solver should be used? 0: off, 1: medium, 2: full"]
    pub lp_fastmip: ::std::os::raw::c_int,
    #[doc = "< LP scaling (0: none, 1: normal, 2: aggressive)"]
    pub lp_scaling: ::std::os::raw::c_int,
    #[doc = "< should presolving of LP solver be used?"]
    pub lp_presolving: ::std::os::raw::c_uint,
    #[doc = "< should the lexicographic dual algorithm be used?"]
    pub lp_lexdualalgo: ::std::os::raw::c_uint,
    #[doc = "< should the lexicographic dual algorithm be applied only at the root node"]
    pub lp_lexdualrootonly: ::std::os::raw::c_uint,
    #[doc = "< maximum number of rounds in the lexicographic dual algorithm"]
    pub lp_lexdualmaxrounds: ::std::os::raw::c_int,
    #[doc = "< choose fractional basic variables in lexicographic dual algorithm"]
    pub lp_lexdualbasic: ::std::os::raw::c_uint,
    #[doc = "< turn on the lex dual algorithm only when stalling?"]
    pub lp_lexdualstalling: ::std::os::raw::c_uint,
    #[doc = "< disable the cutoff bound in the LP solver? (0: enabled, 1: disabled, 2: auto)"]
    pub lp_disablecutoff: ::std::os::raw::c_int,
    #[doc = "< simplex algorithm shall use row representation of the basis\n   if number of rows divided by number of columns exceeds this value"]
    pub lp_rowrepswitch: f64,
    #[doc = "< number of threads used for solving the LP (0: automatic)"]
    pub lp_threads: ::std::os::raw::c_int,
    #[doc = "< factor of average LP iterations that is used as LP iteration limit\n   for LP resolve (-1: unlimited)"]
    pub lp_resolveiterfac: f64,
    #[doc = "< minimum number of iterations that are allowed for LP resolve"]
    pub lp_resolveitermin: ::std::os::raw::c_int,
    #[doc = "< LP solution polishing method (0: disabled, 1: only root, 2: always, 3: auto)"]
    pub lp_solutionpolishing: ::std::os::raw::c_int,
    #[doc = "< LP refactorization interval (0: automatic)"]
    pub lp_refactorinterval: ::std::os::raw::c_int,
    #[doc = "< should the dual solution always be collected for LP solutions."]
    pub lp_alwaysgetduals: ::std::os::raw::c_uint,
    #[doc = "< should the NLP be disabled even if a constraint handler enabled it?"]
    pub nlp_disable: ::std::os::raw::c_uint,
    #[doc = "< name of NLP solver to use"]
    pub nlp_solver: *mut ::std::os::raw::c_char,
    #[doc = "< fraction of maximal memory usage resulting in switch to memory saving mode"]
    pub mem_savefac: f64,
    #[doc = "< memory growing factor for dynamically allocated arrays"]
    pub mem_arraygrowfac: f64,
    #[doc = "< memory growing factor for tree array"]
    pub mem_treegrowfac: f64,
    #[doc = "< memory growing factor for path array"]
    pub mem_pathgrowfac: f64,
    #[doc = "< initial size of dynamically allocated arrays"]
    pub mem_arraygrowinit: ::std::os::raw::c_int,
    #[doc = "< initial size of tree array"]
    pub mem_treegrowinit: ::std::os::raw::c_int,
    #[doc = "< initial size of path array"]
    pub mem_pathgrowinit: ::std::os::raw::c_int,
    #[doc = "< should the CTRL-C interrupt be caught by SCIP?"]
    pub misc_catchctrlc: ::std::os::raw::c_uint,
    #[doc = "< should a hashtable be used to map from variable names to variables?"]
    pub misc_usevartable: ::std::os::raw::c_uint,
    #[doc = "< should a hashtable be used to map from constraint names to constraints?"]
    pub misc_useconstable: ::std::os::raw::c_uint,
    #[doc = "< should smaller hashtables be used? yields better performance for small problems with about 100 variables"]
    pub misc_usesmalltables: ::std::os::raw::c_uint,
    #[doc = "< should the statistics be reset if the transformed problem is freed\n   otherwise the statistics get reset after original problem is freed (in\n   case of bender decomposition this parameter should be set to FALSE and\n   therefore can be used to collect statistics over all runs)"]
    pub misc_resetstat: ::std::os::raw::c_uint,
    #[doc = "< should only solutions be checked which improve the primal bound"]
    pub misc_improvingsols: ::std::os::raw::c_uint,
    #[doc = "< should the reason be printed if a given start solution is infeasible?"]
    pub misc_printreason: ::std::os::raw::c_uint,
    #[doc = "< should the usage of external memory be estimated?"]
    pub misc_estimexternmem: ::std::os::raw::c_uint,
    #[doc = "< try to avoid running into memory limit by restricting plugins like heuristics?"]
    pub misc_avoidmemout: ::std::os::raw::c_uint,
    #[doc = "< should SCIP try to transfer original solutions to the transformed space (after presolving)?"]
    pub misc_transorigsols: ::std::os::raw::c_uint,
    #[doc = "< should SCIP try to transfer transformed solutions to the original space (after solving)?"]
    pub misc_transsolsorig: ::std::os::raw::c_uint,
    #[doc = "< should SCIP calculate the primal dual integral value which may require\n   a large number of additional clock calls (and decrease the performance)?"]
    pub misc_calcintegral: ::std::os::raw::c_uint,
    #[doc = "< should SCIP try to remove infinite fixings from solutions copied to the solution store?"]
    pub misc_finitesolstore: ::std::os::raw::c_uint,
    #[doc = "< should the best solution be transformed to the orignal space and be output in command line run?"]
    pub misc_outputorigsol: ::std::os::raw::c_uint,
    #[doc = "< should strong dual reductions be allowed in propagation and presolving?"]
    pub misc_allowstrongdualreds: ::std::os::raw::c_uint,
    #[doc = "< should weak dual reductions be allowed in propagation and presolving?"]
    pub misc_allowweakdualreds: ::std::os::raw::c_uint,
    #[doc = "< objective value for reference purposes"]
    pub misc_referencevalue: f64,
    #[doc = "< bitset describing used symmetry handling technique (0: off; 1: polyhedral (orbitopes and/or symresacks);\n   2: orbital fixing; 3: orbitopes and orbital fixing; 4: Schreier Sims cuts; 5: Schreier Sims cuts and\n   symresacks)"]
    pub misc_usesymmetry: ::std::os::raw::c_int,
    #[doc = "< path to a debug solution"]
    pub misc_debugsol: *mut ::std::os::raw::c_char,
    #[doc = "< should the objective function be scaled?"]
    pub misc_scaleobj: ::std::os::raw::c_uint,
    #[doc = "< should detailed statistics for diving heuristics be shown?"]
    pub misc_showdivingstats: ::std::os::raw::c_uint,
    #[doc = "< global shift of all random seeds in the plugins, this will have no impact on the permutation and LP seeds"]
    pub random_randomseedshift: ::std::os::raw::c_int,
    #[doc = "< multiplier for global shift random_randomseedshift"]
    pub random_randomseedshiftmultiplier: ::std::os::raw::c_int,
    #[doc = "< seed value for permuting the problem after reading/transformation\n   (0: no permutation)"]
    pub random_permutationseed: ::std::os::raw::c_int,
    #[doc = "< random seed for LP solver, e.g. for perturbations in the simplex (0: LP default)"]
    pub random_randomseed: ::std::os::raw::c_int,
    #[doc = "< should order of constraints be permuted (depends on permutationseed)?"]
    pub random_permuteconss: ::std::os::raw::c_uint,
    #[doc = "< should order of variables be permuted (depends on permutationseed)?"]
    pub random_permutevars: ::std::os::raw::c_uint,
    #[doc = "< child selection rule ('d'own, 'u'p, 'p'seudo costs, 'i'nference, 'l'p value,\n   'r'oot LP value difference, 'h'brid inference/root LP value difference)"]
    pub nodesel_childsel: ::std::os::raw::c_char,
    #[doc = "< values larger than this are considered infinity"]
    pub num_infinity: f64,
    #[doc = "< absolute values smaller than this are considered zero"]
    pub num_epsilon: f64,
    #[doc = "< absolute values of sums smaller than this are considered zero"]
    pub num_sumepsilon: f64,
    #[doc = "< feasibility tolerance for constraints"]
    pub num_feastol: f64,
    #[doc = "< factor to change the feasibility tolerance when testing the best\n   solution for feasibility (after solving process)"]
    pub num_checkfeastolfac: f64,
    #[doc = "< factor w.r.t. primal feasibility tolerance that determines default (and maximal) primal feasibility tolerance of LP solver (user parameter, see also num_relaxfeastol)"]
    pub num_lpfeastolfactor: f64,
    #[doc = "< feasibility tolerance for reduced costs"]
    pub num_dualfeastol: f64,
    #[doc = "< convergence tolerance used in barrier algorithm"]
    pub num_barrierconvtol: f64,
    #[doc = "< minimal improve for strengthening bounds"]
    pub num_boundstreps: f64,
    #[doc = "< minimal variable distance value to use for pseudo cost updates"]
    pub num_pseudocosteps: f64,
    #[doc = "< minimal objective distance value to use for pseudo cost updates"]
    pub num_pseudocostdelta: f64,
    #[doc = "< minimal decrease factor that causes the recomputation of a value\n   (e.g., pseudo objective) instead of an update"]
    pub num_recompfac: f64,
    #[doc = "< values larger than this are considered huge and should be handled\n   separately (e.g., in activity computation)"]
    pub num_hugeval: f64,
    #[doc = "< primal feasibility tolerance for relaxations (set by core or plugins, not a parameter)"]
    pub num_relaxfeastol: f64,
    #[doc = "< abort presolve, if l.t. this frac of the problem was changed in last round"]
    pub presol_abortfac: f64,
    #[doc = "< maximal number of presolving rounds (-1: unlimited)"]
    pub presol_maxrounds: ::std::os::raw::c_int,
    #[doc = "< maximal number of restarts (-1: unlimited)"]
    pub presol_maxrestarts: ::std::os::raw::c_int,
    #[doc = "< limit on number of entries in clique table relative to number of problem nonzeros"]
    pub presol_clqtablefac: f64,
    #[doc = "< fraction of integer variables that were fixed in the root node\n   triggering a restart with preprocessing after root node evaluation"]
    pub presol_restartfac: f64,
    #[doc = "< fraction of integer variables that were fixed in the root node triggering an\n   immediate restart with preprocessing"]
    pub presol_immrestartfac: f64,
    #[doc = "< fraction of integer variables that were globally fixed during the\n   solving process triggering a restart with preprocessing"]
    pub presol_subrestartfac: f64,
    #[doc = "< minimal fraction of integer variables removed after restart to allow for\n   an additional restart"]
    pub presol_restartminred: f64,
    #[doc = "< should multi-aggregation of variables be forbidden?"]
    pub presol_donotmultaggr: ::std::os::raw::c_uint,
    #[doc = "< should aggregation of variables be forbidden?"]
    pub presol_donotaggr: ::std::os::raw::c_uint,
    #[doc = "< pricing is aborted, if fac * maxpricevars pricing candidates were found"]
    pub price_abortfac: f64,
    #[doc = "< maximal number of variables priced in per pricing round"]
    pub price_maxvars: ::std::os::raw::c_int,
    #[doc = "< maximal number of priced variables at the root node"]
    pub price_maxvarsroot: ::std::os::raw::c_int,
    #[doc = "< should variables created at the current node be deleted when the node is solved\n   in case they are not present in the LP anymore?"]
    pub price_delvars: ::std::os::raw::c_uint,
    #[doc = "< should variables created at the root node be deleted when the root is solved\n   in case they are not present in the LP anymore?"]
    pub price_delvarsroot: ::std::os::raw::c_uint,
    #[doc = "< should the variables be labeled for the application of Benders'\n   decomposition"]
    pub decomp_benderslabels: ::std::os::raw::c_uint,
    #[doc = "< if a decomposition exists, should Benders' decomposition be applied"]
    pub decomp_applybenders: ::std::os::raw::c_uint,
    #[doc = "< maximum number of edges in block graph computation (-1: no limit, 0: disable block graph computation)"]
    pub decomp_maxgraphedge: ::std::os::raw::c_int,
    #[doc = "< disable expensive measures"]
    pub decomp_disablemeasures: ::std::os::raw::c_uint,
    #[doc = "< the tolerance for checking optimality in Benders' decomposition"]
    pub benders_soltol: f64,
    #[doc = "< should cuts be generated from the solution to the LP relaxation?"]
    pub benders_cutlpsol: ::std::os::raw::c_uint,
    #[doc = "< should Benders' decomposition be copied for sub-SCIPs?"]
    pub benders_copybenders: ::std::os::raw::c_uint,
    #[doc = "< maximal number of propagation rounds per node (-1: unlimited)"]
    pub prop_maxrounds: ::std::os::raw::c_int,
    #[doc = "< maximal number of propagation rounds in the root node (-1: unlimited)"]
    pub prop_maxroundsroot: ::std::os::raw::c_int,
    #[doc = "< should propagation be aborted immediately? setting this to FALSE could\n   help conflict analysis to produce more conflict constraints"]
    pub prop_abortoncutoff: ::std::os::raw::c_uint,
    #[doc = "< similarity of two objective functions to reuse stored solutions."]
    pub reopt_objsimsol: f64,
    #[doc = "< similarity of two sequential objective function to disable solving the\n   root LP."]
    pub reopt_objsimrootlp: f64,
    #[doc = "< minimum similarity for using reoptimization of the search tree."]
    pub reopt_objsimdelay: f64,
    pub reopt_varorderinterdiction: ::std::os::raw::c_char,
    #[doc = "< force a restart if the last n optimal solutions were found by\n   heuristic reoptsols"]
    pub reopt_forceheurrestart: ::std::os::raw::c_int,
    #[doc = "< maximal age of cuts to use them in reoptimization"]
    pub reopt_maxcutage: ::std::os::raw::c_int,
    #[doc = "< maximal number of bound changes between two stored nodes on one path"]
    pub reopt_maxdiffofnodes: ::std::os::raw::c_int,
    #[doc = "< maximal number of saved nodes"]
    pub reopt_maxsavednodes: ::std::os::raw::c_int,
    #[doc = "< strategy for solving the LP at nodes from reoptimization"]
    pub reopt_solvelp: ::std::os::raw::c_int,
    #[doc = "< maximal number of bound changes at node to skip solving the LP"]
    pub reopt_solvelpdiff: ::std::os::raw::c_int,
    #[doc = "< number of best solutions which should be saved for the following runs.\n   (-1: save all)"]
    pub reopt_savesols: ::std::os::raw::c_int,
    #[doc = "< time limit over all reoptimization rounds?"]
    pub reopt_commontimelimit: ::std::os::raw::c_uint,
    #[doc = "< enable reoptimization"]
    pub reopt_enable: ::std::os::raw::c_uint,
    #[doc = "< delete stored nodes which were not reoptimized"]
    pub reopt_reducetofrontier: ::std::os::raw::c_uint,
    #[doc = "< save constraint and propagator propagations"]
    pub reopt_saveprop: ::std::os::raw::c_uint,
    #[doc = "< try to fix variables before reoptimizing by probing like strong\n   branching"]
    pub reopt_sbinit: ::std::os::raw::c_uint,
    #[doc = "< replace branched inner nodes by their child nodes, if the number of\n   bound changes is not to large"]
    pub reopt_shrinkinner: ::std::os::raw::c_uint,
    #[doc = "< save global constraints to separate infeasible subtrees"]
    pub reopt_sepaglbinfsubtrees: ::std::os::raw::c_uint,
    #[doc = "< separate only the best solution, i.e., for constrained shortest path"]
    pub reopt_sepabestsol: ::std::os::raw::c_uint,
    #[doc = "< use variable history of the previous solve if the objective function\n   has changed only slightly"]
    pub reopt_storevarhistory: ::std::os::raw::c_uint,
    #[doc = "< reuse pseudo costs if the objective function changed only slightly"]
    pub reopt_usepscost: ::std::os::raw::c_uint,
    #[doc = "< reoptimize cuts found at the root node"]
    pub reopt_usecuts: ::std::os::raw::c_uint,
    #[doc = "< use constraints to reconstruct the subtree pruned be dual reduction\n   when reactivating the node"]
    pub reopt_usesplitcons: ::std::os::raw::c_uint,
    #[doc = "< maximal relative distance from current node's dual bound to primal bound\n   compared to best node's dual bound for applying separation\n   (0.0: only on current best node, 1.0: on all nodes)"]
    pub sepa_maxbounddist: f64,
    #[doc = "< maximal relative distance from current node's dual bound to primal bound\n   compared to best node's dual bound for applying local separation\n   (0.0: only on current best node, 1.0: on all nodes)"]
    pub sepa_maxlocalbounddist: f64,
    #[doc = "< maximal ratio between coefficients in strongcg, cmir, and flowcover cuts"]
    pub sepa_maxcoefratio: f64,
    #[doc = "< maximal ratio between coefficients (as factor of 1/feastol) to ensure in rowprep cleanup"]
    pub sepa_maxcoefratiofacrowprep: f64,
    #[doc = "< minimal efficacy for a cut to enter the LP"]
    pub sepa_minefficacy: f64,
    #[doc = "< minimal efficacy for a cut to enter the LP in the root node"]
    pub sepa_minefficacyroot: f64,
    #[doc = "< minimal orthogonality for a cut to enter the LP"]
    pub sepa_minortho: f64,
    #[doc = "< minimal orthogonality for a cut to enter the LP in the root node"]
    pub sepa_minorthoroot: f64,
    #[doc = "< minimum cut activity quotient to convert cuts into constraints\n   during a restart (0.0: all cuts are converted)"]
    pub sepa_minactivityquot: f64,
    #[doc = "< function used for calc. scalar prod. in orthogonality test ('e'uclidean, 'd'iscrete)"]
    pub sepa_orthofunc: ::std::os::raw::c_char,
    #[doc = "< row norm to use for efficacy calculation ('e'uclidean, 'm'aximum, 's'um,\n   'd'iscrete)"]
    pub sepa_efficacynorm: ::std::os::raw::c_char,
    #[doc = "< cut selection during restart ('a'ge, activity 'q'uotient)"]
    pub sepa_cutselrestart: ::std::os::raw::c_char,
    #[doc = "< cut selection for sub SCIPs  ('a'ge, activity 'q'uotient)"]
    pub sepa_cutselsubscip: ::std::os::raw::c_char,
    #[doc = "< should cutpool separate only cuts with high relative efficacy?"]
    pub sepa_filtercutpoolrel: ::std::os::raw::c_uint,
    #[doc = "< maximal number of runs for which separation is enabled (-1: unlimited)"]
    pub sepa_maxruns: ::std::os::raw::c_int,
    #[doc = "< maximal number of separation rounds per node (-1: unlimited)"]
    pub sepa_maxrounds: ::std::os::raw::c_int,
    #[doc = "< maximal number of separation rounds in the root node (-1: unlimited)"]
    pub sepa_maxroundsroot: ::std::os::raw::c_int,
    #[doc = "< maximal number of separation rounds in the root node of a subsequent run (-1: unlimited)"]
    pub sepa_maxroundsrootsubrun: ::std::os::raw::c_int,
    #[doc = "< maximal additional number of separation rounds in subsequent price-and-cut\n   loops (-1: no additional restriction)"]
    pub sepa_maxaddrounds: ::std::os::raw::c_int,
    #[doc = "< maximal number of consecutive separation rounds without objective\n   or integrality improvement (-1: no additional restriction)"]
    pub sepa_maxstallrounds: ::std::os::raw::c_int,
    #[doc = "< maximal number of consecutive separation rounds without objective\n   or integrality improvement (-1: no additional restriction)"]
    pub sepa_maxstallroundsroot: ::std::os::raw::c_int,
    #[doc = "< factor w.r.t. maxcuts for maximal number of cuts generated per\n separation round (-1.0: no limit, >= 0.0: valid finite limit)"]
    pub sepa_maxcutsgenfactor: f64,
    #[doc = "< factor w.r.t. maxcutsroot for maximal number of generated cuts\n at the root node (-1.0: no limit, >= 0.0: valid finite limit)"]
    pub sepa_maxcutsrootgenfactor: f64,
    #[doc = "< maximal number of cuts separated per separation round"]
    pub sepa_maxcuts: ::std::os::raw::c_int,
    #[doc = "< maximal number of separated cuts at the root node"]
    pub sepa_maxcutsroot: ::std::os::raw::c_int,
    #[doc = "< maximum age a cut can reach before it is deleted from the global cut pool"]
    pub sepa_cutagelimit: ::std::os::raw::c_int,
    #[doc = "< separation frequency for the global cut pool"]
    pub sepa_poolfreq: ::std::os::raw::c_int,
    #[doc = "< the mode for the parallel implementation. 0: opportunistic or\n   1: deterministic"]
    pub parallel_mode: ::std::os::raw::c_int,
    #[doc = "< the minimum number of threads used for parallel code"]
    pub parallel_minnthreads: ::std::os::raw::c_int,
    #[doc = "< the maximum number of threads used for parallel code"]
    pub parallel_maxnthreads: ::std::os::raw::c_int,
    #[doc = "< change the seeds in the different solvers?"]
    pub concurrent_changeseeds: ::std::os::raw::c_uint,
    #[doc = "< change the child selection rule in different solvers?"]
    pub concurrent_changechildsel: ::std::os::raw::c_uint,
    #[doc = "< should the concurrent solvers communicate global variable bound changes?"]
    pub concurrent_commvarbnds: ::std::os::raw::c_uint,
    #[doc = "< should the problem be presolved before it is copied to the concurrent solvers?"]
    pub concurrent_presolvebefore: ::std::os::raw::c_uint,
    #[doc = "< the seed for computing the concurrent solver seeds"]
    pub concurrent_initseed: ::std::os::raw::c_int,
    #[doc = "< initial frequency of synchronization"]
    pub concurrent_freqinit: f64,
    #[doc = "< maximal frequency of synchronization"]
    pub concurrent_freqmax: f64,
    #[doc = "< factor by which the frequency of synchronization changes"]
    pub concurrent_freqfactor: f64,
    #[doc = "< when adapting the synchronization frequency this value is the targeted\n   relative difference by which the absolute gap decreases per synchronization"]
    pub concurrent_targetprogress: f64,
    #[doc = "< maximum number of solutions that will get stored in one synchronization"]
    pub concurrent_maxnsols: ::std::os::raw::c_int,
    #[doc = "< number of best solutions that should be considered for synchronization"]
    pub concurrent_nbestsols: ::std::os::raw::c_int,
    #[doc = "< max number of synchronizations before data is used"]
    pub concurrent_maxnsyncdelay: ::std::os::raw::c_int,
    #[doc = "< min offset before synchronization data is used"]
    pub concurrent_minsyncdelay: f64,
    #[doc = "< path prefix for parameter setting files of concurrent solver scip-custom"]
    pub concurrent_paramsetprefix: *mut ::std::os::raw::c_char,
    #[doc = "< default clock type to use"]
    pub time_clocktype: SCIP_CLOCKTYPE,
    #[doc = "< is timing enabled?"]
    pub time_enabled: ::std::os::raw::c_uint,
    #[doc = "< belongs reading time to solving time?"]
    pub time_reading: ::std::os::raw::c_uint,
    #[doc = "< should clock checks of solving time be performed less frequently (might exceed time limit slightly)"]
    pub time_rareclockcheck: ::std::os::raw::c_uint,
    #[doc = "< should timing for statistic output be enabled?"]
    pub time_statistictiming: ::std::os::raw::c_uint,
    #[doc = "< should time for evaluation in NLP solves be measured?"]
    pub time_nlpieval: ::std::os::raw::c_uint,
    #[doc = "< should automatic tree compression after presolving be enabled? (only for reoptimization)"]
    pub compr_enable: ::std::os::raw::c_uint,
    #[doc = "< maximum time to run tree compression heuristics"]
    pub compr_time: f64,
    #[doc = "< name of the VBC tool output file, or - if no VBC output should be created"]
    pub visual_vbcfilename: *mut ::std::os::raw::c_char,
    #[doc = "< name of the BAK tool output file, or - if no BAK output should be created"]
    pub visual_bakfilename: *mut ::std::os::raw::c_char,
    #[doc = "< should the real solving time be used instead of time step counter in visualization?"]
    pub visual_realtime: ::std::os::raw::c_uint,
    #[doc = "< should the node where solutions are found be visualized?"]
    pub visual_dispsols: ::std::os::raw::c_uint,
    #[doc = "< should lower bound information be visualized?"]
    pub visual_displb: ::std::os::raw::c_uint,
    #[doc = "< should be output the external value of the objective?"]
    pub visual_objextern: ::std::os::raw::c_uint,
    #[doc = "< should the problem be solved exactly (without numerical tolerances)?"]
    pub exact_enable: ::std::os::raw::c_uint,
    #[doc = "< should only exact solutions be checked which improve the primal bound?"]
    pub exact_improvingsols: ::std::os::raw::c_uint,
    #[doc = "< strategy to interleave safe dual bounding with exact LP\n   solve (0: never, 1: only close to cutoff bound, 2: only at depth lvl 2,4,8,16,...,\n   3: close to cutoff bound OR at depth lvl 2,4,8,16,...)"]
    pub exact_interleavedbstrat: ::std::os::raw::c_int,
    #[doc = "< method for computing safe dual bounds\n   ('n'eumaier-shcherbina, 'p'roject-and-shift, 'e'xact LP, 'a'utomatic)"]
    pub exact_safedbmethod: ::std::os::raw::c_char,
    #[doc = "< strategy for dual column selection in project-and-shift to compute interior point\n   (0: no sel, 1: active rows of inexact primal LP, 2: active rows of exact primal LP)"]
    pub exact_psdualcolselection: ::std::os::raw::c_int,
    #[doc = "< should exact the LP solver display status messages?"]
    pub exact_lpinfo: ::std::os::raw::c_uint,
    #[doc = "< should negative slack variables be used for gomory cuts in exact solving mode?"]
    pub exact_allownegslack: ::std::os::raw::c_uint,
    #[doc = "< maximal denominator in cut coefficients, leading to slightly\n   weaker but numerically better cuts (0: disabled)"]
    pub exact_cutmaxdenom: ::std::os::raw::c_longlong,
    #[doc = "< maximal absolute bound value for wich cut coefficient should\n   be approximated with bounded denominator (0: no restriction)"]
    pub exact_cutapproxmaxboundval: ::std::os::raw::c_longlong,
    #[doc = "< name of the certificate file, or \"-\" if no output should be created"]
    pub certificate_filename: *mut ::std::os::raw::c_char,
    #[doc = "< maximum size of the certificate file in MB (stop printing when reached)"]
    pub certificate_maxfilesize: f64,
    #[doc = "< should model constraints be marked as initial?"]
    pub read_initialconss: ::std::os::raw::c_uint,
    #[doc = "< should model constraints be subject to aging?"]
    pub read_dynamicconss: ::std::os::raw::c_uint,
    #[doc = "< should columns be added and removed dynamically to the LP?"]
    pub read_dynamiccols: ::std::os::raw::c_uint,
    #[doc = "< should rows be added and removed dynamically to the LP?"]
    pub read_dynamicrows: ::std::os::raw::c_uint,
    #[doc = "< should all constraints be written (including the redundant constraints)?"]
    pub write_allconss: ::std::os::raw::c_uint,
    #[doc = "< should variables set to zero be printed?"]
    pub write_printzeros: ::std::os::raw::c_uint,
    #[doc = "< when writing the problem with generic names, we start with index\n   0; using this parameter we can change the starting index to be\n   different"]
    pub write_genoffset: ::std::os::raw::c_int,
    #[doc = "< should integrality constraints (i.c.) be written for implied integral\n   variables? (0: use original i.c., 1: add i.c. to strongly implied integral\n   vars, 2: add i.c. to all implied integral vars, -1: remove i.c. from\n   strongly implied integral vars, -2: remove i.c. from all implied integral\n   vars)\""]
    pub write_implintlevel: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Set"][::std::mem::size_of::<SCIP_Set>() - 2336usize];
    ["Alignment of SCIP_Set"][::std::mem::align_of::<SCIP_Set>() - 8usize];
    ["Offset of field: SCIP_Set::stage"][::std::mem::offset_of!(SCIP_Set, stage) - 0usize];
    ["Offset of field: SCIP_Set::scip"][::std::mem::offset_of!(SCIP_Set, scip) - 8usize];
    ["Offset of field: SCIP_Set::paramset"][::std::mem::offset_of!(SCIP_Set, paramset) - 16usize];
    ["Offset of field: SCIP_Set::buffer"][::std::mem::offset_of!(SCIP_Set, buffer) - 24usize];
    ["Offset of field: SCIP_Set::cleanbuffer"]
        [::std::mem::offset_of!(SCIP_Set, cleanbuffer) - 32usize];
    ["Offset of field: SCIP_Set::readers"][::std::mem::offset_of!(SCIP_Set, readers) - 40usize];
    ["Offset of field: SCIP_Set::pricers"][::std::mem::offset_of!(SCIP_Set, pricers) - 48usize];
    ["Offset of field: SCIP_Set::conshdlrs"][::std::mem::offset_of!(SCIP_Set, conshdlrs) - 56usize];
    ["Offset of field: SCIP_Set::conshdlrs_sepa"]
        [::std::mem::offset_of!(SCIP_Set, conshdlrs_sepa) - 64usize];
    ["Offset of field: SCIP_Set::conshdlrs_enfo"]
        [::std::mem::offset_of!(SCIP_Set, conshdlrs_enfo) - 72usize];
    ["Offset of field: SCIP_Set::conshdlrs_include"]
        [::std::mem::offset_of!(SCIP_Set, conshdlrs_include) - 80usize];
    ["Offset of field: SCIP_Set::conflicthdlrs"]
        [::std::mem::offset_of!(SCIP_Set, conflicthdlrs) - 88usize];
    ["Offset of field: SCIP_Set::presols"][::std::mem::offset_of!(SCIP_Set, presols) - 96usize];
    ["Offset of field: SCIP_Set::relaxs"][::std::mem::offset_of!(SCIP_Set, relaxs) - 104usize];
    ["Offset of field: SCIP_Set::sepas"][::std::mem::offset_of!(SCIP_Set, sepas) - 112usize];
    ["Offset of field: SCIP_Set::cutsels"][::std::mem::offset_of!(SCIP_Set, cutsels) - 120usize];
    ["Offset of field: SCIP_Set::props"][::std::mem::offset_of!(SCIP_Set, props) - 128usize];
    ["Offset of field: SCIP_Set::props_presol"]
        [::std::mem::offset_of!(SCIP_Set, props_presol) - 136usize];
    ["Offset of field: SCIP_Set::heurs"][::std::mem::offset_of!(SCIP_Set, heurs) - 144usize];
    ["Offset of field: SCIP_Set::comprs"][::std::mem::offset_of!(SCIP_Set, comprs) - 152usize];
    ["Offset of field: SCIP_Set::eventhdlrs"]
        [::std::mem::offset_of!(SCIP_Set, eventhdlrs) - 160usize];
    ["Offset of field: SCIP_Set::nodesels"][::std::mem::offset_of!(SCIP_Set, nodesels) - 168usize];
    ["Offset of field: SCIP_Set::nodesel"][::std::mem::offset_of!(SCIP_Set, nodesel) - 176usize];
    ["Offset of field: SCIP_Set::branchrules"]
        [::std::mem::offset_of!(SCIP_Set, branchrules) - 184usize];
    ["Offset of field: SCIP_Set::iisfinders"]
        [::std::mem::offset_of!(SCIP_Set, iisfinders) - 192usize];
    ["Offset of field: SCIP_Set::disps"][::std::mem::offset_of!(SCIP_Set, disps) - 200usize];
    ["Offset of field: SCIP_Set::tables"][::std::mem::offset_of!(SCIP_Set, tables) - 208usize];
    ["Offset of field: SCIP_Set::dialogs"][::std::mem::offset_of!(SCIP_Set, dialogs) - 216usize];
    ["Offset of field: SCIP_Set::exprhdlrs"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrs) - 224usize];
    ["Offset of field: SCIP_Set::exprhdlrvar"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrvar) - 232usize];
    ["Offset of field: SCIP_Set::exprhdlrval"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrval) - 240usize];
    ["Offset of field: SCIP_Set::exprhdlrsum"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrsum) - 248usize];
    ["Offset of field: SCIP_Set::exprhdlrproduct"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrproduct) - 256usize];
    ["Offset of field: SCIP_Set::exprhdlrpow"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrpow) - 264usize];
    ["Offset of field: SCIP_Set::nlpis"][::std::mem::offset_of!(SCIP_Set, nlpis) - 272usize];
    ["Offset of field: SCIP_Set::concsolvertypes"]
        [::std::mem::offset_of!(SCIP_Set, concsolvertypes) - 280usize];
    ["Offset of field: SCIP_Set::concsolvers"]
        [::std::mem::offset_of!(SCIP_Set, concsolvers) - 288usize];
    ["Offset of field: SCIP_Set::benders"][::std::mem::offset_of!(SCIP_Set, benders) - 296usize];
    ["Offset of field: SCIP_Set::debugsoldata"]
        [::std::mem::offset_of!(SCIP_Set, debugsoldata) - 304usize];
    ["Offset of field: SCIP_Set::banditvtables"]
        [::std::mem::offset_of!(SCIP_Set, banditvtables) - 312usize];
    ["Offset of field: SCIP_Set::extcodenames"]
        [::std::mem::offset_of!(SCIP_Set, extcodenames) - 320usize];
    ["Offset of field: SCIP_Set::extcodedescs"]
        [::std::mem::offset_of!(SCIP_Set, extcodedescs) - 328usize];
    ["Offset of field: SCIP_Set::nreaders"][::std::mem::offset_of!(SCIP_Set, nreaders) - 336usize];
    ["Offset of field: SCIP_Set::readerssize"]
        [::std::mem::offset_of!(SCIP_Set, readerssize) - 340usize];
    ["Offset of field: SCIP_Set::npricers"][::std::mem::offset_of!(SCIP_Set, npricers) - 344usize];
    ["Offset of field: SCIP_Set::nactivepricers"]
        [::std::mem::offset_of!(SCIP_Set, nactivepricers) - 348usize];
    ["Offset of field: SCIP_Set::pricerssize"]
        [::std::mem::offset_of!(SCIP_Set, pricerssize) - 352usize];
    ["Offset of field: SCIP_Set::nconshdlrs"]
        [::std::mem::offset_of!(SCIP_Set, nconshdlrs) - 356usize];
    ["Offset of field: SCIP_Set::conshdlrssize"]
        [::std::mem::offset_of!(SCIP_Set, conshdlrssize) - 360usize];
    ["Offset of field: SCIP_Set::nconflicthdlrs"]
        [::std::mem::offset_of!(SCIP_Set, nconflicthdlrs) - 364usize];
    ["Offset of field: SCIP_Set::conflicthdlrssize"]
        [::std::mem::offset_of!(SCIP_Set, conflicthdlrssize) - 368usize];
    ["Offset of field: SCIP_Set::npresols"][::std::mem::offset_of!(SCIP_Set, npresols) - 372usize];
    ["Offset of field: SCIP_Set::presolssize"]
        [::std::mem::offset_of!(SCIP_Set, presolssize) - 376usize];
    ["Offset of field: SCIP_Set::nrelaxs"][::std::mem::offset_of!(SCIP_Set, nrelaxs) - 380usize];
    ["Offset of field: SCIP_Set::relaxssize"]
        [::std::mem::offset_of!(SCIP_Set, relaxssize) - 384usize];
    ["Offset of field: SCIP_Set::nsepas"][::std::mem::offset_of!(SCIP_Set, nsepas) - 388usize];
    ["Offset of field: SCIP_Set::sepassize"]
        [::std::mem::offset_of!(SCIP_Set, sepassize) - 392usize];
    ["Offset of field: SCIP_Set::ncutsels"][::std::mem::offset_of!(SCIP_Set, ncutsels) - 396usize];
    ["Offset of field: SCIP_Set::cutselssize"]
        [::std::mem::offset_of!(SCIP_Set, cutselssize) - 400usize];
    ["Offset of field: SCIP_Set::nprops"][::std::mem::offset_of!(SCIP_Set, nprops) - 404usize];
    ["Offset of field: SCIP_Set::propssize"]
        [::std::mem::offset_of!(SCIP_Set, propssize) - 408usize];
    ["Offset of field: SCIP_Set::nheurs"][::std::mem::offset_of!(SCIP_Set, nheurs) - 412usize];
    ["Offset of field: SCIP_Set::heurssize"]
        [::std::mem::offset_of!(SCIP_Set, heurssize) - 416usize];
    ["Offset of field: SCIP_Set::ncomprs"][::std::mem::offset_of!(SCIP_Set, ncomprs) - 420usize];
    ["Offset of field: SCIP_Set::comprssize"]
        [::std::mem::offset_of!(SCIP_Set, comprssize) - 424usize];
    ["Offset of field: SCIP_Set::neventhdlrs"]
        [::std::mem::offset_of!(SCIP_Set, neventhdlrs) - 428usize];
    ["Offset of field: SCIP_Set::eventhdlrssize"]
        [::std::mem::offset_of!(SCIP_Set, eventhdlrssize) - 432usize];
    ["Offset of field: SCIP_Set::nnodesels"]
        [::std::mem::offset_of!(SCIP_Set, nnodesels) - 436usize];
    ["Offset of field: SCIP_Set::nodeselssize"]
        [::std::mem::offset_of!(SCIP_Set, nodeselssize) - 440usize];
    ["Offset of field: SCIP_Set::nbranchrules"]
        [::std::mem::offset_of!(SCIP_Set, nbranchrules) - 444usize];
    ["Offset of field: SCIP_Set::branchrulessize"]
        [::std::mem::offset_of!(SCIP_Set, branchrulessize) - 448usize];
    ["Offset of field: SCIP_Set::niisfinders"]
        [::std::mem::offset_of!(SCIP_Set, niisfinders) - 452usize];
    ["Offset of field: SCIP_Set::iisfinderssize"]
        [::std::mem::offset_of!(SCIP_Set, iisfinderssize) - 456usize];
    ["Offset of field: SCIP_Set::ndisps"][::std::mem::offset_of!(SCIP_Set, ndisps) - 460usize];
    ["Offset of field: SCIP_Set::dispssize"]
        [::std::mem::offset_of!(SCIP_Set, dispssize) - 464usize];
    ["Offset of field: SCIP_Set::ntables"][::std::mem::offset_of!(SCIP_Set, ntables) - 468usize];
    ["Offset of field: SCIP_Set::tablessize"]
        [::std::mem::offset_of!(SCIP_Set, tablessize) - 472usize];
    ["Offset of field: SCIP_Set::ndialogs"][::std::mem::offset_of!(SCIP_Set, ndialogs) - 476usize];
    ["Offset of field: SCIP_Set::dialogssize"]
        [::std::mem::offset_of!(SCIP_Set, dialogssize) - 480usize];
    ["Offset of field: SCIP_Set::nexprhdlrs"]
        [::std::mem::offset_of!(SCIP_Set, nexprhdlrs) - 484usize];
    ["Offset of field: SCIP_Set::exprhdlrssize"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrssize) - 488usize];
    ["Offset of field: SCIP_Set::nnlpis"][::std::mem::offset_of!(SCIP_Set, nnlpis) - 492usize];
    ["Offset of field: SCIP_Set::nlpissize"]
        [::std::mem::offset_of!(SCIP_Set, nlpissize) - 496usize];
    ["Offset of field: SCIP_Set::nconcsolvertypes"]
        [::std::mem::offset_of!(SCIP_Set, nconcsolvertypes) - 500usize];
    ["Offset of field: SCIP_Set::concsolvertypessize"]
        [::std::mem::offset_of!(SCIP_Set, concsolvertypessize) - 504usize];
    ["Offset of field: SCIP_Set::nconcsolvers"]
        [::std::mem::offset_of!(SCIP_Set, nconcsolvers) - 508usize];
    ["Offset of field: SCIP_Set::concsolverssize"]
        [::std::mem::offset_of!(SCIP_Set, concsolverssize) - 512usize];
    ["Offset of field: SCIP_Set::nbenders"][::std::mem::offset_of!(SCIP_Set, nbenders) - 516usize];
    ["Offset of field: SCIP_Set::nactivebenders"]
        [::std::mem::offset_of!(SCIP_Set, nactivebenders) - 520usize];
    ["Offset of field: SCIP_Set::benderssize"]
        [::std::mem::offset_of!(SCIP_Set, benderssize) - 524usize];
    ["Offset of field: SCIP_Set::nextcodes"]
        [::std::mem::offset_of!(SCIP_Set, nextcodes) - 528usize];
    ["Offset of field: SCIP_Set::extcodessize"]
        [::std::mem::offset_of!(SCIP_Set, extcodessize) - 532usize];
    ["Offset of field: SCIP_Set::nbanditvtables"]
        [::std::mem::offset_of!(SCIP_Set, nbanditvtables) - 536usize];
    ["Offset of field: SCIP_Set::banditvtablessize"]
        [::std::mem::offset_of!(SCIP_Set, banditvtablessize) - 540usize];
    ["Offset of field: SCIP_Set::pricerssorted"]
        [::std::mem::offset_of!(SCIP_Set, pricerssorted) - 544usize];
    ["Offset of field: SCIP_Set::pricersnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, pricersnamesorted) - 548usize];
    ["Offset of field: SCIP_Set::conflicthdlrssorted"]
        [::std::mem::offset_of!(SCIP_Set, conflicthdlrssorted) - 552usize];
    ["Offset of field: SCIP_Set::conflicthdlrsnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, conflicthdlrsnamesorted) - 556usize];
    ["Offset of field: SCIP_Set::presolssorted"]
        [::std::mem::offset_of!(SCIP_Set, presolssorted) - 560usize];
    ["Offset of field: SCIP_Set::presolsnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, presolsnamesorted) - 564usize];
    ["Offset of field: SCIP_Set::relaxssorted"]
        [::std::mem::offset_of!(SCIP_Set, relaxssorted) - 568usize];
    ["Offset of field: SCIP_Set::relaxsnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, relaxsnamesorted) - 572usize];
    ["Offset of field: SCIP_Set::sepassorted"]
        [::std::mem::offset_of!(SCIP_Set, sepassorted) - 576usize];
    ["Offset of field: SCIP_Set::sepasnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, sepasnamesorted) - 580usize];
    ["Offset of field: SCIP_Set::cutselssorted"]
        [::std::mem::offset_of!(SCIP_Set, cutselssorted) - 584usize];
    ["Offset of field: SCIP_Set::propssorted"]
        [::std::mem::offset_of!(SCIP_Set, propssorted) - 588usize];
    ["Offset of field: SCIP_Set::propspresolsorted"]
        [::std::mem::offset_of!(SCIP_Set, propspresolsorted) - 592usize];
    ["Offset of field: SCIP_Set::propsnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, propsnamesorted) - 596usize];
    ["Offset of field: SCIP_Set::heurssorted"]
        [::std::mem::offset_of!(SCIP_Set, heurssorted) - 600usize];
    ["Offset of field: SCIP_Set::heursnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, heursnamesorted) - 604usize];
    ["Offset of field: SCIP_Set::comprssorted"]
        [::std::mem::offset_of!(SCIP_Set, comprssorted) - 608usize];
    ["Offset of field: SCIP_Set::comprsnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, comprsnamesorted) - 612usize];
    ["Offset of field: SCIP_Set::branchrulessorted"]
        [::std::mem::offset_of!(SCIP_Set, branchrulessorted) - 616usize];
    ["Offset of field: SCIP_Set::branchrulesnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, branchrulesnamesorted) - 620usize];
    ["Offset of field: SCIP_Set::iisfinderssorted"]
        [::std::mem::offset_of!(SCIP_Set, iisfinderssorted) - 624usize];
    ["Offset of field: SCIP_Set::tablessorted"]
        [::std::mem::offset_of!(SCIP_Set, tablessorted) - 628usize];
    ["Offset of field: SCIP_Set::exprhdlrssorted"]
        [::std::mem::offset_of!(SCIP_Set, exprhdlrssorted) - 632usize];
    ["Offset of field: SCIP_Set::nlpissorted"]
        [::std::mem::offset_of!(SCIP_Set, nlpissorted) - 636usize];
    ["Offset of field: SCIP_Set::benderssorted"]
        [::std::mem::offset_of!(SCIP_Set, benderssorted) - 640usize];
    ["Offset of field: SCIP_Set::bendersnamesorted"]
        [::std::mem::offset_of!(SCIP_Set, bendersnamesorted) - 644usize];
    ["Offset of field: SCIP_Set::limitchanged"]
        [::std::mem::offset_of!(SCIP_Set, limitchanged) - 648usize];
    ["Offset of field: SCIP_Set::subscipsoff"]
        [::std::mem::offset_of!(SCIP_Set, subscipsoff) - 652usize];
    ["Offset of field: SCIP_Set::branch_scorefunc"]
        [::std::mem::offset_of!(SCIP_Set, branch_scorefunc) - 656usize];
    ["Offset of field: SCIP_Set::branch_firstsbchild"]
        [::std::mem::offset_of!(SCIP_Set, branch_firstsbchild) - 657usize];
    ["Offset of field: SCIP_Set::branch_scorefac"]
        [::std::mem::offset_of!(SCIP_Set, branch_scorefac) - 664usize];
    ["Offset of field: SCIP_Set::branch_preferbinary"]
        [::std::mem::offset_of!(SCIP_Set, branch_preferbinary) - 672usize];
    ["Offset of field: SCIP_Set::branch_clamp"]
        [::std::mem::offset_of!(SCIP_Set, branch_clamp) - 680usize];
    ["Offset of field: SCIP_Set::branch_midpull"]
        [::std::mem::offset_of!(SCIP_Set, branch_midpull) - 688usize];
    ["Offset of field: SCIP_Set::branch_midpullreldomtrig"]
        [::std::mem::offset_of!(SCIP_Set, branch_midpullreldomtrig) - 696usize];
    ["Offset of field: SCIP_Set::branch_lpgainnorm"]
        [::std::mem::offset_of!(SCIP_Set, branch_lpgainnorm) - 704usize];
    ["Offset of field: SCIP_Set::branch_delaypscost"]
        [::std::mem::offset_of!(SCIP_Set, branch_delaypscost) - 708usize];
    ["Offset of field: SCIP_Set::branch_divingpscost"]
        [::std::mem::offset_of!(SCIP_Set, branch_divingpscost) - 712usize];
    ["Offset of field: SCIP_Set::branch_collectancpscost"]
        [::std::mem::offset_of!(SCIP_Set, branch_collectancpscost) - 716usize];
    ["Offset of field: SCIP_Set::branch_forceall"]
        [::std::mem::offset_of!(SCIP_Set, branch_forceall) - 720usize];
    ["Offset of field: SCIP_Set::branch_checksbsol"]
        [::std::mem::offset_of!(SCIP_Set, branch_checksbsol) - 724usize];
    ["Offset of field: SCIP_Set::branch_roundsbsol"]
        [::std::mem::offset_of!(SCIP_Set, branch_roundsbsol) - 728usize];
    ["Offset of field: SCIP_Set::branch_sumadjustscore"]
        [::std::mem::offset_of!(SCIP_Set, branch_sumadjustscore) - 732usize];
    ["Offset of field: SCIP_Set::conf_maxvarsfac"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxvarsfac) - 736usize];
    ["Offset of field: SCIP_Set::conf_maxvarsfracres"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxvarsfracres) - 744usize];
    ["Offset of field: SCIP_Set::conf_minmaxvars"]
        [::std::mem::offset_of!(SCIP_Set, conf_minmaxvars) - 752usize];
    ["Offset of field: SCIP_Set::conf_maxlploops"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxlploops) - 756usize];
    ["Offset of field: SCIP_Set::conf_lpiterations"]
        [::std::mem::offset_of!(SCIP_Set, conf_lpiterations) - 760usize];
    ["Offset of field: SCIP_Set::conf_fuiplevels"]
        [::std::mem::offset_of!(SCIP_Set, conf_fuiplevels) - 764usize];
    ["Offset of field: SCIP_Set::conf_resfuiplevels"]
        [::std::mem::offset_of!(SCIP_Set, conf_resfuiplevels) - 768usize];
    ["Offset of field: SCIP_Set::conf_interconss"]
        [::std::mem::offset_of!(SCIP_Set, conf_interconss) - 772usize];
    ["Offset of field: SCIP_Set::conf_maxconss"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxconss) - 776usize];
    ["Offset of field: SCIP_Set::conf_maxstoresize"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxstoresize) - 780usize];
    ["Offset of field: SCIP_Set::conf_reconvlevels"]
        [::std::mem::offset_of!(SCIP_Set, conf_reconvlevels) - 784usize];
    ["Offset of field: SCIP_Set::conf_enable"]
        [::std::mem::offset_of!(SCIP_Set, conf_enable) - 788usize];
    ["Offset of field: SCIP_Set::conf_cleanbnddepend"]
        [::std::mem::offset_of!(SCIP_Set, conf_cleanbnddepend) - 792usize];
    ["Offset of field: SCIP_Set::conf_useprop"]
        [::std::mem::offset_of!(SCIP_Set, conf_useprop) - 796usize];
    ["Offset of field: SCIP_Set::conf_usegenres"]
        [::std::mem::offset_of!(SCIP_Set, conf_usegenres) - 800usize];
    ["Offset of field: SCIP_Set::conf_useinflp"]
        [::std::mem::offset_of!(SCIP_Set, conf_useinflp) - 804usize];
    ["Offset of field: SCIP_Set::conf_useboundlp"]
        [::std::mem::offset_of!(SCIP_Set, conf_useboundlp) - 805usize];
    ["Offset of field: SCIP_Set::conf_usesb"]
        [::std::mem::offset_of!(SCIP_Set, conf_usesb) - 808usize];
    ["Offset of field: SCIP_Set::conf_reduction"]
        [::std::mem::offset_of!(SCIP_Set, conf_reduction) - 812usize];
    ["Offset of field: SCIP_Set::conf_mbreduction"]
        [::std::mem::offset_of!(SCIP_Set, conf_mbreduction) - 816usize];
    ["Offset of field: SCIP_Set::conf_usepseudo"]
        [::std::mem::offset_of!(SCIP_Set, conf_usepseudo) - 820usize];
    ["Offset of field: SCIP_Set::conf_prefinfproof"]
        [::std::mem::offset_of!(SCIP_Set, conf_prefinfproof) - 824usize];
    ["Offset of field: SCIP_Set::conf_preferbinary"]
        [::std::mem::offset_of!(SCIP_Set, conf_preferbinary) - 828usize];
    ["Offset of field: SCIP_Set::conf_allowlocal"]
        [::std::mem::offset_of!(SCIP_Set, conf_allowlocal) - 832usize];
    ["Offset of field: SCIP_Set::conf_settlelocal"]
        [::std::mem::offset_of!(SCIP_Set, conf_settlelocal) - 836usize];
    ["Offset of field: SCIP_Set::conf_repropagate"]
        [::std::mem::offset_of!(SCIP_Set, conf_repropagate) - 840usize];
    ["Offset of field: SCIP_Set::conf_keepreprop"]
        [::std::mem::offset_of!(SCIP_Set, conf_keepreprop) - 844usize];
    ["Offset of field: SCIP_Set::conf_separate"]
        [::std::mem::offset_of!(SCIP_Set, conf_separate) - 848usize];
    ["Offset of field: SCIP_Set::conf_dynamic"]
        [::std::mem::offset_of!(SCIP_Set, conf_dynamic) - 852usize];
    ["Offset of field: SCIP_Set::conf_removable"]
        [::std::mem::offset_of!(SCIP_Set, conf_removable) - 856usize];
    ["Offset of field: SCIP_Set::conf_depthscorefac"]
        [::std::mem::offset_of!(SCIP_Set, conf_depthscorefac) - 864usize];
    ["Offset of field: SCIP_Set::conf_proofscorefac"]
        [::std::mem::offset_of!(SCIP_Set, conf_proofscorefac) - 872usize];
    ["Offset of field: SCIP_Set::conf_uplockscorefac"]
        [::std::mem::offset_of!(SCIP_Set, conf_uplockscorefac) - 880usize];
    ["Offset of field: SCIP_Set::conf_downlockscorefac"]
        [::std::mem::offset_of!(SCIP_Set, conf_downlockscorefac) - 888usize];
    ["Offset of field: SCIP_Set::conf_scorefac"]
        [::std::mem::offset_of!(SCIP_Set, conf_scorefac) - 896usize];
    ["Offset of field: SCIP_Set::conf_restartnum"]
        [::std::mem::offset_of!(SCIP_Set, conf_restartnum) - 904usize];
    ["Offset of field: SCIP_Set::conf_restartfac"]
        [::std::mem::offset_of!(SCIP_Set, conf_restartfac) - 912usize];
    ["Offset of field: SCIP_Set::conf_ignorerelaxedbd"]
        [::std::mem::offset_of!(SCIP_Set, conf_ignorerelaxedbd) - 920usize];
    ["Offset of field: SCIP_Set::conf_maxvarsdetectimpliedbounds"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxvarsdetectimpliedbounds) - 924usize];
    ["Offset of field: SCIP_Set::conf_fullshortenconflict"]
        [::std::mem::offset_of!(SCIP_Set, conf_fullshortenconflict) - 928usize];
    ["Offset of field: SCIP_Set::conf_conflictweight"]
        [::std::mem::offset_of!(SCIP_Set, conf_conflictweight) - 936usize];
    ["Offset of field: SCIP_Set::conf_conflictgraphweight"]
        [::std::mem::offset_of!(SCIP_Set, conf_conflictgraphweight) - 944usize];
    ["Offset of field: SCIP_Set::conf_weightsize"]
        [::std::mem::offset_of!(SCIP_Set, conf_weightsize) - 952usize];
    ["Offset of field: SCIP_Set::conf_weightrepropdepth"]
        [::std::mem::offset_of!(SCIP_Set, conf_weightrepropdepth) - 960usize];
    ["Offset of field: SCIP_Set::conf_weightvaliddepth"]
        [::std::mem::offset_of!(SCIP_Set, conf_weightvaliddepth) - 968usize];
    ["Offset of field: SCIP_Set::conf_sepaaltproofs"]
        [::std::mem::offset_of!(SCIP_Set, conf_sepaaltproofs) - 976usize];
    ["Offset of field: SCIP_Set::conf_minimprove"]
        [::std::mem::offset_of!(SCIP_Set, conf_minimprove) - 984usize];
    ["Offset of field: SCIP_Set::conf_uselocalrows"]
        [::std::mem::offset_of!(SCIP_Set, conf_uselocalrows) - 992usize];
    ["Offset of field: SCIP_Set::conf_maxcoefquot"]
        [::std::mem::offset_of!(SCIP_Set, conf_maxcoefquot) - 1000usize];
    ["Offset of field: SCIP_Set::conf_fixandcontinue"]
        [::std::mem::offset_of!(SCIP_Set, conf_fixandcontinue) - 1008usize];
    ["Offset of field: SCIP_Set::cons_agelimit"]
        [::std::mem::offset_of!(SCIP_Set, cons_agelimit) - 1012usize];
    ["Offset of field: SCIP_Set::cons_obsoleteage"]
        [::std::mem::offset_of!(SCIP_Set, cons_obsoleteage) - 1016usize];
    ["Offset of field: SCIP_Set::cons_disableenfops"]
        [::std::mem::offset_of!(SCIP_Set, cons_disableenfops) - 1020usize];
    ["Offset of field: SCIP_Set::disp_verblevel"]
        [::std::mem::offset_of!(SCIP_Set, disp_verblevel) - 1024usize];
    ["Offset of field: SCIP_Set::disp_width"]
        [::std::mem::offset_of!(SCIP_Set, disp_width) - 1028usize];
    ["Offset of field: SCIP_Set::disp_freq"]
        [::std::mem::offset_of!(SCIP_Set, disp_freq) - 1032usize];
    ["Offset of field: SCIP_Set::disp_headerfreq"]
        [::std::mem::offset_of!(SCIP_Set, disp_headerfreq) - 1036usize];
    ["Offset of field: SCIP_Set::disp_lpinfo"]
        [::std::mem::offset_of!(SCIP_Set, disp_lpinfo) - 1040usize];
    ["Offset of field: SCIP_Set::disp_allviols"]
        [::std::mem::offset_of!(SCIP_Set, disp_allviols) - 1044usize];
    ["Offset of field: SCIP_Set::disp_relevantstats"]
        [::std::mem::offset_of!(SCIP_Set, disp_relevantstats) - 1048usize];
    ["Offset of field: SCIP_Set::heur_useuctsubscip"]
        [::std::mem::offset_of!(SCIP_Set, heur_useuctsubscip) - 1052usize];
    ["Offset of field: SCIP_Set::history_valuebased"]
        [::std::mem::offset_of!(SCIP_Set, history_valuebased) - 1056usize];
    ["Offset of field: SCIP_Set::history_allowmerge"]
        [::std::mem::offset_of!(SCIP_Set, history_allowmerge) - 1060usize];
    ["Offset of field: SCIP_Set::history_allowtransfer"]
        [::std::mem::offset_of!(SCIP_Set, history_allowtransfer) - 1064usize];
    ["Offset of field: SCIP_Set::iisfinder_irreducible"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_irreducible) - 1068usize];
    ["Offset of field: SCIP_Set::iisfinder_removebounds"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_removebounds) - 1072usize];
    ["Offset of field: SCIP_Set::iisfinder_silent"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_silent) - 1076usize];
    ["Offset of field: SCIP_Set::iisfinder_stopafterone"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_stopafterone) - 1080usize];
    ["Offset of field: SCIP_Set::iisfinder_removeunusedvars"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_removeunusedvars) - 1084usize];
    ["Offset of field: SCIP_Set::iisfinder_time"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_time) - 1088usize];
    ["Offset of field: SCIP_Set::iisfinder_nodes"]
        [::std::mem::offset_of!(SCIP_Set, iisfinder_nodes) - 1096usize];
    ["Offset of field: SCIP_Set::limit_time"]
        [::std::mem::offset_of!(SCIP_Set, limit_time) - 1104usize];
    ["Offset of field: SCIP_Set::limit_memory"]
        [::std::mem::offset_of!(SCIP_Set, limit_memory) - 1112usize];
    ["Offset of field: SCIP_Set::limit_gap"]
        [::std::mem::offset_of!(SCIP_Set, limit_gap) - 1120usize];
    ["Offset of field: SCIP_Set::limit_absgap"]
        [::std::mem::offset_of!(SCIP_Set, limit_absgap) - 1128usize];
    ["Offset of field: SCIP_Set::limit_primal"]
        [::std::mem::offset_of!(SCIP_Set, limit_primal) - 1136usize];
    ["Offset of field: SCIP_Set::limit_dual"]
        [::std::mem::offset_of!(SCIP_Set, limit_dual) - 1144usize];
    ["Offset of field: SCIP_Set::limit_nodes"]
        [::std::mem::offset_of!(SCIP_Set, limit_nodes) - 1152usize];
    ["Offset of field: SCIP_Set::limit_totalnodes"]
        [::std::mem::offset_of!(SCIP_Set, limit_totalnodes) - 1160usize];
    ["Offset of field: SCIP_Set::limit_stallnodes"]
        [::std::mem::offset_of!(SCIP_Set, limit_stallnodes) - 1168usize];
    ["Offset of field: SCIP_Set::limit_solutions"]
        [::std::mem::offset_of!(SCIP_Set, limit_solutions) - 1176usize];
    ["Offset of field: SCIP_Set::limit_bestsol"]
        [::std::mem::offset_of!(SCIP_Set, limit_bestsol) - 1180usize];
    ["Offset of field: SCIP_Set::limit_maxsol"]
        [::std::mem::offset_of!(SCIP_Set, limit_maxsol) - 1184usize];
    ["Offset of field: SCIP_Set::limit_maxorigsol"]
        [::std::mem::offset_of!(SCIP_Set, limit_maxorigsol) - 1188usize];
    ["Offset of field: SCIP_Set::limit_restarts"]
        [::std::mem::offset_of!(SCIP_Set, limit_restarts) - 1192usize];
    ["Offset of field: SCIP_Set::limit_autorestartnodes"]
        [::std::mem::offset_of!(SCIP_Set, limit_autorestartnodes) - 1196usize];
    ["Offset of field: SCIP_Set::istimelimitfinite"]
        [::std::mem::offset_of!(SCIP_Set, istimelimitfinite) - 1200usize];
    ["Offset of field: SCIP_Set::lp_solvefreq"]
        [::std::mem::offset_of!(SCIP_Set, lp_solvefreq) - 1204usize];
    ["Offset of field: SCIP_Set::lp_iterlim"]
        [::std::mem::offset_of!(SCIP_Set, lp_iterlim) - 1208usize];
    ["Offset of field: SCIP_Set::lp_rootiterlim"]
        [::std::mem::offset_of!(SCIP_Set, lp_rootiterlim) - 1216usize];
    ["Offset of field: SCIP_Set::lp_solvedepth"]
        [::std::mem::offset_of!(SCIP_Set, lp_solvedepth) - 1224usize];
    ["Offset of field: SCIP_Set::lp_minsolvedepth"]
        [::std::mem::offset_of!(SCIP_Set, lp_minsolvedepth) - 1228usize];
    ["Offset of field: SCIP_Set::lp_initalgorithm"]
        [::std::mem::offset_of!(SCIP_Set, lp_initalgorithm) - 1232usize];
    ["Offset of field: SCIP_Set::lp_resolvealgorithm"]
        [::std::mem::offset_of!(SCIP_Set, lp_resolvealgorithm) - 1233usize];
    ["Offset of field: SCIP_Set::lp_pricing"]
        [::std::mem::offset_of!(SCIP_Set, lp_pricing) - 1234usize];
    ["Offset of field: SCIP_Set::lp_clearinitialprobinglp"]
        [::std::mem::offset_of!(SCIP_Set, lp_clearinitialprobinglp) - 1236usize];
    ["Offset of field: SCIP_Set::lp_resolverestore"]
        [::std::mem::offset_of!(SCIP_Set, lp_resolverestore) - 1240usize];
    ["Offset of field: SCIP_Set::lp_freesolvalbuffers"]
        [::std::mem::offset_of!(SCIP_Set, lp_freesolvalbuffers) - 1244usize];
    ["Offset of field: SCIP_Set::lp_colagelimit"]
        [::std::mem::offset_of!(SCIP_Set, lp_colagelimit) - 1248usize];
    ["Offset of field: SCIP_Set::lp_rowagelimit"]
        [::std::mem::offset_of!(SCIP_Set, lp_rowagelimit) - 1252usize];
    ["Offset of field: SCIP_Set::lp_cleanupcols"]
        [::std::mem::offset_of!(SCIP_Set, lp_cleanupcols) - 1256usize];
    ["Offset of field: SCIP_Set::lp_cleanupcolsroot"]
        [::std::mem::offset_of!(SCIP_Set, lp_cleanupcolsroot) - 1260usize];
    ["Offset of field: SCIP_Set::lp_cleanuprows"]
        [::std::mem::offset_of!(SCIP_Set, lp_cleanuprows) - 1264usize];
    ["Offset of field: SCIP_Set::lp_cleanuprowsroot"]
        [::std::mem::offset_of!(SCIP_Set, lp_cleanuprowsroot) - 1268usize];
    ["Offset of field: SCIP_Set::lp_checkstability"]
        [::std::mem::offset_of!(SCIP_Set, lp_checkstability) - 1272usize];
    ["Offset of field: SCIP_Set::lp_conditionlimit"]
        [::std::mem::offset_of!(SCIP_Set, lp_conditionlimit) - 1280usize];
    ["Offset of field: SCIP_Set::lp_markowitz"]
        [::std::mem::offset_of!(SCIP_Set, lp_markowitz) - 1288usize];
    ["Offset of field: SCIP_Set::lp_checkprimfeas"]
        [::std::mem::offset_of!(SCIP_Set, lp_checkprimfeas) - 1296usize];
    ["Offset of field: SCIP_Set::lp_checkdualfeas"]
        [::std::mem::offset_of!(SCIP_Set, lp_checkdualfeas) - 1300usize];
    ["Offset of field: SCIP_Set::lp_checkfarkas"]
        [::std::mem::offset_of!(SCIP_Set, lp_checkfarkas) - 1304usize];
    ["Offset of field: SCIP_Set::lp_fastmip"]
        [::std::mem::offset_of!(SCIP_Set, lp_fastmip) - 1308usize];
    ["Offset of field: SCIP_Set::lp_scaling"]
        [::std::mem::offset_of!(SCIP_Set, lp_scaling) - 1312usize];
    ["Offset of field: SCIP_Set::lp_presolving"]
        [::std::mem::offset_of!(SCIP_Set, lp_presolving) - 1316usize];
    ["Offset of field: SCIP_Set::lp_lexdualalgo"]
        [::std::mem::offset_of!(SCIP_Set, lp_lexdualalgo) - 1320usize];
    ["Offset of field: SCIP_Set::lp_lexdualrootonly"]
        [::std::mem::offset_of!(SCIP_Set, lp_lexdualrootonly) - 1324usize];
    ["Offset of field: SCIP_Set::lp_lexdualmaxrounds"]
        [::std::mem::offset_of!(SCIP_Set, lp_lexdualmaxrounds) - 1328usize];
    ["Offset of field: SCIP_Set::lp_lexdualbasic"]
        [::std::mem::offset_of!(SCIP_Set, lp_lexdualbasic) - 1332usize];
    ["Offset of field: SCIP_Set::lp_lexdualstalling"]
        [::std::mem::offset_of!(SCIP_Set, lp_lexdualstalling) - 1336usize];
    ["Offset of field: SCIP_Set::lp_disablecutoff"]
        [::std::mem::offset_of!(SCIP_Set, lp_disablecutoff) - 1340usize];
    ["Offset of field: SCIP_Set::lp_rowrepswitch"]
        [::std::mem::offset_of!(SCIP_Set, lp_rowrepswitch) - 1344usize];
    ["Offset of field: SCIP_Set::lp_threads"]
        [::std::mem::offset_of!(SCIP_Set, lp_threads) - 1352usize];
    ["Offset of field: SCIP_Set::lp_resolveiterfac"]
        [::std::mem::offset_of!(SCIP_Set, lp_resolveiterfac) - 1360usize];
    ["Offset of field: SCIP_Set::lp_resolveitermin"]
        [::std::mem::offset_of!(SCIP_Set, lp_resolveitermin) - 1368usize];
    ["Offset of field: SCIP_Set::lp_solutionpolishing"]
        [::std::mem::offset_of!(SCIP_Set, lp_solutionpolishing) - 1372usize];
    ["Offset of field: SCIP_Set::lp_refactorinterval"]
        [::std::mem::offset_of!(SCIP_Set, lp_refactorinterval) - 1376usize];
    ["Offset of field: SCIP_Set::lp_alwaysgetduals"]
        [::std::mem::offset_of!(SCIP_Set, lp_alwaysgetduals) - 1380usize];
    ["Offset of field: SCIP_Set::nlp_disable"]
        [::std::mem::offset_of!(SCIP_Set, nlp_disable) - 1384usize];
    ["Offset of field: SCIP_Set::nlp_solver"]
        [::std::mem::offset_of!(SCIP_Set, nlp_solver) - 1392usize];
    ["Offset of field: SCIP_Set::mem_savefac"]
        [::std::mem::offset_of!(SCIP_Set, mem_savefac) - 1400usize];
    ["Offset of field: SCIP_Set::mem_arraygrowfac"]
        [::std::mem::offset_of!(SCIP_Set, mem_arraygrowfac) - 1408usize];
    ["Offset of field: SCIP_Set::mem_treegrowfac"]
        [::std::mem::offset_of!(SCIP_Set, mem_treegrowfac) - 1416usize];
    ["Offset of field: SCIP_Set::mem_pathgrowfac"]
        [::std::mem::offset_of!(SCIP_Set, mem_pathgrowfac) - 1424usize];
    ["Offset of field: SCIP_Set::mem_arraygrowinit"]
        [::std::mem::offset_of!(SCIP_Set, mem_arraygrowinit) - 1432usize];
    ["Offset of field: SCIP_Set::mem_treegrowinit"]
        [::std::mem::offset_of!(SCIP_Set, mem_treegrowinit) - 1436usize];
    ["Offset of field: SCIP_Set::mem_pathgrowinit"]
        [::std::mem::offset_of!(SCIP_Set, mem_pathgrowinit) - 1440usize];
    ["Offset of field: SCIP_Set::misc_catchctrlc"]
        [::std::mem::offset_of!(SCIP_Set, misc_catchctrlc) - 1444usize];
    ["Offset of field: SCIP_Set::misc_usevartable"]
        [::std::mem::offset_of!(SCIP_Set, misc_usevartable) - 1448usize];
    ["Offset of field: SCIP_Set::misc_useconstable"]
        [::std::mem::offset_of!(SCIP_Set, misc_useconstable) - 1452usize];
    ["Offset of field: SCIP_Set::misc_usesmalltables"]
        [::std::mem::offset_of!(SCIP_Set, misc_usesmalltables) - 1456usize];
    ["Offset of field: SCIP_Set::misc_resetstat"]
        [::std::mem::offset_of!(SCIP_Set, misc_resetstat) - 1460usize];
    ["Offset of field: SCIP_Set::misc_improvingsols"]
        [::std::mem::offset_of!(SCIP_Set, misc_improvingsols) - 1464usize];
    ["Offset of field: SCIP_Set::misc_printreason"]
        [::std::mem::offset_of!(SCIP_Set, misc_printreason) - 1468usize];
    ["Offset of field: SCIP_Set::misc_estimexternmem"]
        [::std::mem::offset_of!(SCIP_Set, misc_estimexternmem) - 1472usize];
    ["Offset of field: SCIP_Set::misc_avoidmemout"]
        [::std::mem::offset_of!(SCIP_Set, misc_avoidmemout) - 1476usize];
    ["Offset of field: SCIP_Set::misc_transorigsols"]
        [::std::mem::offset_of!(SCIP_Set, misc_transorigsols) - 1480usize];
    ["Offset of field: SCIP_Set::misc_transsolsorig"]
        [::std::mem::offset_of!(SCIP_Set, misc_transsolsorig) - 1484usize];
    ["Offset of field: SCIP_Set::misc_calcintegral"]
        [::std::mem::offset_of!(SCIP_Set, misc_calcintegral) - 1488usize];
    ["Offset of field: SCIP_Set::misc_finitesolstore"]
        [::std::mem::offset_of!(SCIP_Set, misc_finitesolstore) - 1492usize];
    ["Offset of field: SCIP_Set::misc_outputorigsol"]
        [::std::mem::offset_of!(SCIP_Set, misc_outputorigsol) - 1496usize];
    ["Offset of field: SCIP_Set::misc_allowstrongdualreds"]
        [::std::mem::offset_of!(SCIP_Set, misc_allowstrongdualreds) - 1500usize];
    ["Offset of field: SCIP_Set::misc_allowweakdualreds"]
        [::std::mem::offset_of!(SCIP_Set, misc_allowweakdualreds) - 1504usize];
    ["Offset of field: SCIP_Set::misc_referencevalue"]
        [::std::mem::offset_of!(SCIP_Set, misc_referencevalue) - 1512usize];
    ["Offset of field: SCIP_Set::misc_usesymmetry"]
        [::std::mem::offset_of!(SCIP_Set, misc_usesymmetry) - 1520usize];
    ["Offset of field: SCIP_Set::misc_debugsol"]
        [::std::mem::offset_of!(SCIP_Set, misc_debugsol) - 1528usize];
    ["Offset of field: SCIP_Set::misc_scaleobj"]
        [::std::mem::offset_of!(SCIP_Set, misc_scaleobj) - 1536usize];
    ["Offset of field: SCIP_Set::misc_showdivingstats"]
        [::std::mem::offset_of!(SCIP_Set, misc_showdivingstats) - 1540usize];
    ["Offset of field: SCIP_Set::random_randomseedshift"]
        [::std::mem::offset_of!(SCIP_Set, random_randomseedshift) - 1544usize];
    ["Offset of field: SCIP_Set::random_randomseedshiftmultiplier"]
        [::std::mem::offset_of!(SCIP_Set, random_randomseedshiftmultiplier) - 1548usize];
    ["Offset of field: SCIP_Set::random_permutationseed"]
        [::std::mem::offset_of!(SCIP_Set, random_permutationseed) - 1552usize];
    ["Offset of field: SCIP_Set::random_randomseed"]
        [::std::mem::offset_of!(SCIP_Set, random_randomseed) - 1556usize];
    ["Offset of field: SCIP_Set::random_permuteconss"]
        [::std::mem::offset_of!(SCIP_Set, random_permuteconss) - 1560usize];
    ["Offset of field: SCIP_Set::random_permutevars"]
        [::std::mem::offset_of!(SCIP_Set, random_permutevars) - 1564usize];
    ["Offset of field: SCIP_Set::nodesel_childsel"]
        [::std::mem::offset_of!(SCIP_Set, nodesel_childsel) - 1568usize];
    ["Offset of field: SCIP_Set::num_infinity"]
        [::std::mem::offset_of!(SCIP_Set, num_infinity) - 1576usize];
    ["Offset of field: SCIP_Set::num_epsilon"]
        [::std::mem::offset_of!(SCIP_Set, num_epsilon) - 1584usize];
    ["Offset of field: SCIP_Set::num_sumepsilon"]
        [::std::mem::offset_of!(SCIP_Set, num_sumepsilon) - 1592usize];
    ["Offset of field: SCIP_Set::num_feastol"]
        [::std::mem::offset_of!(SCIP_Set, num_feastol) - 1600usize];
    ["Offset of field: SCIP_Set::num_checkfeastolfac"]
        [::std::mem::offset_of!(SCIP_Set, num_checkfeastolfac) - 1608usize];
    ["Offset of field: SCIP_Set::num_lpfeastolfactor"]
        [::std::mem::offset_of!(SCIP_Set, num_lpfeastolfactor) - 1616usize];
    ["Offset of field: SCIP_Set::num_dualfeastol"]
        [::std::mem::offset_of!(SCIP_Set, num_dualfeastol) - 1624usize];
    ["Offset of field: SCIP_Set::num_barrierconvtol"]
        [::std::mem::offset_of!(SCIP_Set, num_barrierconvtol) - 1632usize];
    ["Offset of field: SCIP_Set::num_boundstreps"]
        [::std::mem::offset_of!(SCIP_Set, num_boundstreps) - 1640usize];
    ["Offset of field: SCIP_Set::num_pseudocosteps"]
        [::std::mem::offset_of!(SCIP_Set, num_pseudocosteps) - 1648usize];
    ["Offset of field: SCIP_Set::num_pseudocostdelta"]
        [::std::mem::offset_of!(SCIP_Set, num_pseudocostdelta) - 1656usize];
    ["Offset of field: SCIP_Set::num_recompfac"]
        [::std::mem::offset_of!(SCIP_Set, num_recompfac) - 1664usize];
    ["Offset of field: SCIP_Set::num_hugeval"]
        [::std::mem::offset_of!(SCIP_Set, num_hugeval) - 1672usize];
    ["Offset of field: SCIP_Set::num_relaxfeastol"]
        [::std::mem::offset_of!(SCIP_Set, num_relaxfeastol) - 1680usize];
    ["Offset of field: SCIP_Set::presol_abortfac"]
        [::std::mem::offset_of!(SCIP_Set, presol_abortfac) - 1688usize];
    ["Offset of field: SCIP_Set::presol_maxrounds"]
        [::std::mem::offset_of!(SCIP_Set, presol_maxrounds) - 1696usize];
    ["Offset of field: SCIP_Set::presol_maxrestarts"]
        [::std::mem::offset_of!(SCIP_Set, presol_maxrestarts) - 1700usize];
    ["Offset of field: SCIP_Set::presol_clqtablefac"]
        [::std::mem::offset_of!(SCIP_Set, presol_clqtablefac) - 1704usize];
    ["Offset of field: SCIP_Set::presol_restartfac"]
        [::std::mem::offset_of!(SCIP_Set, presol_restartfac) - 1712usize];
    ["Offset of field: SCIP_Set::presol_immrestartfac"]
        [::std::mem::offset_of!(SCIP_Set, presol_immrestartfac) - 1720usize];
    ["Offset of field: SCIP_Set::presol_subrestartfac"]
        [::std::mem::offset_of!(SCIP_Set, presol_subrestartfac) - 1728usize];
    ["Offset of field: SCIP_Set::presol_restartminred"]
        [::std::mem::offset_of!(SCIP_Set, presol_restartminred) - 1736usize];
    ["Offset of field: SCIP_Set::presol_donotmultaggr"]
        [::std::mem::offset_of!(SCIP_Set, presol_donotmultaggr) - 1744usize];
    ["Offset of field: SCIP_Set::presol_donotaggr"]
        [::std::mem::offset_of!(SCIP_Set, presol_donotaggr) - 1748usize];
    ["Offset of field: SCIP_Set::price_abortfac"]
        [::std::mem::offset_of!(SCIP_Set, price_abortfac) - 1752usize];
    ["Offset of field: SCIP_Set::price_maxvars"]
        [::std::mem::offset_of!(SCIP_Set, price_maxvars) - 1760usize];
    ["Offset of field: SCIP_Set::price_maxvarsroot"]
        [::std::mem::offset_of!(SCIP_Set, price_maxvarsroot) - 1764usize];
    ["Offset of field: SCIP_Set::price_delvars"]
        [::std::mem::offset_of!(SCIP_Set, price_delvars) - 1768usize];
    ["Offset of field: SCIP_Set::price_delvarsroot"]
        [::std::mem::offset_of!(SCIP_Set, price_delvarsroot) - 1772usize];
    ["Offset of field: SCIP_Set::decomp_benderslabels"]
        [::std::mem::offset_of!(SCIP_Set, decomp_benderslabels) - 1776usize];
    ["Offset of field: SCIP_Set::decomp_applybenders"]
        [::std::mem::offset_of!(SCIP_Set, decomp_applybenders) - 1780usize];
    ["Offset of field: SCIP_Set::decomp_maxgraphedge"]
        [::std::mem::offset_of!(SCIP_Set, decomp_maxgraphedge) - 1784usize];
    ["Offset of field: SCIP_Set::decomp_disablemeasures"]
        [::std::mem::offset_of!(SCIP_Set, decomp_disablemeasures) - 1788usize];
    ["Offset of field: SCIP_Set::benders_soltol"]
        [::std::mem::offset_of!(SCIP_Set, benders_soltol) - 1792usize];
    ["Offset of field: SCIP_Set::benders_cutlpsol"]
        [::std::mem::offset_of!(SCIP_Set, benders_cutlpsol) - 1800usize];
    ["Offset of field: SCIP_Set::benders_copybenders"]
        [::std::mem::offset_of!(SCIP_Set, benders_copybenders) - 1804usize];
    ["Offset of field: SCIP_Set::prop_maxrounds"]
        [::std::mem::offset_of!(SCIP_Set, prop_maxrounds) - 1808usize];
    ["Offset of field: SCIP_Set::prop_maxroundsroot"]
        [::std::mem::offset_of!(SCIP_Set, prop_maxroundsroot) - 1812usize];
    ["Offset of field: SCIP_Set::prop_abortoncutoff"]
        [::std::mem::offset_of!(SCIP_Set, prop_abortoncutoff) - 1816usize];
    ["Offset of field: SCIP_Set::reopt_objsimsol"]
        [::std::mem::offset_of!(SCIP_Set, reopt_objsimsol) - 1824usize];
    ["Offset of field: SCIP_Set::reopt_objsimrootlp"]
        [::std::mem::offset_of!(SCIP_Set, reopt_objsimrootlp) - 1832usize];
    ["Offset of field: SCIP_Set::reopt_objsimdelay"]
        [::std::mem::offset_of!(SCIP_Set, reopt_objsimdelay) - 1840usize];
    ["Offset of field: SCIP_Set::reopt_varorderinterdiction"]
        [::std::mem::offset_of!(SCIP_Set, reopt_varorderinterdiction) - 1848usize];
    ["Offset of field: SCIP_Set::reopt_forceheurrestart"]
        [::std::mem::offset_of!(SCIP_Set, reopt_forceheurrestart) - 1852usize];
    ["Offset of field: SCIP_Set::reopt_maxcutage"]
        [::std::mem::offset_of!(SCIP_Set, reopt_maxcutage) - 1856usize];
    ["Offset of field: SCIP_Set::reopt_maxdiffofnodes"]
        [::std::mem::offset_of!(SCIP_Set, reopt_maxdiffofnodes) - 1860usize];
    ["Offset of field: SCIP_Set::reopt_maxsavednodes"]
        [::std::mem::offset_of!(SCIP_Set, reopt_maxsavednodes) - 1864usize];
    ["Offset of field: SCIP_Set::reopt_solvelp"]
        [::std::mem::offset_of!(SCIP_Set, reopt_solvelp) - 1868usize];
    ["Offset of field: SCIP_Set::reopt_solvelpdiff"]
        [::std::mem::offset_of!(SCIP_Set, reopt_solvelpdiff) - 1872usize];
    ["Offset of field: SCIP_Set::reopt_savesols"]
        [::std::mem::offset_of!(SCIP_Set, reopt_savesols) - 1876usize];
    ["Offset of field: SCIP_Set::reopt_commontimelimit"]
        [::std::mem::offset_of!(SCIP_Set, reopt_commontimelimit) - 1880usize];
    ["Offset of field: SCIP_Set::reopt_enable"]
        [::std::mem::offset_of!(SCIP_Set, reopt_enable) - 1884usize];
    ["Offset of field: SCIP_Set::reopt_reducetofrontier"]
        [::std::mem::offset_of!(SCIP_Set, reopt_reducetofrontier) - 1888usize];
    ["Offset of field: SCIP_Set::reopt_saveprop"]
        [::std::mem::offset_of!(SCIP_Set, reopt_saveprop) - 1892usize];
    ["Offset of field: SCIP_Set::reopt_sbinit"]
        [::std::mem::offset_of!(SCIP_Set, reopt_sbinit) - 1896usize];
    ["Offset of field: SCIP_Set::reopt_shrinkinner"]
        [::std::mem::offset_of!(SCIP_Set, reopt_shrinkinner) - 1900usize];
    ["Offset of field: SCIP_Set::reopt_sepaglbinfsubtrees"]
        [::std::mem::offset_of!(SCIP_Set, reopt_sepaglbinfsubtrees) - 1904usize];
    ["Offset of field: SCIP_Set::reopt_sepabestsol"]
        [::std::mem::offset_of!(SCIP_Set, reopt_sepabestsol) - 1908usize];
    ["Offset of field: SCIP_Set::reopt_storevarhistory"]
        [::std::mem::offset_of!(SCIP_Set, reopt_storevarhistory) - 1912usize];
    ["Offset of field: SCIP_Set::reopt_usepscost"]
        [::std::mem::offset_of!(SCIP_Set, reopt_usepscost) - 1916usize];
    ["Offset of field: SCIP_Set::reopt_usecuts"]
        [::std::mem::offset_of!(SCIP_Set, reopt_usecuts) - 1920usize];
    ["Offset of field: SCIP_Set::reopt_usesplitcons"]
        [::std::mem::offset_of!(SCIP_Set, reopt_usesplitcons) - 1924usize];
    ["Offset of field: SCIP_Set::sepa_maxbounddist"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxbounddist) - 1928usize];
    ["Offset of field: SCIP_Set::sepa_maxlocalbounddist"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxlocalbounddist) - 1936usize];
    ["Offset of field: SCIP_Set::sepa_maxcoefratio"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcoefratio) - 1944usize];
    ["Offset of field: SCIP_Set::sepa_maxcoefratiofacrowprep"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcoefratiofacrowprep) - 1952usize];
    ["Offset of field: SCIP_Set::sepa_minefficacy"]
        [::std::mem::offset_of!(SCIP_Set, sepa_minefficacy) - 1960usize];
    ["Offset of field: SCIP_Set::sepa_minefficacyroot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_minefficacyroot) - 1968usize];
    ["Offset of field: SCIP_Set::sepa_minortho"]
        [::std::mem::offset_of!(SCIP_Set, sepa_minortho) - 1976usize];
    ["Offset of field: SCIP_Set::sepa_minorthoroot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_minorthoroot) - 1984usize];
    ["Offset of field: SCIP_Set::sepa_minactivityquot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_minactivityquot) - 1992usize];
    ["Offset of field: SCIP_Set::sepa_orthofunc"]
        [::std::mem::offset_of!(SCIP_Set, sepa_orthofunc) - 2000usize];
    ["Offset of field: SCIP_Set::sepa_efficacynorm"]
        [::std::mem::offset_of!(SCIP_Set, sepa_efficacynorm) - 2001usize];
    ["Offset of field: SCIP_Set::sepa_cutselrestart"]
        [::std::mem::offset_of!(SCIP_Set, sepa_cutselrestart) - 2002usize];
    ["Offset of field: SCIP_Set::sepa_cutselsubscip"]
        [::std::mem::offset_of!(SCIP_Set, sepa_cutselsubscip) - 2003usize];
    ["Offset of field: SCIP_Set::sepa_filtercutpoolrel"]
        [::std::mem::offset_of!(SCIP_Set, sepa_filtercutpoolrel) - 2004usize];
    ["Offset of field: SCIP_Set::sepa_maxruns"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxruns) - 2008usize];
    ["Offset of field: SCIP_Set::sepa_maxrounds"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxrounds) - 2012usize];
    ["Offset of field: SCIP_Set::sepa_maxroundsroot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxroundsroot) - 2016usize];
    ["Offset of field: SCIP_Set::sepa_maxroundsrootsubrun"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxroundsrootsubrun) - 2020usize];
    ["Offset of field: SCIP_Set::sepa_maxaddrounds"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxaddrounds) - 2024usize];
    ["Offset of field: SCIP_Set::sepa_maxstallrounds"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxstallrounds) - 2028usize];
    ["Offset of field: SCIP_Set::sepa_maxstallroundsroot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxstallroundsroot) - 2032usize];
    ["Offset of field: SCIP_Set::sepa_maxcutsgenfactor"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcutsgenfactor) - 2040usize];
    ["Offset of field: SCIP_Set::sepa_maxcutsrootgenfactor"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcutsrootgenfactor) - 2048usize];
    ["Offset of field: SCIP_Set::sepa_maxcuts"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcuts) - 2056usize];
    ["Offset of field: SCIP_Set::sepa_maxcutsroot"]
        [::std::mem::offset_of!(SCIP_Set, sepa_maxcutsroot) - 2060usize];
    ["Offset of field: SCIP_Set::sepa_cutagelimit"]
        [::std::mem::offset_of!(SCIP_Set, sepa_cutagelimit) - 2064usize];
    ["Offset of field: SCIP_Set::sepa_poolfreq"]
        [::std::mem::offset_of!(SCIP_Set, sepa_poolfreq) - 2068usize];
    ["Offset of field: SCIP_Set::parallel_mode"]
        [::std::mem::offset_of!(SCIP_Set, parallel_mode) - 2072usize];
    ["Offset of field: SCIP_Set::parallel_minnthreads"]
        [::std::mem::offset_of!(SCIP_Set, parallel_minnthreads) - 2076usize];
    ["Offset of field: SCIP_Set::parallel_maxnthreads"]
        [::std::mem::offset_of!(SCIP_Set, parallel_maxnthreads) - 2080usize];
    ["Offset of field: SCIP_Set::concurrent_changeseeds"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_changeseeds) - 2084usize];
    ["Offset of field: SCIP_Set::concurrent_changechildsel"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_changechildsel) - 2088usize];
    ["Offset of field: SCIP_Set::concurrent_commvarbnds"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_commvarbnds) - 2092usize];
    ["Offset of field: SCIP_Set::concurrent_presolvebefore"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_presolvebefore) - 2096usize];
    ["Offset of field: SCIP_Set::concurrent_initseed"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_initseed) - 2100usize];
    ["Offset of field: SCIP_Set::concurrent_freqinit"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_freqinit) - 2104usize];
    ["Offset of field: SCIP_Set::concurrent_freqmax"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_freqmax) - 2112usize];
    ["Offset of field: SCIP_Set::concurrent_freqfactor"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_freqfactor) - 2120usize];
    ["Offset of field: SCIP_Set::concurrent_targetprogress"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_targetprogress) - 2128usize];
    ["Offset of field: SCIP_Set::concurrent_maxnsols"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_maxnsols) - 2136usize];
    ["Offset of field: SCIP_Set::concurrent_nbestsols"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_nbestsols) - 2140usize];
    ["Offset of field: SCIP_Set::concurrent_maxnsyncdelay"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_maxnsyncdelay) - 2144usize];
    ["Offset of field: SCIP_Set::concurrent_minsyncdelay"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_minsyncdelay) - 2152usize];
    ["Offset of field: SCIP_Set::concurrent_paramsetprefix"]
        [::std::mem::offset_of!(SCIP_Set, concurrent_paramsetprefix) - 2160usize];
    ["Offset of field: SCIP_Set::time_clocktype"]
        [::std::mem::offset_of!(SCIP_Set, time_clocktype) - 2168usize];
    ["Offset of field: SCIP_Set::time_enabled"]
        [::std::mem::offset_of!(SCIP_Set, time_enabled) - 2172usize];
    ["Offset of field: SCIP_Set::time_reading"]
        [::std::mem::offset_of!(SCIP_Set, time_reading) - 2176usize];
    ["Offset of field: SCIP_Set::time_rareclockcheck"]
        [::std::mem::offset_of!(SCIP_Set, time_rareclockcheck) - 2180usize];
    ["Offset of field: SCIP_Set::time_statistictiming"]
        [::std::mem::offset_of!(SCIP_Set, time_statistictiming) - 2184usize];
    ["Offset of field: SCIP_Set::time_nlpieval"]
        [::std::mem::offset_of!(SCIP_Set, time_nlpieval) - 2188usize];
    ["Offset of field: SCIP_Set::compr_enable"]
        [::std::mem::offset_of!(SCIP_Set, compr_enable) - 2192usize];
    ["Offset of field: SCIP_Set::compr_time"]
        [::std::mem::offset_of!(SCIP_Set, compr_time) - 2200usize];
    ["Offset of field: SCIP_Set::visual_vbcfilename"]
        [::std::mem::offset_of!(SCIP_Set, visual_vbcfilename) - 2208usize];
    ["Offset of field: SCIP_Set::visual_bakfilename"]
        [::std::mem::offset_of!(SCIP_Set, visual_bakfilename) - 2216usize];
    ["Offset of field: SCIP_Set::visual_realtime"]
        [::std::mem::offset_of!(SCIP_Set, visual_realtime) - 2224usize];
    ["Offset of field: SCIP_Set::visual_dispsols"]
        [::std::mem::offset_of!(SCIP_Set, visual_dispsols) - 2228usize];
    ["Offset of field: SCIP_Set::visual_displb"]
        [::std::mem::offset_of!(SCIP_Set, visual_displb) - 2232usize];
    ["Offset of field: SCIP_Set::visual_objextern"]
        [::std::mem::offset_of!(SCIP_Set, visual_objextern) - 2236usize];
    ["Offset of field: SCIP_Set::exact_enable"]
        [::std::mem::offset_of!(SCIP_Set, exact_enable) - 2240usize];
    ["Offset of field: SCIP_Set::exact_improvingsols"]
        [::std::mem::offset_of!(SCIP_Set, exact_improvingsols) - 2244usize];
    ["Offset of field: SCIP_Set::exact_interleavedbstrat"]
        [::std::mem::offset_of!(SCIP_Set, exact_interleavedbstrat) - 2248usize];
    ["Offset of field: SCIP_Set::exact_safedbmethod"]
        [::std::mem::offset_of!(SCIP_Set, exact_safedbmethod) - 2252usize];
    ["Offset of field: SCIP_Set::exact_psdualcolselection"]
        [::std::mem::offset_of!(SCIP_Set, exact_psdualcolselection) - 2256usize];
    ["Offset of field: SCIP_Set::exact_lpinfo"]
        [::std::mem::offset_of!(SCIP_Set, exact_lpinfo) - 2260usize];
    ["Offset of field: SCIP_Set::exact_allownegslack"]
        [::std::mem::offset_of!(SCIP_Set, exact_allownegslack) - 2264usize];
    ["Offset of field: SCIP_Set::exact_cutmaxdenom"]
        [::std::mem::offset_of!(SCIP_Set, exact_cutmaxdenom) - 2272usize];
    ["Offset of field: SCIP_Set::exact_cutapproxmaxboundval"]
        [::std::mem::offset_of!(SCIP_Set, exact_cutapproxmaxboundval) - 2280usize];
    ["Offset of field: SCIP_Set::certificate_filename"]
        [::std::mem::offset_of!(SCIP_Set, certificate_filename) - 2288usize];
    ["Offset of field: SCIP_Set::certificate_maxfilesize"]
        [::std::mem::offset_of!(SCIP_Set, certificate_maxfilesize) - 2296usize];
    ["Offset of field: SCIP_Set::read_initialconss"]
        [::std::mem::offset_of!(SCIP_Set, read_initialconss) - 2304usize];
    ["Offset of field: SCIP_Set::read_dynamicconss"]
        [::std::mem::offset_of!(SCIP_Set, read_dynamicconss) - 2308usize];
    ["Offset of field: SCIP_Set::read_dynamiccols"]
        [::std::mem::offset_of!(SCIP_Set, read_dynamiccols) - 2312usize];
    ["Offset of field: SCIP_Set::read_dynamicrows"]
        [::std::mem::offset_of!(SCIP_Set, read_dynamicrows) - 2316usize];
    ["Offset of field: SCIP_Set::write_allconss"]
        [::std::mem::offset_of!(SCIP_Set, write_allconss) - 2320usize];
    ["Offset of field: SCIP_Set::write_printzeros"]
        [::std::mem::offset_of!(SCIP_Set, write_printzeros) - 2324usize];
    ["Offset of field: SCIP_Set::write_genoffset"]
        [::std::mem::offset_of!(SCIP_Set, write_genoffset) - 2328usize];
    ["Offset of field: SCIP_Set::write_implintlevel"]
        [::std::mem::offset_of!(SCIP_Set, write_implintlevel) - 2332usize];
};
unsafe extern "C" {
    #[doc = " copies plugins from sourcescip to targetscip; in case that a constraint handler which does not need constraints\n  cannot be copied, valid will return FALSE. All plugins can declare that, if their copy process failed, the\n  copied SCIP instance might not represent the same problem semantics as the original.\n  Note that in this case dual reductions might be invalid."]
    pub fn SCIPsetCopyPlugins(
        sourceset: *mut SCIP_SET,
        targetset: *mut SCIP_SET,
        copyreaders: ::std::os::raw::c_uint,
        copypricers: ::std::os::raw::c_uint,
        copyconshdlrs: ::std::os::raw::c_uint,
        copyconflicthdlrs: ::std::os::raw::c_uint,
        copypresolvers: ::std::os::raw::c_uint,
        copyrelaxators: ::std::os::raw::c_uint,
        copyseparators: ::std::os::raw::c_uint,
        copycutselectors: ::std::os::raw::c_uint,
        copypropagators: ::std::os::raw::c_uint,
        copyheuristics: ::std::os::raw::c_uint,
        copyeventhdlrs: ::std::os::raw::c_uint,
        copynodeselectors: ::std::os::raw::c_uint,
        copybranchrules: ::std::os::raw::c_uint,
        copyiisfinders: ::std::os::raw::c_uint,
        copydisplays: ::std::os::raw::c_uint,
        copydialogs: ::std::os::raw::c_uint,
        copytables: ::std::os::raw::c_uint,
        copyexprhdlrs: ::std::os::raw::c_uint,
        copynlpis: ::std::os::raw::c_uint,
        allvalid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies parameters from sourcescip to targetscip"]
    pub fn SCIPsetCopyParams(
        sourceset: *mut SCIP_SET,
        targetset: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates global SCIP settings"]
    pub fn SCIPsetCreate(
        set: *mut *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        scip: *mut SCIP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees global SCIP settings"]
    pub fn SCIPsetFree(set: *mut *mut SCIP_SET, blkmem: *mut BMS_BLKMEM) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns current stage of SCIP"]
    pub fn SCIPsetGetStage(set: *mut SCIP_SET) -> SCIP_STAGE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Bool parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddBoolParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_uint,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_uint,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a int parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddIntParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_int,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_int,
        minvalue: ::std::os::raw::c_int,
        maxvalue: ::std::os::raw::c_int,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Longint parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddLongintParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_longlong,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_longlong,
        minvalue: ::std::os::raw::c_longlong,
        maxvalue: ::std::os::raw::c_longlong,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP_Real parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddRealParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut f64,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: f64,
        minvalue: f64,
        maxvalue: f64,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a char parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddCharParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_char,
        allowedvalues: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a string parameter, sets it to its default value, and adds it to the parameter set"]
    pub fn SCIPsetAddStringParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the fixing status value of an existing parameter"]
    pub fn SCIPsetIsParamFixed(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the pointer to the SCIP parameter with the given name"]
    pub fn SCIPsetGetParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_PARAM;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Bool parameter"]
    pub fn SCIPsetGetBoolParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing Int parameter"]
    pub fn SCIPsetGetIntParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Longint parameter"]
    pub fn SCIPsetGetLongintParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing SCIP_Real parameter"]
    pub fn SCIPsetGetRealParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing Char parameter"]
    pub fn SCIPsetGetCharParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets the value of an existing String parameter"]
    pub fn SCIPsetGetStringParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the fixing status of an existing parameter"]
    pub fn SCIPsetChgParamFixed(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        fixed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter"]
    pub fn SCIPsetChgBoolParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter"]
    pub fn SCIPsetSetBoolParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the default value of an existing SCIP_Bool parameter"]
    pub fn SCIPsetSetDefaultBoolParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        defaultvalue: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing Int parameter"]
    pub fn SCIPsetChgIntParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing Int parameter"]
    pub fn SCIPsetSetIntParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the default value of an existing Int parameter"]
    pub fn SCIPsetSetDefaultIntParam(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        defaultvalue: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter"]
    pub fn SCIPsetChgLongintParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter"]
    pub fn SCIPsetSetLongintParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter"]
    pub fn SCIPsetChgRealParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter"]
    pub fn SCIPsetSetRealParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing Char parameter"]
    pub fn SCIPsetChgCharParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing Char parameter"]
    pub fn SCIPsetSetCharParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing String parameter"]
    pub fn SCIPsetChgStringParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing String parameter"]
    pub fn SCIPsetSetStringParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes the value of an existing parameter"]
    pub fn SCIPsetSetParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads parameters from a file"]
    pub fn SCIPsetReadParams(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        filename: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes all parameters in the parameter set to a file"]
    pub fn SCIPsetWriteParams(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets a single parameters to its default value"]
    pub fn SCIPsetResetParam(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " resets all parameters to their default values"]
    pub fn SCIPsetResetParams(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether the value pointers attached to each parameter are unique\n\n  When creating a parameter a value pointer can be attached. This function checks whether these pointers are\n  unique. Duplicate pointers indicate an error."]
    pub fn SCIPsetCheckParamValuePtrUnique(set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets parameters to\n\n  - \\ref SCIP_PARAMEMPHASIS_DEFAULT to use default values (see also SCIPsetResetParams())\n  - \\ref SCIP_PARAMEMPHASIS_COUNTER to get feasible and \"fast\" counting process\n  - \\ref SCIP_PARAMEMPHASIS_CPSOLVER to get CP like search (e.g. no LP relaxation)\n  - \\ref SCIP_PARAMEMPHASIS_EASYCIP to solve easy problems fast\n  - \\ref SCIP_PARAMEMPHASIS_FEASIBILITY to detect feasibility fast\n  - \\ref SCIP_PARAMEMPHASIS_HARDLP to be capable to handle hard LPs\n  - \\ref SCIP_PARAMEMPHASIS_OPTIMALITY to prove optimality fast\n  - \\ref SCIP_PARAMEMPHASIS_PHASEFEAS to find feasible solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEIMPROVE to find improved solutions during a 3 phase solution process\n  - \\ref SCIP_PARAMEMPHASIS_PHASEPROOF to proof optimality during a 3 phase solution process"]
    pub fn SCIPsetSetEmphasis(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        paramemphasis: SCIP_PARAMEMPHASIS,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set parameters for reoptimization"]
    pub fn SCIPsetSetReoptimizationParams(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " enable or disable all plugin timers depending on the value of the flag \\p enabled"]
    pub fn SCIPsetEnableOrDisablePluginClocks(set: *mut SCIP_SET, enabled: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " sets parameters to deactivate separators and heuristics that use auxiliary SCIP instances; should be called for\n  auxiliary SCIP instances to avoid recursion"]
    pub fn SCIPsetSetSubscipsOff(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets heuristic parameters values to\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all heuristic parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for heuristic is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the heuristic are called more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all heuristics"]
    pub fn SCIPsetSetHeuristics(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets presolving parameters to\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all presolving parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for presolving is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the presolving is more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all presolving"]
    pub fn SCIPsetSetPresolving(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets separating parameters to\n  - SCIP_PARAMSETTING_DEFAULT which are the default values of all separating parameters\n  - SCIP_PARAMSETTING_FAST such that the time spend for separating is decreased\n  - SCIP_PARAMSETTING_AGGRESSIVE such that the separating is done more aggregative\n  - SCIP_PARAMSETTING_OFF which turn off all separating"]
    pub fn SCIPsetSetSeparating(
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the array of all available SCIP parameters"]
    pub fn SCIPsetGetParams(set: *mut SCIP_SET) -> *mut *mut SCIP_PARAM;
}
unsafe extern "C" {
    #[doc = " returns the total number of all available SCIP parameters"]
    pub fn SCIPsetGetNParams(set: *mut SCIP_SET) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " inserts file reader in file reader list"]
    pub fn SCIPsetIncludeReader(set: *mut SCIP_SET, reader: *mut SCIP_READER) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the file reader of the given name, or NULL if not existing"]
    pub fn SCIPsetFindReader(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_READER;
}
unsafe extern "C" {
    #[doc = " inserts variable pricer in variable pricer list"]
    pub fn SCIPsetIncludePricer(set: *mut SCIP_SET, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the variable pricer of the given name, or NULL if not existing"]
    pub fn SCIPsetFindPricer(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_PRICER;
}
unsafe extern "C" {
    #[doc = " sorts pricers by priorities"]
    pub fn SCIPsetSortPricers(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts pricers by name"]
    pub fn SCIPsetSortPricersName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts Benders' decomposition into the Benders' decomposition list"]
    pub fn SCIPsetIncludeBenders(set: *mut SCIP_SET, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the Benders' decomposition of the given name, or NULL if not existing"]
    pub fn SCIPsetFindBenders(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERS;
}
unsafe extern "C" {
    #[doc = " sorts Benders' decomposition by priorities"]
    pub fn SCIPsetSortBenders(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts Benders' decomposition by name"]
    pub fn SCIPsetSortBendersName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts constraint handler in constraint handler list"]
    pub fn SCIPsetIncludeConshdlr(set: *mut SCIP_SET, conshdlr: *mut SCIP_CONSHDLR)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reinserts a constraint handler with modified sepa priority into the sepa priority sorted array"]
    pub fn SCIPsetReinsertConshdlrSepaPrio(
        set: *mut SCIP_SET,
        conshdlr: *mut SCIP_CONSHDLR,
        oldpriority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the constraint handler of the given name, or NULL if not existing"]
    pub fn SCIPsetFindConshdlr(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONSHDLR;
}
unsafe extern "C" {
    #[doc = " inserts conflict handler in conflict handler list"]
    pub fn SCIPsetIncludeConflicthdlr(
        set: *mut SCIP_SET,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the conflict handler of the given name, or NULL if not existing"]
    pub fn SCIPsetFindConflicthdlr(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONFLICTHDLR;
}
unsafe extern "C" {
    #[doc = " sorts conflict handlers by priorities"]
    pub fn SCIPsetSortConflicthdlrs(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts conflict handlers by name"]
    pub fn SCIPsetSortConflicthdlrsName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts presolver in presolver list"]
    pub fn SCIPsetIncludePresol(set: *mut SCIP_SET, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the presolver of the given name, or NULL if not existing"]
    pub fn SCIPsetFindPresol(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_PRESOL;
}
unsafe extern "C" {
    #[doc = " sorts presolvers by priorities"]
    pub fn SCIPsetSortPresols(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts presolvers by name"]
    pub fn SCIPsetSortPresolsName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts relaxator in relaxator list"]
    pub fn SCIPsetIncludeRelax(set: *mut SCIP_SET, relax: *mut SCIP_RELAX) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the relaxator of the given name, or NULL if not existing"]
    pub fn SCIPsetFindRelax(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_RELAX;
}
unsafe extern "C" {
    #[doc = " sorts relaxators by priorities"]
    pub fn SCIPsetSortRelaxs(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts relaxators by name"]
    pub fn SCIPsetSortRelaxsName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts separator in separator list"]
    pub fn SCIPsetIncludeSepa(set: *mut SCIP_SET, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the separator of the given name, or NULL if not existing"]
    pub fn SCIPsetFindSepa(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_SEPA;
}
unsafe extern "C" {
    #[doc = " sorts separators by priorities"]
    pub fn SCIPsetSortSepas(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts separators by name"]
    pub fn SCIPsetSortSepasName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts cut selector in cut selector list"]
    pub fn SCIPsetIncludeCutsel(set: *mut SCIP_SET, cutsel: *mut SCIP_CUTSEL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the cut selector of the given name, or NULL if not existing"]
    pub fn SCIPsetFindCutsel(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CUTSEL;
}
unsafe extern "C" {
    #[doc = " sorts cut selectors by priorities"]
    pub fn SCIPsetSortCutsels(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts propagator in propagator list"]
    pub fn SCIPsetIncludeProp(set: *mut SCIP_SET, prop: *mut SCIP_PROP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the propagator of the given name, or NULL if not existing"]
    pub fn SCIPsetFindProp(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_PROP;
}
unsafe extern "C" {
    #[doc = " sorts propagators by priorities"]
    pub fn SCIPsetSortProps(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts propagators by priorities for presolving"]
    pub fn SCIPsetSortPropsPresol(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts propagators w.r.t. names"]
    pub fn SCIPsetSortPropsName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts concurrent solver type into the concurrent solver type list"]
    pub fn SCIPsetIncludeConcsolverType(
        set: *mut SCIP_SET,
        concsolvertype: *mut SCIP_CONCSOLVERTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the concurrent solver type with the given name, or NULL if not existing"]
    pub fn SCIPsetFindConcsolverType(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONCSOLVERTYPE;
}
unsafe extern "C" {
    #[doc = " inserts concurrent solver into the concurrent solver list"]
    pub fn SCIPsetIncludeConcsolver(
        set: *mut SCIP_SET,
        concsolver: *mut SCIP_CONCSOLVER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees all concurrent solvers in the concurrent solver list"]
    pub fn SCIPsetFreeConcsolvers(set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts primal heuristic in primal heuristic list"]
    pub fn SCIPsetIncludeHeur(set: *mut SCIP_SET, heur: *mut SCIP_HEUR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the primal heuristic of the given name, or NULL if not existing"]
    pub fn SCIPsetFindHeur(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_HEUR;
}
unsafe extern "C" {
    #[doc = " sorts heuristics by priorities"]
    pub fn SCIPsetSortHeurs(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts heuristics by name"]
    pub fn SCIPsetSortHeursName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts tree compression in tree compression list"]
    pub fn SCIPsetIncludeCompr(set: *mut SCIP_SET, compr: *mut SCIP_COMPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the tree compression of the given name, or NULL if not existing"]
    pub fn SCIPsetFindCompr(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_COMPR;
}
unsafe extern "C" {
    #[doc = " sorts compressions by priorities"]
    pub fn SCIPsetSortComprs(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts heuristics by names"]
    pub fn SCIPsetSortComprsName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts event handler in event handler list"]
    pub fn SCIPsetIncludeEventhdlr(
        set: *mut SCIP_SET,
        eventhdlr: *mut SCIP_EVENTHDLR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the event handler of the given name, or NULL if not existing"]
    pub fn SCIPsetFindEventhdlr(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EVENTHDLR;
}
unsafe extern "C" {
    #[doc = " inserts node selector in node selector list"]
    pub fn SCIPsetIncludeNodesel(set: *mut SCIP_SET, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the node selector of the given name, or NULL if not existing"]
    pub fn SCIPsetFindNodesel(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " returns node selector with highest priority in the current mode"]
    pub fn SCIPsetGetNodesel(set: *mut SCIP_SET, stat: *mut SCIP_STAT) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " inserts branching rule in branching rule list"]
    pub fn SCIPsetIncludeBranchrule(
        set: *mut SCIP_SET,
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the branching rule of the given name, or NULL if not existing"]
    pub fn SCIPsetFindBranchrule(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BRANCHRULE;
}
unsafe extern "C" {
    #[doc = " sorts branching rules by priorities"]
    pub fn SCIPsetSortBranchrules(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " sorts branching rules by name"]
    pub fn SCIPsetSortBranchrulesName(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts IIS finders in IIS finder list"]
    pub fn SCIPsetIncludeIISfinder(
        set: *mut SCIP_SET,
        iisfinder: *mut SCIP_IISFINDER,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the IIS finder of the given name, or NULL if not existing"]
    pub fn SCIPsetFindIISfinder(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_IISFINDER;
}
unsafe extern "C" {
    #[doc = " sorts the IIS finders by priorities"]
    pub fn SCIPsetSortIISfinders(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts display column in display column list"]
    pub fn SCIPsetIncludeDisp(set: *mut SCIP_SET, disp: *mut SCIP_DISP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the display column of the given name, or NULL if not existing"]
    pub fn SCIPsetFindDisp(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_DISP;
}
unsafe extern "C" {
    #[doc = " inserts statistics table in statistics table list"]
    pub fn SCIPsetIncludeTable(set: *mut SCIP_SET, table: *mut SCIP_TABLE) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the statistics table of the given name, or NULL if not existing"]
    pub fn SCIPsetFindTable(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_TABLE;
}
unsafe extern "C" {
    #[doc = " inserts dialog in dialog list"]
    pub fn SCIPsetIncludeDialog(set: *mut SCIP_SET, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns if the dialog already exists"]
    pub fn SCIPsetExistsDialog(
        set: *mut SCIP_SET,
        dialog: *mut SCIP_DIALOG,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " inserts expression handler in expression handler list"]
    pub fn SCIPsetIncludeExprhdlr(set: *mut SCIP_SET, exprhdlr: *mut SCIP_EXPRHDLR)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the expression handler of the given name, or NULL if not existing"]
    pub fn SCIPsetFindExprhdlr(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EXPRHDLR;
}
unsafe extern "C" {
    #[doc = " sorts expression handlers by name"]
    pub fn SCIPsetSortExprhdlrs(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " inserts NLPI in NLPI list"]
    pub fn SCIPsetIncludeNlpi(set: *mut SCIP_SET, nlpi: *mut SCIP_NLPI) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the NLPI of the given name, or NULL if not existing"]
    pub fn SCIPsetFindNlpi(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NLPI;
}
unsafe extern "C" {
    #[doc = " sorts NLPIs by priorities"]
    pub fn SCIPsetSortNlpis(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " set priority of an NLPI"]
    pub fn SCIPsetSetPriorityNlpi(
        set: *mut SCIP_SET,
        nlpi: *mut SCIP_NLPI,
        priority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " inserts information about an external code in external codes list"]
    pub fn SCIPsetIncludeExternalCode(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " inserts bandit virtual function table into set"]
    pub fn SCIPsetIncludeBanditvtable(
        set: *mut SCIP_SET,
        banditvtable: *mut SCIP_BANDITVTABLE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the bandit virtual function table of the given name, or NULL if not existing"]
    pub fn SCIPsetFindBanditvtable(
        set: *mut SCIP_SET,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BANDITVTABLE;
}
unsafe extern "C" {
    #[doc = " calls init methods of all plugins"]
    pub fn SCIPsetInitPlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls exit methods of all plugins"]
    pub fn SCIPsetExitPlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls initpre methods of all plugins"]
    pub fn SCIPsetInitprePlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls exitpre methods of all plugins"]
    pub fn SCIPsetExitprePlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls initsol methods of all plugins"]
    pub fn SCIPsetInitsolPlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calls exitsol methods of all plugins"]
    pub fn SCIPsetExitsolPlugins(
        set: *mut SCIP_SET,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
        restart: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculate memory size for dynamically allocated arrays"]
    pub fn SCIPsetCalcMemGrowSize(
        set: *mut SCIP_SET,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " calculate memory size for tree array"]
    pub fn SCIPsetCalcTreeGrowSize(
        set: *mut SCIP_SET,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " calculate memory size for path array"]
    pub fn SCIPsetCalcPathGrowSize(
        set: *mut SCIP_SET,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets verbosity level for message output"]
    pub fn SCIPsetSetVerbLevel(set: *mut SCIP_SET, verblevel: SCIP_VERBLEVEL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets feasibility tolerance"]
    pub fn SCIPsetSetFeastol(set: *mut SCIP_SET, lp: *mut SCIP_LP, feastol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets feasibility tolerance for reduced costs in LP solution"]
    pub fn SCIPsetSetDualfeastol(set: *mut SCIP_SET, dualfeastol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets LP convergence tolerance used in barrier algorithm"]
    pub fn SCIPsetSetBarrierconvtol(set: *mut SCIP_SET, barrierconvtol: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets primal feasibility tolerance for relaxations (relaxfeastol)\n\n @note Set to SCIP_INVALID to apply relaxation-specific feasibility tolerance only.\n\n @return Previous value of relaxfeastol."]
    pub fn SCIPsetSetRelaxfeastol(set: *mut SCIP_SET, relaxfeastol: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " marks that some limit parameter was changed"]
    pub fn SCIPsetSetLimitChanged(set: *mut SCIP_SET);
}
unsafe extern "C" {
    #[doc = " returns the maximal number of variables priced into the LP per round"]
    pub fn SCIPsetGetPriceMaxvars(
        set: *mut SCIP_SET,
        root: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns factor for the maximal number of cuts generated per round"]
    pub fn SCIPsetGetSepaMaxcutsGenFactor(set: *mut SCIP_SET, root: ::std::os::raw::c_uint) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the maximal number of cuts separated per round"]
    pub fn SCIPsetGetSepaMaxcuts(
        set: *mut SCIP_SET,
        root: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the maximal ratio between coefficients to ensure in rowprep cleanup"]
    pub fn SCIPsetGetSepaMaxCoefRatioRowprep(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns user defined objective value (in original space) for reference purposes"]
    pub fn SCIPsetGetReferencevalue(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns debug solution data"]
    pub fn SCIPsetGetDebugSolData(set: *mut SCIP_SET) -> *mut SCIP_DEBUGSOLDATA;
}
unsafe extern "C" {
    #[doc = " Checks if an iteratively updated value is reliable or should be recomputed from scratch.\n  This is useful, if the value, e.g., the activity of a linear constraint or the pseudo objective value, gets a high\n  absolute value during the optimization process which is later reduced significantly. In this case, the last digits\n  were cancelled out when increasing the value and are random after decreasing it.\n  We dot not consider the cancellations which can occur during increasing the absolute value because they just cannot\n  be expressed using fixed precision floating point arithmetic, anymore.\n  The idea to get more reliable values is to always store the last reliable value, where increasing the absolute of\n  the value is viewed as preserving reliability. Then, after each update, the new absolute value can be compared\n  against the last reliable one with this method, checking whether it was decreased by a factor of at least\n  \"lp/recompfac\" and should be recomputed."]
    pub fn SCIPsetIsUpdateUnreliable(
        set: *mut SCIP_SET,
        newvalue: f64,
        oldvalue: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " modifies an initial seed value with the global shift of random seeds"]
    pub fn SCIPsetInitializeRandomSeed(
        set: *mut SCIP_SET,
        initialseedvalue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns value treated as infinity"]
    pub fn SCIPsetInfinity(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the minimum value that is regarded as huge and should be handled separately (e.g., in activity\n  computation)"]
    pub fn SCIPsetGetHugeValue(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns value treated as zero"]
    pub fn SCIPsetEpsilon(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns value treated as zero for sums of floating point values"]
    pub fn SCIPsetSumepsilon(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    pub fn SCIPsetFeastol(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns factor w.r.t. primal feasibility tolerance that determines default (and maximal) feasibility tolerance"]
    pub fn SCIPsetLPFeastolFactor(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    pub fn SCIPsetDualfeastol(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns convergence tolerance used in barrier algorithm"]
    pub fn SCIPsetBarrierconvtol(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns minimal variable distance value to use for pseudo cost updates"]
    pub fn SCIPsetPseudocosteps(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns minimal minimal objective distance value to use for pseudo cost updates"]
    pub fn SCIPsetPseudocostdelta(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " return the delta to use for computing the cutoff bound for integral objectives"]
    pub fn SCIPsetCutoffbounddelta(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " return the primal feasibility tolerance for relaxations"]
    pub fn SCIPsetRelaxfeastol(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " returns minimal decrease factor that causes the recomputation of a value\n  (e.g., pseudo objective) instead of an update"]
    pub fn SCIPsetRecompfac(set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if values are in range of epsilon"]
    pub fn SCIPsetIsEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than epsilon) lower than val2"]
    pub fn SCIPsetIsLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than epsilon) greater than val2"]
    pub fn SCIPsetIsLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than epsilon) greater than val2"]
    pub fn SCIPsetIsGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than epsilon) lower than val2"]
    pub fn SCIPsetIsGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is (positive) infinite"]
    pub fn SCIPsetIsInfinity(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is huge and should be handled separately (e.g., in activity computation)"]
    pub fn SCIPsetIsHugeValue(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range epsilon of 0.0"]
    pub fn SCIPsetIsZero(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than epsilon"]
    pub fn SCIPsetIsPositive(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -epsilon"]
    pub fn SCIPsetIsNegative(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within epsilon"]
    pub fn SCIPsetIsIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks whether the product val * scalar is integral in epsilon scaled by scalar"]
    pub fn SCIPsetIsScalingIntegral(
        set: *mut SCIP_SET,
        val: f64,
        scalar: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than epsilon"]
    pub fn SCIPsetIsFracIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + feasibility tolerance down to the next integer in epsilon tolerance"]
    pub fn SCIPsetFloor(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - feasibility tolerance up to the next integer in epsilon tolerance"]
    pub fn SCIPsetCeil(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in epsilon tolerance"]
    pub fn SCIPsetRound(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in epsilon tolerance"]
    pub fn SCIPsetFrac(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if values are in range of sumepsilon"]
    pub fn SCIPsetIsSumEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than sumepsilon) lower than val2"]
    pub fn SCIPsetIsSumLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than sumepsilon) greater than val2"]
    pub fn SCIPsetIsSumLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is (more than sumepsilon) greater than val2"]
    pub fn SCIPsetIsSumGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if val1 is not (more than sumepsilon) lower than val2"]
    pub fn SCIPsetIsSumGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range sumepsilon of 0.0"]
    pub fn SCIPsetIsSumZero(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than sumepsilon"]
    pub fn SCIPsetIsSumPositive(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -sumepsilon"]
    pub fn SCIPsetIsSumNegative(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + sumepsilon tolerance down to the next integer"]
    pub fn SCIPsetSumFloor(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - sumepsilon tolerance up to the next integer"]
    pub fn SCIPsetSumCeil(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in sumepsilon tolerance"]
    pub fn SCIPsetSumRound(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in sumepsilon tolerance"]
    pub fn SCIPsetSumFrac(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of feastol"]
    pub fn SCIPsetIsFeasEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than feastol"]
    pub fn SCIPsetIsFeasLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than feastol"]
    pub fn SCIPsetIsFeasLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than feastol"]
    pub fn SCIPsetIsFeasGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -feastol"]
    pub fn SCIPsetIsFeasGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range feasibility tolerance of 0.0"]
    pub fn SCIPsetIsFeasZero(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than feasibility tolerance"]
    pub fn SCIPsetIsFeasPositive(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -feasibility tolerance"]
    pub fn SCIPsetIsFeasNegative(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within the feasibility bounds"]
    pub fn SCIPsetIsFeasIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than feastol"]
    pub fn SCIPsetIsFeasFracIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + feasibility tolerance down to the next integer"]
    pub fn SCIPsetFeasFloor(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - feasibility tolerance up to the next integer"]
    pub fn SCIPsetFeasCeil(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in feasibility tolerance"]
    pub fn SCIPsetFeasRound(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in feasibility tolerance"]
    pub fn SCIPsetFeasFrac(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is in range dual feasibility tolerance of 0.0"]
    pub fn SCIPsetIsDualfeasZero(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is greater than dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasPositive(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is lower than -dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasNegative(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if value is integral within the dual feasibility bounds"]
    pub fn SCIPsetIsDualfeasIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if given fractional part is smaller than dual feasibility tolerance"]
    pub fn SCIPsetIsDualfeasFracIntegral(set: *mut SCIP_SET, val: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " rounds value + dual feasibility tolerance down to the next integer"]
    pub fn SCIPsetDualfeasFloor(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value - dual feasibility tolerance up to the next integer"]
    pub fn SCIPsetDualfeasCeil(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " rounds value to the nearest integer in dual feasibility tolerance"]
    pub fn SCIPsetDualfeasRound(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in dual feasibility tolerance"]
    pub fn SCIPsetDualfeasFrac(set: *mut SCIP_SET, val: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " checks if the given new lower bound is at least min(oldub - oldlb, |oldlb|) times the bound\n  strengthening epsilon better than the old one or the change in the lower bound would fix the\n  sign of the variable"]
    pub fn SCIPsetIsLbBetter(
        set: *mut SCIP_SET,
        newlb: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if the given new upper bound is at least min(oldub - oldlb, |oldub|) times the bound\n  strengthening epsilon better than the old one or the change in the upper bound would fix the\n  sign of the variable"]
    pub fn SCIPsetIsUbBetter(
        set: *mut SCIP_SET,
        newub: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if the given cut's efficacy is larger than the minimal cut efficacy"]
    pub fn SCIPsetIsEfficacious(
        set: *mut SCIP_SET,
        root: ::std::os::raw::c_uint,
        efficacy: f64,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of epsilon"]
    pub fn SCIPsetIsRelEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than epsilon"]
    pub fn SCIPsetIsRelLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than epsilon"]
    pub fn SCIPsetIsRelLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than epsilon"]
    pub fn SCIPsetIsRelGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -epsilon"]
    pub fn SCIPsetIsRelGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of values is in range of sumepsilon"]
    pub fn SCIPsetIsSumRelEQ(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is lower than sumepsilon"]
    pub fn SCIPsetIsSumRelLT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not greater than sumepsilon"]
    pub fn SCIPsetIsSumRelLE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is greater than sumepsilon"]
    pub fn SCIPsetIsSumRelGT(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " checks if relative difference of val1 and val2 is not lower than -sumepsilon"]
    pub fn SCIPsetIsSumRelGE(set: *mut SCIP_SET, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the flag indicating whether sub-SCIPs that could cause recursion have been deactivated"]
    pub fn SCIPsetGetSubscipsOff(set: *mut SCIP_SET) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn SCIPsetPrintDebugMessage(
        set: *mut SCIP_SET,
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn SCIPsetDebugMessagePrint(
        set: *mut SCIP_SET,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Primal {
    _unused: [u8; 0],
}
pub type SCIP_PRIMAL = SCIP_Primal;
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to zero"]
    pub fn SCIPsolCreate(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution with exact rational values, initialized to zero"]
    pub fn SCIPsolCreateExact(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution in original problem space, initialized to the offset in the original problem"]
    pub fn SCIPsolCreateOriginal(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates exact primal CIP solution in original problem space, initialized to the offset in the original problem"]
    pub fn SCIPsolCreateOriginalExact(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a primal CIP solution"]
    pub fn SCIPsolCopy(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " transformes given original solution to the transformed space; a corresponding transformed solution has to be given\n  which is copied into the existing solution and freed afterwards"]
    pub fn SCIPsolTransform(
        sol: *mut SCIP_SOL,
        transsol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        primal: *mut SCIP_PRIMAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adjusts solution values of implied integral variables in handed solution, solution objective value is not\n  deteriorated by this method"]
    pub fn SCIPsolAdjustImplicitSolVals(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current LP solution"]
    pub fn SCIPsolCreateLPSol(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution with exact rational values, initialized to the current LP solution"]
    pub fn SCIPsolCreateLPSolExact(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LPEXACT,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current NLP solution"]
    pub fn SCIPsolCreateNLPSol(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        nlp: *mut SCIP_NLP,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current relaxation solution"]
    pub fn SCIPsolCreateRelaxSol(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        relaxation: *mut SCIP_RELAXATION,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current pseudo solution"]
    pub fn SCIPsolCreatePseudoSol(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current exact pseudo solution"]
    pub fn SCIPsolCreatePseudoSolExact(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LPEXACT,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to the current solution"]
    pub fn SCIPsolCreateCurrentSol(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution with exact rational values, initialized to the current solution"]
    pub fn SCIPsolCreateCurrentSolExact(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LPEXACT,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates partial primal CIP solution, initialized to unknown values"]
    pub fn SCIPsolCreatePartial(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates primal CIP solution, initialized to unknown values"]
    pub fn SCIPsolCreateUnknown(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees primal CIP solution"]
    pub fn SCIPsolFree(
        sol: *mut *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        primal: *mut SCIP_PRIMAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current LP solution into CIP solution by linking"]
    pub fn SCIPsolLinkLPSol(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current exact LP solution into CIP solution by linking"]
    pub fn SCIPsolLinkLPSolExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LPEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current NLP solution into CIP solution by linking"]
    pub fn SCIPsolLinkNLPSol(
        sol: *mut SCIP_SOL,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        nlp: *mut SCIP_NLP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current relaxation solution into CIP solution by linking"]
    pub fn SCIPsolLinkRelaxSol(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        relaxation: *mut SCIP_RELAXATION,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current pseudo solution into CIP solution by linking"]
    pub fn SCIPsolLinkPseudoSol(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current pseudo solution into CIP solution by linking"]
    pub fn SCIPsolLinkPseudoSolExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LPEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies current solution (LP or pseudo solution) into CIP solution by linking"]
    pub fn SCIPsolLinkCurrentSol(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears primal CIP solution"]
    pub fn SCIPsolClear(
        sol: *mut SCIP_SOL,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " declares all entries in the primal CIP solution to be unknown"]
    pub fn SCIPsolSetUnknown(
        sol: *mut SCIP_SOL,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores solution values of variables in solution's own array"]
    pub fn SCIPsolUnlink(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores solution values of variables in solution's own array"]
    pub fn SCIPsolUnlinkExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets value of variable in primal CIP solution"]
    pub fn SCIPsolSetVal(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets value of variable in primal CIP solution"]
    pub fn SCIPsolSetValExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        var: *mut SCIP_VAR,
        val: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases value of variable in primal CIP solution"]
    pub fn SCIPsolIncVal(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        var: *mut SCIP_VAR,
        incval: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns value of variable in primal CIP solution"]
    pub fn SCIPsolGetVal(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns value of variable in primal CIP solution"]
    pub fn SCIPsolGetValExact(
        res: *mut SCIP_RATIONAL,
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
    );
}
unsafe extern "C" {
    #[doc = " returns value of variable in primal ray represented by primal CIP solution"]
    pub fn SCIPsolGetRayVal(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets objective value of primal CIP solution in transformed problem"]
    pub fn SCIPsolGetObj(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " gets objective value of primal CIP solution in transformed problem"]
    pub fn SCIPsolGetObjExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        objval: *mut SCIP_RATIONAL,
    );
}
unsafe extern "C" {
    #[doc = " updates primal solutions after a change in a variable's objective value"]
    pub fn SCIPsolUpdateVarObj(sol: *mut SCIP_SOL, var: *mut SCIP_VAR, oldobj: f64, newobj: f64);
}
unsafe extern "C" {
    pub fn SCIPsolMarkPartial(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks solution for feasibility in original problem without adding it to the solution store\n\n  We first check the variable bounds. Then we loop over all constraint handlers and constraints, checking each in the\n  order of their check priority."]
    pub fn SCIPsolCheckOrig(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        checkmodifiable: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks primal CIP solution for feasibility\n\n  @note The difference between SCIPsolCheck() and SCIPcheckSolOrig() is that modifiable constraints are handled\n        differently. There might be some variables which do not have an original counter part (e.g. in\n        branch-and-price). Therefore, modifiable constraints can not be double-checked in the original space."]
    pub fn SCIPsolCheck(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " try to round given solution"]
    pub fn SCIPsolRound(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies the real values to the exact arrays of the solution"]
    pub fn SCIPsolMakeExact(
        sol: *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " approximates and copies the exact values to the real arrays of the solution and frees the exact data"]
    pub fn SCIPsolMakeReal(
        sol: *mut SCIP_SOL,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates the solution value sums in variables by adding the value in the given solution"]
    pub fn SCIPsolUpdateVarsum(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        weight: f64,
    );
}
unsafe extern "C" {
    #[doc = " retransforms solution to original problem space"]
    pub fn SCIPsolRetransform(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        hasinfval: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " retransforms exact part of solution to original problem space"]
    pub fn SCIPsolRetransformExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        hasinfval: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " recomputes the objective value of an original solution, e.g., when transferring solutions\n  from the solution pool (objective coefficients might have changed in the meantime)"]
    pub fn SCIPsolRecomputeObj(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
    );
}
unsafe extern "C" {
    #[doc = " recomputes the objective value of an exact solution, e.g., when initialized from a real solution"]
    pub fn SCIPsolRecomputeInternObjExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
    );
}
unsafe extern "C" {
    #[doc = " returns whether the given solutions in transformed space are equal"]
    pub fn SCIPsolsAreEqual(
        sol1: *mut SCIP_SOL,
        sol2: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " outputs non-zero elements of solution to file stream"]
    pub fn SCIPsolPrint(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        file: *mut FILE,
        mipstart: ::std::os::raw::c_uint,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs non-zero elements of solution to file stream"]
    pub fn SCIPsolPrintExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        file: *mut FILE,
        mipstart: ::std::os::raw::c_uint,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " outputs non-zero elements of solution representing a ray to file stream"]
    pub fn SCIPsolPrintRay(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        prob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " set new origin type for a solution"]
    pub fn SCIPsolSetOrigin(sol: *mut SCIP_SOL, origin: SCIP_SOLORIGIN);
}
unsafe extern "C" {
    #[doc = " reset violations of a solution"]
    pub fn SCIPsolResetViolations(sol: *mut SCIP_SOL);
}
unsafe extern "C" {
    #[doc = " update integrality violation of a solution"]
    pub fn SCIPsolUpdateIntegralityViolation(sol: *mut SCIP_SOL, absviolintegrality: f64);
}
unsafe extern "C" {
    #[doc = " update bound violation of a solution"]
    pub fn SCIPsolUpdateBoundViolation(sol: *mut SCIP_SOL, absviolbounds: f64, relviolbounds: f64);
}
unsafe extern "C" {
    #[doc = " update LP row violation of a solution"]
    pub fn SCIPsolUpdateLPRowViolation(sol: *mut SCIP_SOL, absviollprows: f64, relviollprows: f64);
}
unsafe extern "C" {
    #[doc = " update constraint violation of a solution"]
    pub fn SCIPsolUpdateConsViolation(sol: *mut SCIP_SOL, absviolcons: f64, relviolcons: f64);
}
unsafe extern "C" {
    #[doc = " update violation of a constraint that is represented in the LP"]
    pub fn SCIPsolUpdateLPConsViolation(sol: *mut SCIP_SOL, absviol: f64, relviol: f64);
}
unsafe extern "C" {
    #[doc = " gets objective value of primal CIP solution which lives in the original problem space"]
    pub fn SCIPsolGetOrigObjExact(sol: *mut SCIP_SOL) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " overwrite FP solution with exact values"]
    pub fn SCIPsolOverwriteFPSolWithExact(
        sol: *mut SCIP_SOL,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        origprob: *mut SCIP_PROB,
        transprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a copy of a primal CIP solution"]
    pub fn SCIPvalsExactCopy(
        valsexact: *mut *mut SCIP_VALSEXACT,
        blkmem: *mut BMS_BLKMEM,
        sourcevals: *mut SCIP_VALSEXACT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds value to the objective value of a given original primal CIP solution"]
    pub fn SCIPsolOrigAddObjval(sol: *mut SCIP_SOL, addval: f64);
}
unsafe extern "C" {
    #[doc = " gets current position of solution in array of existing solutions of primal data"]
    pub fn SCIPsolGetPrimalIndex(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets current position of solution in array of existing solutions of primal data"]
    pub fn SCIPsolSetPrimalIndex(sol: *mut SCIP_SOL, primalindex: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " creates node priority queue"]
    pub fn SCIPnodepqCreate(
        nodepq: *mut *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
        nodesel: *mut SCIP_NODESEL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees node priority queue, but not the data nodes themselves"]
    pub fn SCIPnodepqDestroy(nodepq: *mut *mut SCIP_NODEPQ);
}
unsafe extern "C" {
    #[doc = " frees node priority queue and all nodes in the queue"]
    pub fn SCIPnodepqFree(
        nodepq: *mut *mut SCIP_NODEPQ,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deletes all nodes in the node priority queue"]
    pub fn SCIPnodepqClear(
        nodepq: *mut SCIP_NODEPQ,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the node selector associated with the given node priority queue"]
    pub fn SCIPnodepqGetNodesel(nodepq: *mut SCIP_NODEPQ) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " sets the node selector used for sorting the nodes in the queue, and resorts the queue if necessary"]
    pub fn SCIPnodepqSetNodesel(
        nodepq: *mut *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
        nodesel: *mut SCIP_NODESEL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compares two nodes; returns -1/0/+1 if node1 better/equal/worse than node2"]
    pub fn SCIPnodepqCompare(
        nodepq: *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " inserts node into node priority queue"]
    pub fn SCIPnodepqInsert(
        nodepq: *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
        node: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " removes node from the node priority queue"]
    pub fn SCIPnodepqRemove(
        nodepq: *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
        node: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the best node of the queue without removing it"]
    pub fn SCIPnodepqFirst(nodepq: *const SCIP_NODEPQ) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " returns the nodes array of the queue"]
    pub fn SCIPnodepqNodes(nodepq: *const SCIP_NODEPQ) -> *mut *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " returns the number of nodes stored in the node priority queue"]
    pub fn SCIPnodepqLen(nodepq: *const SCIP_NODEPQ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the minimal lower bound of all nodes in the queue"]
    pub fn SCIPnodepqGetLowerbound(nodepq: *mut SCIP_NODEPQ, set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the minimal exact lower bound of all nodes in the queue or NULL if empty"]
    pub fn SCIPnodepqGetLowerboundExact(
        nodepq: *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the node with minimal lower bound of all nodes in the queue"]
    pub fn SCIPnodepqGetLowerboundNode(
        nodepq: *mut SCIP_NODEPQ,
        set: *mut SCIP_SET,
    ) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the sum of lower bounds of all nodes in the queue"]
    pub fn SCIPnodepqGetLowerboundSum(nodepq: *mut SCIP_NODEPQ) -> f64;
}
unsafe extern "C" {
    #[doc = " free all nodes from the queue that are cut off by the given upper bound"]
    pub fn SCIPnodepqBound(
        nodepq: *mut SCIP_NODEPQ,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " copies the given node selector to a new scip"]
    pub fn SCIPnodeselCopyInclude(nodesel: *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a node selector"]
    pub fn SCIPnodeselCreate(
        nodesel: *mut *mut SCIP_NODESEL,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        blkmem: *mut BMS_BLKMEM,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees memory of node selector"]
    pub fn SCIPnodeselFree(nodesel: *mut *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " initializes node selector"]
    pub fn SCIPnodeselInit(nodesel: *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " deinitializes node selector"]
    pub fn SCIPnodeselExit(nodesel: *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs node selector that the branch and bound process is being started"]
    pub fn SCIPnodeselInitsol(nodesel: *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " informs node selector that the branch and bound process data is being freed"]
    pub fn SCIPnodeselExitsol(nodesel: *mut SCIP_NODESEL, set: *mut SCIP_SET) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " select next node to be processed"]
    pub fn SCIPnodeselSelect(
        nodesel: *mut SCIP_NODESEL,
        set: *mut SCIP_SET,
        selnode: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compares two nodes; returns -1/0/+1 if node1 better/equal/worse than node2"]
    pub fn SCIPnodeselCompare(
        nodesel: *mut SCIP_NODESEL,
        set: *mut SCIP_SET,
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets priority of node selector in standard mode"]
    pub fn SCIPnodeselSetStdPriority(
        nodesel: *mut SCIP_NODESEL,
        set: *mut SCIP_SET,
        priority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets priority of node selector in memory saving mode"]
    pub fn SCIPnodeselSetMemsavePriority(
        nodesel: *mut SCIP_NODESEL,
        set: *mut SCIP_SET,
        priority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " sets copy method of node selector"]
    pub fn SCIPnodeselSetCopy(
        nodesel: *mut SCIP_NODESEL,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets destructor method of node selector"]
    pub fn SCIPnodeselSetFree(
        nodesel: *mut SCIP_NODESEL,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets initialization method of node selector"]
    pub fn SCIPnodeselSetInit(
        nodesel: *mut SCIP_NODESEL,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets deinitialization method of node selector"]
    pub fn SCIPnodeselSetExit(
        nodesel: *mut SCIP_NODESEL,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets solving process initialization method of node selector"]
    pub fn SCIPnodeselSetInitsol(
        nodesel: *mut SCIP_NODESEL,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets solving process deinitialization method of node selector"]
    pub fn SCIPnodeselSetExitsol(
        nodesel: *mut SCIP_NODESEL,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " enables or disables all clocks of \\p nodesel, depending on the value of the flag"]
    pub fn SCIPnodeselEnableOrDisableClocks(
        nodesel: *mut SCIP_NODESEL,
        enable: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflictStore {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTSTORE = SCIP_ConflictStore;
#[doc = " probing node, possibly with solved LP, where bounds and constraints have been changed,\n  and rows and columns might have been added"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Probingnode {
    #[doc = "< LP state information"]
    pub lpistate: *mut SCIP_LPISTATE,
    #[doc = "< LP pricing norms information"]
    pub lpinorms: *mut SCIP_LPINORMS,
    #[doc = "< number of LP columns before the node was processed"]
    pub ninitialcols: ::std::os::raw::c_int,
    #[doc = "< number of LP rows before the node was processed"]
    pub ninitialrows: ::std::os::raw::c_int,
    #[doc = "< total number of columns of this node's LP"]
    pub ncols: ::std::os::raw::c_int,
    #[doc = "< total number of rows of this node's LP"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< variables whose objective function coefficients have changed"]
    pub origobjvars: *mut *mut SCIP_VAR,
    #[doc = "< original objective function coefficients"]
    pub origobjvals: *mut f64,
    #[doc = "< number of changed objective coefficients"]
    pub nchgdobjs: ::std::os::raw::c_int,
    #[doc = "< primal feasibility of saved LP state information"]
    pub lpwasprimfeas: ::std::os::raw::c_uint,
    #[doc = "< primal feasibility check state of saved LP state information"]
    pub lpwasprimchecked: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility of saved LP state information"]
    pub lpwasdualfeas: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility check state of saved LP state information"]
    pub lpwasdualchecked: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Probingnode"][::std::mem::size_of::<SCIP_Probingnode>() - 72usize];
    ["Alignment of SCIP_Probingnode"][::std::mem::align_of::<SCIP_Probingnode>() - 8usize];
    ["Offset of field: SCIP_Probingnode::lpistate"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpistate) - 0usize];
    ["Offset of field: SCIP_Probingnode::lpinorms"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpinorms) - 8usize];
    ["Offset of field: SCIP_Probingnode::ninitialcols"]
        [::std::mem::offset_of!(SCIP_Probingnode, ninitialcols) - 16usize];
    ["Offset of field: SCIP_Probingnode::ninitialrows"]
        [::std::mem::offset_of!(SCIP_Probingnode, ninitialrows) - 20usize];
    ["Offset of field: SCIP_Probingnode::ncols"]
        [::std::mem::offset_of!(SCIP_Probingnode, ncols) - 24usize];
    ["Offset of field: SCIP_Probingnode::nrows"]
        [::std::mem::offset_of!(SCIP_Probingnode, nrows) - 28usize];
    ["Offset of field: SCIP_Probingnode::origobjvars"]
        [::std::mem::offset_of!(SCIP_Probingnode, origobjvars) - 32usize];
    ["Offset of field: SCIP_Probingnode::origobjvals"]
        [::std::mem::offset_of!(SCIP_Probingnode, origobjvals) - 40usize];
    ["Offset of field: SCIP_Probingnode::nchgdobjs"]
        [::std::mem::offset_of!(SCIP_Probingnode, nchgdobjs) - 48usize];
    ["Offset of field: SCIP_Probingnode::lpwasprimfeas"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpwasprimfeas) - 52usize];
    ["Offset of field: SCIP_Probingnode::lpwasprimchecked"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpwasprimchecked) - 56usize];
    ["Offset of field: SCIP_Probingnode::lpwasdualfeas"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpwasdualfeas) - 60usize];
    ["Offset of field: SCIP_Probingnode::lpwasdualchecked"]
        [::std::mem::offset_of!(SCIP_Probingnode, lpwasdualchecked) - 64usize];
};
#[doc = " sibling information (should not exceed the size of a pointer)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sibling {
    #[doc = "< position of node in the siblings array"]
    pub arraypos: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Sibling"][::std::mem::size_of::<SCIP_Sibling>() - 4usize];
    ["Alignment of SCIP_Sibling"][::std::mem::align_of::<SCIP_Sibling>() - 4usize];
    ["Offset of field: SCIP_Sibling::arraypos"]
        [::std::mem::offset_of!(SCIP_Sibling, arraypos) - 0usize];
};
#[doc = " child information (should not exceed the size of a pointer)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Child {
    #[doc = "< position of node in the children array"]
    pub arraypos: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Child"][::std::mem::size_of::<SCIP_Child>() - 4usize];
    ["Alignment of SCIP_Child"][::std::mem::align_of::<SCIP_Child>() - 4usize];
    ["Offset of field: SCIP_Child::arraypos"]
        [::std::mem::offset_of!(SCIP_Child, arraypos) - 0usize];
};
#[doc = " leaf information (should not exceed the size of a pointer)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Leaf {
    #[doc = "< fork/subroot node defining the LP state of the leaf"]
    pub lpstatefork: *mut SCIP_NODE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Leaf"][::std::mem::size_of::<SCIP_Leaf>() - 8usize];
    ["Alignment of SCIP_Leaf"][::std::mem::align_of::<SCIP_Leaf>() - 8usize];
    ["Offset of field: SCIP_Leaf::lpstatefork"]
        [::std::mem::offset_of!(SCIP_Leaf, lpstatefork) - 0usize];
};
#[doc = " fork without LP solution, where only bounds and constraints have been changed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Junction {
    #[doc = "< number of children of this parent node"]
    pub nchildren: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Junction"][::std::mem::size_of::<SCIP_Junction>() - 4usize];
    ["Alignment of SCIP_Junction"][::std::mem::align_of::<SCIP_Junction>() - 4usize];
    ["Offset of field: SCIP_Junction::nchildren"]
        [::std::mem::offset_of!(SCIP_Junction, nchildren) - 0usize];
};
#[doc = " fork without LP solution, where bounds and constraints have been changed, and rows and columns were added"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pseudofork {
    #[doc = "< array with pointers to new columns added at this node into the LP"]
    pub addedcols: *mut *mut SCIP_COL,
    #[doc = "< array with pointers to new rows added at this node into the LP"]
    pub addedrows: *mut *mut SCIP_ROW,
    #[doc = "< number of columns added at this node"]
    pub naddedcols: ::std::os::raw::c_int,
    #[doc = "< number of rows added at this node"]
    pub naddedrows: ::std::os::raw::c_int,
    #[doc = "< number of children of this parent node"]
    pub nchildren: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Pseudofork"][::std::mem::size_of::<SCIP_Pseudofork>() - 32usize];
    ["Alignment of SCIP_Pseudofork"][::std::mem::align_of::<SCIP_Pseudofork>() - 8usize];
    ["Offset of field: SCIP_Pseudofork::addedcols"]
        [::std::mem::offset_of!(SCIP_Pseudofork, addedcols) - 0usize];
    ["Offset of field: SCIP_Pseudofork::addedrows"]
        [::std::mem::offset_of!(SCIP_Pseudofork, addedrows) - 8usize];
    ["Offset of field: SCIP_Pseudofork::naddedcols"]
        [::std::mem::offset_of!(SCIP_Pseudofork, naddedcols) - 16usize];
    ["Offset of field: SCIP_Pseudofork::naddedrows"]
        [::std::mem::offset_of!(SCIP_Pseudofork, naddedrows) - 20usize];
    ["Offset of field: SCIP_Pseudofork::nchildren"]
        [::std::mem::offset_of!(SCIP_Pseudofork, nchildren) - 24usize];
};
#[doc = " fork with solved LP, where bounds and constraints have been changed, and rows and columns were added"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Fork {
    #[doc = "< array with pointers to new columns added at this node into the LP"]
    pub addedcols: *mut *mut SCIP_COL,
    #[doc = "< array with pointers to new rows added at this node into the LP"]
    pub addedrows: *mut *mut SCIP_ROW,
    #[doc = "< LP state information"]
    pub lpistate: *mut SCIP_LPISTATE,
    #[doc = "< the LP objective value for that node, needed to compute the pseudo costs correctly"]
    pub lpobjval: f64,
    #[doc = "< number of columns added at this node"]
    pub naddedcols: ::std::os::raw::c_int,
    #[doc = "< number of rows added at this node"]
    pub naddedrows: ::std::os::raw::c_int,
    #[doc = "< number of times, the LP state is needed"]
    pub nlpistateref: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Fork"][::std::mem::size_of::<SCIP_Fork>() - 48usize];
    ["Alignment of SCIP_Fork"][::std::mem::align_of::<SCIP_Fork>() - 8usize];
    ["Offset of field: SCIP_Fork::addedcols"]
        [::std::mem::offset_of!(SCIP_Fork, addedcols) - 0usize];
    ["Offset of field: SCIP_Fork::addedrows"]
        [::std::mem::offset_of!(SCIP_Fork, addedrows) - 8usize];
    ["Offset of field: SCIP_Fork::lpistate"][::std::mem::offset_of!(SCIP_Fork, lpistate) - 16usize];
    ["Offset of field: SCIP_Fork::lpobjval"][::std::mem::offset_of!(SCIP_Fork, lpobjval) - 24usize];
    ["Offset of field: SCIP_Fork::naddedcols"]
        [::std::mem::offset_of!(SCIP_Fork, naddedcols) - 32usize];
    ["Offset of field: SCIP_Fork::naddedrows"]
        [::std::mem::offset_of!(SCIP_Fork, naddedrows) - 36usize];
    ["Offset of field: SCIP_Fork::nlpistateref"]
        [::std::mem::offset_of!(SCIP_Fork, nlpistateref) - 40usize];
};
impl SCIP_Fork {
    #[inline]
    pub fn nchildren(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_nchildren(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nchildren_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nchildren_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasprimfeas(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasprimfeas(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasprimfeas_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasprimfeas_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasprimchecked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasprimchecked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasprimchecked_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasprimchecked_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasdualfeas(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasdualfeas(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasdualfeas_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasdualfeas_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasdualchecked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasdualchecked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasdualchecked_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasdualchecked_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nchildren: ::std::os::raw::c_uint,
        lpwasprimfeas: ::std::os::raw::c_uint,
        lpwasprimchecked: ::std::os::raw::c_uint,
        lpwasdualfeas: ::std::os::raw::c_uint,
        lpwasdualchecked: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let nchildren: u32 = unsafe { ::std::mem::transmute(nchildren) };
            nchildren as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let lpwasprimfeas: u32 = unsafe { ::std::mem::transmute(lpwasprimfeas) };
            lpwasprimfeas as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let lpwasprimchecked: u32 = unsafe { ::std::mem::transmute(lpwasprimchecked) };
            lpwasprimchecked as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lpwasdualfeas: u32 = unsafe { ::std::mem::transmute(lpwasdualfeas) };
            lpwasdualfeas as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lpwasdualchecked: u32 = unsafe { ::std::mem::transmute(lpwasdualchecked) };
            lpwasdualchecked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " fork with solved LP, where bounds and constraints have been changed, and rows and columns were removed and added"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Subroot {
    #[doc = "< array with pointers to the columns in the same order as in the LP"]
    pub cols: *mut *mut SCIP_COL,
    #[doc = "< array with pointers to the rows in the same order as in the LP"]
    pub rows: *mut *mut SCIP_ROW,
    #[doc = "< LP state information"]
    pub lpistate: *mut SCIP_LPISTATE,
    #[doc = "< the LP objective value for that node, needed to compute the pseudo costs correctly"]
    pub lpobjval: f64,
    #[doc = "< number of columns in the LP"]
    pub ncols: ::std::os::raw::c_int,
    #[doc = "< number of rows in the LP"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< number of times, the LP state is needed"]
    pub nlpistateref: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Subroot"][::std::mem::size_of::<SCIP_Subroot>() - 56usize];
    ["Alignment of SCIP_Subroot"][::std::mem::align_of::<SCIP_Subroot>() - 8usize];
    ["Offset of field: SCIP_Subroot::cols"][::std::mem::offset_of!(SCIP_Subroot, cols) - 0usize];
    ["Offset of field: SCIP_Subroot::rows"][::std::mem::offset_of!(SCIP_Subroot, rows) - 8usize];
    ["Offset of field: SCIP_Subroot::lpistate"]
        [::std::mem::offset_of!(SCIP_Subroot, lpistate) - 16usize];
    ["Offset of field: SCIP_Subroot::lpobjval"]
        [::std::mem::offset_of!(SCIP_Subroot, lpobjval) - 24usize];
    ["Offset of field: SCIP_Subroot::ncols"][::std::mem::offset_of!(SCIP_Subroot, ncols) - 32usize];
    ["Offset of field: SCIP_Subroot::nrows"][::std::mem::offset_of!(SCIP_Subroot, nrows) - 36usize];
    ["Offset of field: SCIP_Subroot::nlpistateref"]
        [::std::mem::offset_of!(SCIP_Subroot, nlpistateref) - 40usize];
};
impl SCIP_Subroot {
    #[inline]
    pub fn nchildren(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_nchildren(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nchildren_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nchildren_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasprimfeas(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasprimfeas(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasprimfeas_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasprimfeas_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasprimchecked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasprimchecked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasprimchecked_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasprimchecked_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasdualfeas(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasdualfeas(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasdualfeas_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasdualfeas_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lpwasdualchecked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpwasdualchecked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lpwasdualchecked_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lpwasdualchecked_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nchildren: ::std::os::raw::c_uint,
        lpwasprimfeas: ::std::os::raw::c_uint,
        lpwasprimchecked: ::std::os::raw::c_uint,
        lpwasdualfeas: ::std::os::raw::c_uint,
        lpwasdualchecked: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let nchildren: u32 = unsafe { ::std::mem::transmute(nchildren) };
            nchildren as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lpwasprimfeas: u32 = unsafe { ::std::mem::transmute(lpwasprimfeas) };
            lpwasprimfeas as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lpwasprimchecked: u32 = unsafe { ::std::mem::transmute(lpwasprimchecked) };
            lpwasprimchecked as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let lpwasdualfeas: u32 = unsafe { ::std::mem::transmute(lpwasdualfeas) };
            lpwasdualfeas as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let lpwasdualchecked: u32 = unsafe { ::std::mem::transmute(lpwasdualchecked) };
            lpwasdualchecked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " node data structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_Node {
    #[doc = "< successively assigned number of the node"]
    pub number: ::std::os::raw::c_longlong,
    #[doc = "< lower (dual) bound of subtree"]
    pub lowerbound: f64,
    #[doc = "< lower (dual) rational bound of subtree"]
    pub lowerboundexact: *mut SCIP_RATIONAL,
    #[doc = "< estimated value of feasible solution in subtree"]
    pub estimate: f64,
    pub data: SCIP_Node__bindgen_ty_1,
    #[doc = "< parent node in the tree"]
    pub parent: *mut SCIP_NODE,
    #[doc = "< constraint set changes at this node or NULL"]
    pub conssetchg: *mut SCIP_CONSSETCHG,
    #[doc = "< domain changes at this node or NULL"]
    pub domchg: *mut SCIP_DOMCHG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 11usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SCIP_Node__bindgen_ty_1 {
    #[doc = "< data for probing nodes"]
    pub probingnode: *mut SCIP_PROBINGNODE,
    #[doc = "< data for sibling nodes"]
    pub sibling: SCIP_SIBLING,
    #[doc = "< data for child nodes"]
    pub child: SCIP_CHILD,
    #[doc = "< data for leaf nodes"]
    pub leaf: SCIP_LEAF,
    #[doc = "< data for junction nodes"]
    pub junction: SCIP_JUNCTION,
    #[doc = "< data for pseudo fork nodes"]
    pub pseudofork: *mut SCIP_PSEUDOFORK,
    #[doc = "< data for fork nodes"]
    pub fork: *mut SCIP_FORK,
    #[doc = "< data for subroot nodes"]
    pub subroot: *mut SCIP_SUBROOT,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Node__bindgen_ty_1"][::std::mem::size_of::<SCIP_Node__bindgen_ty_1>() - 8usize];
    ["Alignment of SCIP_Node__bindgen_ty_1"]
        [::std::mem::align_of::<SCIP_Node__bindgen_ty_1>() - 8usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::probingnode"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, probingnode) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::sibling"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, sibling) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::child"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, child) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::leaf"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, leaf) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::junction"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, junction) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::pseudofork"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, pseudofork) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::fork"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, fork) - 0usize];
    ["Offset of field: SCIP_Node__bindgen_ty_1::subroot"]
        [::std::mem::offset_of!(SCIP_Node__bindgen_ty_1, subroot) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Node"][::std::mem::size_of::<SCIP_Node>() - 80usize];
    ["Alignment of SCIP_Node"][::std::mem::align_of::<SCIP_Node>() - 8usize];
    ["Offset of field: SCIP_Node::number"][::std::mem::offset_of!(SCIP_Node, number) - 0usize];
    ["Offset of field: SCIP_Node::lowerbound"]
        [::std::mem::offset_of!(SCIP_Node, lowerbound) - 8usize];
    ["Offset of field: SCIP_Node::lowerboundexact"]
        [::std::mem::offset_of!(SCIP_Node, lowerboundexact) - 16usize];
    ["Offset of field: SCIP_Node::estimate"][::std::mem::offset_of!(SCIP_Node, estimate) - 24usize];
    ["Offset of field: SCIP_Node::data"][::std::mem::offset_of!(SCIP_Node, data) - 32usize];
    ["Offset of field: SCIP_Node::parent"][::std::mem::offset_of!(SCIP_Node, parent) - 40usize];
    ["Offset of field: SCIP_Node::conssetchg"]
        [::std::mem::offset_of!(SCIP_Node, conssetchg) - 48usize];
    ["Offset of field: SCIP_Node::domchg"][::std::mem::offset_of!(SCIP_Node, domchg) - 56usize];
};
impl SCIP_Node {
    #[inline]
    pub fn depth(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn depth_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_depth_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reoptid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_reoptid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reoptid_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reoptid_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reopttype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reopttype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reopttype_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reopttype_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repropsubtreemark(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(67usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_repropsubtreemark(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(67usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repropsubtreemark_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                67usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repropsubtreemark_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                67usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                76usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_active_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                76usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cutoff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cutoff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cutoff_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                77usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cutoff_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                77usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reprop(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reprop(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reprop_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                78usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reprop_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                78usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nodetype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_nodetype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nodetype_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 11usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                79usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nodetype_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 11usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                79usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        depth: ::std::os::raw::c_uint,
        reoptid: ::std::os::raw::c_uint,
        reopttype: ::std::os::raw::c_uint,
        repropsubtreemark: ::std::os::raw::c_uint,
        active: ::std::os::raw::c_uint,
        cutoff: ::std::os::raw::c_uint,
        reprop: ::std::os::raw::c_uint,
        nodetype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 11usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 11usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let depth: u32 = unsafe { ::std::mem::transmute(depth) };
            depth as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let reoptid: u32 = unsafe { ::std::mem::transmute(reoptid) };
            reoptid as u64
        });
        __bindgen_bitfield_unit.set(64usize, 3u8, {
            let reopttype: u32 = unsafe { ::std::mem::transmute(reopttype) };
            reopttype as u64
        });
        __bindgen_bitfield_unit.set(67usize, 9u8, {
            let repropsubtreemark: u32 = unsafe { ::std::mem::transmute(repropsubtreemark) };
            repropsubtreemark as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let active: u32 = unsafe { ::std::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let cutoff: u32 = unsafe { ::std::mem::transmute(cutoff) };
            cutoff as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let reprop: u32 = unsafe { ::std::mem::transmute(reprop) };
            reprop as u64
        });
        __bindgen_bitfield_unit.set(79usize, 4u8, {
            let nodetype: u32 = unsafe { ::std::mem::transmute(nodetype) };
            nodetype as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " bound change information for pending bound changes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PendingBdchg {
    #[doc = "< node to add bound change to"]
    pub node: *mut SCIP_NODE,
    #[doc = "< variable to change the bounds for"]
    pub var: *mut SCIP_VAR,
    #[doc = "< new value for bound"]
    pub newbound: f64,
    #[doc = "< new value for exact bound, or NULL if not needed"]
    pub newboundexact: *mut SCIP_RATIONAL,
    #[doc = "< type of bound: lower or upper bound"]
    pub boundtype: SCIP_BOUNDTYPE,
    #[doc = "< constraint that deduced the bound change, or NULL"]
    pub infercons: *mut SCIP_CONS,
    #[doc = "< propagator that deduced the bound change, or NULL"]
    pub inferprop: *mut SCIP_PROP,
    #[doc = "< user information for inference to help resolving the conflict"]
    pub inferinfo: ::std::os::raw::c_int,
    #[doc = "< is the bound change a temporary setting due to probing?"]
    pub probingchange: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_PendingBdchg"][::std::mem::size_of::<SCIP_PendingBdchg>() - 64usize];
    ["Alignment of SCIP_PendingBdchg"][::std::mem::align_of::<SCIP_PendingBdchg>() - 8usize];
    ["Offset of field: SCIP_PendingBdchg::node"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, node) - 0usize];
    ["Offset of field: SCIP_PendingBdchg::var"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, var) - 8usize];
    ["Offset of field: SCIP_PendingBdchg::newbound"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, newbound) - 16usize];
    ["Offset of field: SCIP_PendingBdchg::newboundexact"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, newboundexact) - 24usize];
    ["Offset of field: SCIP_PendingBdchg::boundtype"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, boundtype) - 32usize];
    ["Offset of field: SCIP_PendingBdchg::infercons"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, infercons) - 40usize];
    ["Offset of field: SCIP_PendingBdchg::inferprop"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, inferprop) - 48usize];
    ["Offset of field: SCIP_PendingBdchg::inferinfo"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, inferinfo) - 56usize];
    ["Offset of field: SCIP_PendingBdchg::probingchange"]
        [::std::mem::offset_of!(SCIP_PendingBdchg, probingchange) - 60usize];
};
#[doc = " branch and bound tree"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Tree {
    #[doc = "< root node of the tree"]
    pub root: *mut SCIP_NODE,
    #[doc = "< leaves of the tree"]
    pub leaves: *mut SCIP_NODEPQ,
    #[doc = "< array of nodes storing the active path from root to current node, which\n   is usually the focus or a probing node; in case of a cut off, the path\n   may already end earlier"]
    pub path: *mut *mut SCIP_NODE,
    #[doc = "< focus node: the node that is stored together with its children and\n   siblings in the tree data structure; the focus node is the currently\n   processed node; it doesn't need to be active all the time, because it\n   may be cut off and the active path stops at the cut off node"]
    pub focusnode: *mut SCIP_NODE,
    #[doc = "< LP defining pseudofork/fork/subroot of the focus node"]
    pub focuslpfork: *mut SCIP_NODE,
    #[doc = "< LP state defining fork/subroot of the focus node"]
    pub focuslpstatefork: *mut SCIP_NODE,
    #[doc = "< subroot of the focus node's sub tree"]
    pub focussubroot: *mut SCIP_NODE,
    #[doc = "< root node of the current probing path, or NULL"]
    pub probingroot: *mut SCIP_NODE,
    #[doc = "< array with children of the focus node"]
    pub children: *mut *mut SCIP_NODE,
    #[doc = "< array with siblings of the focus node"]
    pub siblings: *mut *mut SCIP_NODE,
    #[doc = "< array with node selection priorities of children"]
    pub childrenprio: *mut f64,
    #[doc = "< array with node selection priorities of siblings"]
    pub siblingsprio: *mut f64,
    #[doc = "< two arrays to store variables for branching"]
    pub divebdchgvars: [*mut *mut SCIP_VAR; 2usize],
    #[doc = "< arrays to hold the directions for diving"]
    pub divebdchgdirs: [*mut SCIP_BRANCHDIR; 2usize],
    #[doc = "< arrays to store bound change values for diving"]
    pub divebdchgvals: [*mut f64; 2usize],
    #[doc = "< array with number of LP columns for each problem in active path (except\n   newly added columns of the focus node and the current probing node)"]
    pub pathnlpcols: *mut ::std::os::raw::c_int,
    #[doc = "< array with number of LP rows for each problem in active path (except\n   newly added rows of the focus node and the current probing node)"]
    pub pathnlprows: *mut ::std::os::raw::c_int,
    #[doc = "< LP state information before probing started"]
    pub probinglpistate: *mut SCIP_LPISTATE,
    #[doc = "< LP state information of focus node"]
    pub focuslpistate: *mut SCIP_LPISTATE,
    #[doc = "< LP pricing norms information before probing started"]
    pub probinglpinorms: *mut SCIP_LPINORMS,
    #[doc = "< array of pending bound changes, or NULL"]
    pub pendingbdchgs: *mut SCIP_PENDINGBDCHG,
    #[doc = "< array with stored original relaxation solution during diving or probing"]
    pub probdiverelaxsol: *mut f64,
    #[doc = "< lp objective value before probing started"]
    pub probinglpobjval: f64,
    #[doc = "< size of probdiverelaxsol"]
    pub nprobdiverelaxsol: ::std::os::raw::c_int,
    #[doc = "< LP number of last solved LP in current LP state fork, or -1 if unknown"]
    pub focuslpstateforklpcount: ::std::os::raw::c_longlong,
    #[doc = "< last node id/number of branching parent"]
    pub lastbranchparentid: ::std::os::raw::c_longlong,
    #[doc = "< holds the two sizes of the dive bound change information"]
    pub divebdchgsize: [::std::os::raw::c_int; 2usize],
    #[doc = "< current number of stored dive bound changes for the next depth"]
    pub ndivebdchanges: [::std::os::raw::c_int; 2usize],
    #[doc = "< size of pendingbdchgs array"]
    pub pendingbdchgssize: ::std::os::raw::c_int,
    #[doc = "< number of pending bound changes"]
    pub npendingbdchgs: ::std::os::raw::c_int,
    #[doc = "< available slots in children vector"]
    pub childrensize: ::std::os::raw::c_int,
    #[doc = "< number of children of focus node (number of used slots in children vector)"]
    pub nchildren: ::std::os::raw::c_int,
    #[doc = "< available slots in siblings vector"]
    pub siblingssize: ::std::os::raw::c_int,
    #[doc = "< number of siblings of focus node (number of used slots in siblings vector)"]
    pub nsiblings: ::std::os::raw::c_int,
    #[doc = "< length of the current path"]
    pub pathlen: ::std::os::raw::c_int,
    #[doc = "< number of available slots in path arrays"]
    pub pathsize: ::std::os::raw::c_int,
    #[doc = "< the effective root depth which was already enforced"]
    pub effectiverootdepth: ::std::os::raw::c_int,
    #[doc = "< first depth of node with at least two children or focus node"]
    pub updatedeffectiverootdepth: ::std::os::raw::c_int,
    #[doc = "< depth to which current LP data corresponds to LP data of active path"]
    pub correctlpdepth: ::std::os::raw::c_int,
    #[doc = "< depth of first node in active path that is marked being cutoff"]
    pub cutoffdepth: ::std::os::raw::c_int,
    #[doc = "< depth of first node in active path that has to be propagated again"]
    pub repropdepth: ::std::os::raw::c_int,
    #[doc = "< cyclicly increased counter to create markers for subtree repropagation"]
    pub repropsubtreecount: ::std::os::raw::c_int,
    #[doc = "< number of changed objective coefficients in all probing nodes"]
    pub probingsumchgdobjs: ::std::os::raw::c_int,
    #[doc = "< is LP being processed in the focus node?"]
    pub focusnodehaslp: ::std::os::raw::c_uint,
    #[doc = "< was the LP solved (at least once) in the current probing node?"]
    pub probingnodehaslp: ::std::os::raw::c_uint,
    #[doc = "< was the LP of the focus node already constructed?"]
    pub focuslpconstructed: ::std::os::raw::c_uint,
    #[doc = "< the treeCutoff() call was delayed because of diving and has to be executed"]
    pub cutoffdelayed: ::std::os::raw::c_uint,
    #[doc = "< was the LP flushed before we entered the probing mode?"]
    pub probinglpwasflushed: ::std::os::raw::c_uint,
    #[doc = "< was the LP solved before we entered the probing mode?"]
    pub probinglpwassolved: ::std::os::raw::c_uint,
    #[doc = "< must the LP state be reloaded because of a backtrack in probing?"]
    pub probingloadlpistate: ::std::os::raw::c_uint,
    #[doc = "< was the LP a valid relaxation before we entered the probing mode?"]
    pub probinglpwasrelax: ::std::os::raw::c_uint,
    #[doc = "< was the LP solved during probing mode, i.e., was SCIPsolveProbingLP() called?"]
    pub probingsolvedlp: ::std::os::raw::c_uint,
    #[doc = "< was forcing LP solving message be posted"]
    pub forcinglpmessage: ::std::os::raw::c_uint,
    #[doc = "< was the objective function changed during probing?"]
    pub probingobjchanged: ::std::os::raw::c_uint,
    #[doc = "< is the probing mode used for strong branching?"]
    pub sbprobing: ::std::os::raw::c_uint,
    #[doc = "< primal feasibility when probing started"]
    pub probinglpwasprimfeas: ::std::os::raw::c_uint,
    #[doc = "< primal feasibility has been checked when probing started"]
    pub probinglpwasprimchecked: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility when probing started"]
    pub probinglpwasdualfeas: ::std::os::raw::c_uint,
    #[doc = "< dual feasibility has been check when probing started"]
    pub probinglpwasdualchecked: ::std::os::raw::c_uint,
    #[doc = "< lp had a proven dual bound when probing started?"]
    pub probinglphadsafebound: ::std::os::raw::c_uint,
    #[doc = "< was a relax solution stored before diving or probing ?"]
    pub probdiverelaxstored: ::std::os::raw::c_uint,
    #[doc = "< did the stored relaxation solution include all lp cuts ?"]
    pub probdiverelaxincludeslp: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_Tree"][::std::mem::size_of::<SCIP_Tree>() - 384usize];
    ["Alignment of SCIP_Tree"][::std::mem::align_of::<SCIP_Tree>() - 8usize];
    ["Offset of field: SCIP_Tree::root"][::std::mem::offset_of!(SCIP_Tree, root) - 0usize];
    ["Offset of field: SCIP_Tree::leaves"][::std::mem::offset_of!(SCIP_Tree, leaves) - 8usize];
    ["Offset of field: SCIP_Tree::path"][::std::mem::offset_of!(SCIP_Tree, path) - 16usize];
    ["Offset of field: SCIP_Tree::focusnode"]
        [::std::mem::offset_of!(SCIP_Tree, focusnode) - 24usize];
    ["Offset of field: SCIP_Tree::focuslpfork"]
        [::std::mem::offset_of!(SCIP_Tree, focuslpfork) - 32usize];
    ["Offset of field: SCIP_Tree::focuslpstatefork"]
        [::std::mem::offset_of!(SCIP_Tree, focuslpstatefork) - 40usize];
    ["Offset of field: SCIP_Tree::focussubroot"]
        [::std::mem::offset_of!(SCIP_Tree, focussubroot) - 48usize];
    ["Offset of field: SCIP_Tree::probingroot"]
        [::std::mem::offset_of!(SCIP_Tree, probingroot) - 56usize];
    ["Offset of field: SCIP_Tree::children"][::std::mem::offset_of!(SCIP_Tree, children) - 64usize];
    ["Offset of field: SCIP_Tree::siblings"][::std::mem::offset_of!(SCIP_Tree, siblings) - 72usize];
    ["Offset of field: SCIP_Tree::childrenprio"]
        [::std::mem::offset_of!(SCIP_Tree, childrenprio) - 80usize];
    ["Offset of field: SCIP_Tree::siblingsprio"]
        [::std::mem::offset_of!(SCIP_Tree, siblingsprio) - 88usize];
    ["Offset of field: SCIP_Tree::divebdchgvars"]
        [::std::mem::offset_of!(SCIP_Tree, divebdchgvars) - 96usize];
    ["Offset of field: SCIP_Tree::divebdchgdirs"]
        [::std::mem::offset_of!(SCIP_Tree, divebdchgdirs) - 112usize];
    ["Offset of field: SCIP_Tree::divebdchgvals"]
        [::std::mem::offset_of!(SCIP_Tree, divebdchgvals) - 128usize];
    ["Offset of field: SCIP_Tree::pathnlpcols"]
        [::std::mem::offset_of!(SCIP_Tree, pathnlpcols) - 144usize];
    ["Offset of field: SCIP_Tree::pathnlprows"]
        [::std::mem::offset_of!(SCIP_Tree, pathnlprows) - 152usize];
    ["Offset of field: SCIP_Tree::probinglpistate"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpistate) - 160usize];
    ["Offset of field: SCIP_Tree::focuslpistate"]
        [::std::mem::offset_of!(SCIP_Tree, focuslpistate) - 168usize];
    ["Offset of field: SCIP_Tree::probinglpinorms"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpinorms) - 176usize];
    ["Offset of field: SCIP_Tree::pendingbdchgs"]
        [::std::mem::offset_of!(SCIP_Tree, pendingbdchgs) - 184usize];
    ["Offset of field: SCIP_Tree::probdiverelaxsol"]
        [::std::mem::offset_of!(SCIP_Tree, probdiverelaxsol) - 192usize];
    ["Offset of field: SCIP_Tree::probinglpobjval"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpobjval) - 200usize];
    ["Offset of field: SCIP_Tree::nprobdiverelaxsol"]
        [::std::mem::offset_of!(SCIP_Tree, nprobdiverelaxsol) - 208usize];
    ["Offset of field: SCIP_Tree::focuslpstateforklpcount"]
        [::std::mem::offset_of!(SCIP_Tree, focuslpstateforklpcount) - 216usize];
    ["Offset of field: SCIP_Tree::lastbranchparentid"]
        [::std::mem::offset_of!(SCIP_Tree, lastbranchparentid) - 224usize];
    ["Offset of field: SCIP_Tree::divebdchgsize"]
        [::std::mem::offset_of!(SCIP_Tree, divebdchgsize) - 232usize];
    ["Offset of field: SCIP_Tree::ndivebdchanges"]
        [::std::mem::offset_of!(SCIP_Tree, ndivebdchanges) - 240usize];
    ["Offset of field: SCIP_Tree::pendingbdchgssize"]
        [::std::mem::offset_of!(SCIP_Tree, pendingbdchgssize) - 248usize];
    ["Offset of field: SCIP_Tree::npendingbdchgs"]
        [::std::mem::offset_of!(SCIP_Tree, npendingbdchgs) - 252usize];
    ["Offset of field: SCIP_Tree::childrensize"]
        [::std::mem::offset_of!(SCIP_Tree, childrensize) - 256usize];
    ["Offset of field: SCIP_Tree::nchildren"]
        [::std::mem::offset_of!(SCIP_Tree, nchildren) - 260usize];
    ["Offset of field: SCIP_Tree::siblingssize"]
        [::std::mem::offset_of!(SCIP_Tree, siblingssize) - 264usize];
    ["Offset of field: SCIP_Tree::nsiblings"]
        [::std::mem::offset_of!(SCIP_Tree, nsiblings) - 268usize];
    ["Offset of field: SCIP_Tree::pathlen"][::std::mem::offset_of!(SCIP_Tree, pathlen) - 272usize];
    ["Offset of field: SCIP_Tree::pathsize"]
        [::std::mem::offset_of!(SCIP_Tree, pathsize) - 276usize];
    ["Offset of field: SCIP_Tree::effectiverootdepth"]
        [::std::mem::offset_of!(SCIP_Tree, effectiverootdepth) - 280usize];
    ["Offset of field: SCIP_Tree::updatedeffectiverootdepth"]
        [::std::mem::offset_of!(SCIP_Tree, updatedeffectiverootdepth) - 284usize];
    ["Offset of field: SCIP_Tree::correctlpdepth"]
        [::std::mem::offset_of!(SCIP_Tree, correctlpdepth) - 288usize];
    ["Offset of field: SCIP_Tree::cutoffdepth"]
        [::std::mem::offset_of!(SCIP_Tree, cutoffdepth) - 292usize];
    ["Offset of field: SCIP_Tree::repropdepth"]
        [::std::mem::offset_of!(SCIP_Tree, repropdepth) - 296usize];
    ["Offset of field: SCIP_Tree::repropsubtreecount"]
        [::std::mem::offset_of!(SCIP_Tree, repropsubtreecount) - 300usize];
    ["Offset of field: SCIP_Tree::probingsumchgdobjs"]
        [::std::mem::offset_of!(SCIP_Tree, probingsumchgdobjs) - 304usize];
    ["Offset of field: SCIP_Tree::focusnodehaslp"]
        [::std::mem::offset_of!(SCIP_Tree, focusnodehaslp) - 308usize];
    ["Offset of field: SCIP_Tree::probingnodehaslp"]
        [::std::mem::offset_of!(SCIP_Tree, probingnodehaslp) - 312usize];
    ["Offset of field: SCIP_Tree::focuslpconstructed"]
        [::std::mem::offset_of!(SCIP_Tree, focuslpconstructed) - 316usize];
    ["Offset of field: SCIP_Tree::cutoffdelayed"]
        [::std::mem::offset_of!(SCIP_Tree, cutoffdelayed) - 320usize];
    ["Offset of field: SCIP_Tree::probinglpwasflushed"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasflushed) - 324usize];
    ["Offset of field: SCIP_Tree::probinglpwassolved"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwassolved) - 328usize];
    ["Offset of field: SCIP_Tree::probingloadlpistate"]
        [::std::mem::offset_of!(SCIP_Tree, probingloadlpistate) - 332usize];
    ["Offset of field: SCIP_Tree::probinglpwasrelax"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasrelax) - 336usize];
    ["Offset of field: SCIP_Tree::probingsolvedlp"]
        [::std::mem::offset_of!(SCIP_Tree, probingsolvedlp) - 340usize];
    ["Offset of field: SCIP_Tree::forcinglpmessage"]
        [::std::mem::offset_of!(SCIP_Tree, forcinglpmessage) - 344usize];
    ["Offset of field: SCIP_Tree::probingobjchanged"]
        [::std::mem::offset_of!(SCIP_Tree, probingobjchanged) - 348usize];
    ["Offset of field: SCIP_Tree::sbprobing"]
        [::std::mem::offset_of!(SCIP_Tree, sbprobing) - 352usize];
    ["Offset of field: SCIP_Tree::probinglpwasprimfeas"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasprimfeas) - 356usize];
    ["Offset of field: SCIP_Tree::probinglpwasprimchecked"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasprimchecked) - 360usize];
    ["Offset of field: SCIP_Tree::probinglpwasdualfeas"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasdualfeas) - 364usize];
    ["Offset of field: SCIP_Tree::probinglpwasdualchecked"]
        [::std::mem::offset_of!(SCIP_Tree, probinglpwasdualchecked) - 368usize];
    ["Offset of field: SCIP_Tree::probinglphadsafebound"]
        [::std::mem::offset_of!(SCIP_Tree, probinglphadsafebound) - 372usize];
    ["Offset of field: SCIP_Tree::probdiverelaxstored"]
        [::std::mem::offset_of!(SCIP_Tree, probdiverelaxstored) - 376usize];
    ["Offset of field: SCIP_Tree::probdiverelaxincludeslp"]
        [::std::mem::offset_of!(SCIP_Tree, probdiverelaxincludeslp) - 380usize];
};
unsafe extern "C" {
    #[doc = " creates a child node of the focus node"]
    pub fn SCIPnodeCreateChild(
        node: *mut *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        nodeselprio: f64,
        estimate: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees node and inactive path iteratively"]
    pub fn SCIPnodeFree(
        node: *mut *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " increases the reference counter of the LP state in the fork or subroot node"]
    pub fn SCIPnodeCaptureLPIState(
        node: *mut SCIP_NODE,
        nuses: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " decreases the reference counter of the LP state in the fork or subroot node"]
    pub fn SCIPnodeReleaseLPIState(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " installs a child, a sibling, or a leaf node as the new focus node"]
    pub fn SCIPnodeFocus(
        node: *mut *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        conflict: *mut SCIP_CONFLICT,
        conflictstore: *mut SCIP_CONFLICTSTORE,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        cutoff: *mut ::std::os::raw::c_uint,
        postponed: ::std::os::raw::c_uint,
        exitsolve: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cuts off node and whole sub tree from branch and bound tree"]
    pub fn SCIPnodeCutoff(
        node: *mut SCIP_NODE,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        blkmem: *mut BMS_BLKMEM,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks node, that propagation should be applied again the next time, a node of its subtree is focused"]
    pub fn SCIPnodePropagateAgain(
        node: *mut SCIP_NODE,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
    );
}
unsafe extern "C" {
    #[doc = " marks node, that it is completely propagated in the current repropagation subtree level"]
    pub fn SCIPnodeMarkPropagated(node: *mut SCIP_NODE, tree: *mut SCIP_TREE);
}
unsafe extern "C" {
    #[doc = " adds constraint locally to the node and captures it; activates constraint, if node is active;\n  if a local constraint is added to the root node, it is automatically upgraded into a global constraint"]
    pub fn SCIPnodeAddCons(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " locally deletes constraint at the given node by disabling its separation, enforcing, and propagation capabilities\n  at the node; captures constraint; disables constraint, if node is active"]
    pub fn SCIPnodeDelCons(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return all bound changes on non-continuous variables based on constraint and propagator propagation\n\n Stop saving the bound changes when a propagation based on a dual information is reached."]
    pub fn SCIPnodeGetPropsBeforeDual(
        node: *mut SCIP_NODE,
        vars: *mut *mut SCIP_VAR,
        varbounds: *mut f64,
        varboundtypes: *mut SCIP_BOUNDTYPE,
        npropvars: *mut ::std::os::raw::c_int,
        propvarssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " return bound changes on non-continuous variables based on constraint and propagator propagation\n\n Start saving the bound changes when a propagation based on a dual information is reached.\n\n @note Currently, we can only detect bound changes based in dual information if they arise from strong branching."]
    pub fn SCIPnodeGetPropsAfterDual(
        node: *mut SCIP_NODE,
        vars: *mut *mut SCIP_VAR,
        varbounds: *mut f64,
        varboundtypes: *mut SCIP_BOUNDTYPE,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " adds bound change with inference information to focus node, child of focus node, or probing node;\n  if possible, adjusts bound to integral value;\n  at most one of infercons and inferprop may be non-NULL"]
    pub fn SCIPnodeAddBoundinfer(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        var: *mut SCIP_VAR,
        newbound: f64,
        boundtype: SCIP_BOUNDTYPE,
        infercons: *mut SCIP_CONS,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        probingchange: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds exact bound change with inference information to focus node, child of focus node, or probing node;\n  if possible, adjusts bound to integral value;\n  at most one of infercons and inferprop may be non-NULL"]
    pub fn SCIPnodeAddBoundinferExact(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lpexact: *mut SCIP_LPEXACT,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        boundtype: SCIP_BOUNDTYPE,
        infercons: *mut SCIP_CONS,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        probingchange: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds bound change to focus node, or child of focus node, or probing node;\n  if possible, adjusts bound to integral value"]
    pub fn SCIPnodeAddBoundchg(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        var: *mut SCIP_VAR,
        newbound: f64,
        boundtype: SCIP_BOUNDTYPE,
        probingchange: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds exact bound change to focus node, or child of focus node, or probing node;\n  if possible, adjusts bound to integral value"]
    pub fn SCIPnodeAddBoundchgExact(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lpexact: *mut SCIP_LPEXACT,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        var: *mut SCIP_VAR,
        newbound: *mut SCIP_RATIONAL,
        boundtype: SCIP_BOUNDTYPE,
        probingchange: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds hole with inference information to focus node, child of focus node, or probing node;\n  if possible, adjusts bound to integral value;\n  at most one of infercons and inferprop may be non-NULL"]
    pub fn SCIPnodeAddHoleinfer(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        eventqueue: *mut SCIP_EVENTQUEUE,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        infercons: *mut SCIP_CONS,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        probingchange: ::std::os::raw::c_uint,
        added: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds hole change to focus node, or child of focus node"]
    pub fn SCIPnodeAddHolechg(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        tree: *mut SCIP_TREE,
        eventqueue: *mut SCIP_EVENTQUEUE,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        probingchange: ::std::os::raw::c_uint,
        added: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " if given value is larger than the node's lower bound, sets the node's lower bound to the new value"]
    pub fn SCIPnodeUpdateLowerbound(
        node: *mut SCIP_NODE,
        stat: *mut SCIP_STAT,
        set: *mut SCIP_SET,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        newbound: f64,
        newboundexact: *mut SCIP_RATIONAL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates lower bound of node using lower bound of LP"]
    pub fn SCIPnodeUpdateLowerboundLP(
        node: *mut SCIP_NODE,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        eventfilter: *mut SCIP_EVENTFILTER,
        tree: *mut SCIP_TREE,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " change the node selection priority of the given child"]
    pub fn SCIPchildChgNodeselPrio(tree: *mut SCIP_TREE, child: *mut SCIP_NODE, priority: f64);
}
unsafe extern "C" {
    #[doc = " sets the node's estimated bound to the new value"]
    pub fn SCIPnodeSetEstimate(node: *mut SCIP_NODE, set: *mut SCIP_SET, newestimate: f64);
}
unsafe extern "C" {
    #[doc = " propagates implications of binary fixings at the given node triggered by the implication graph and the clique table"]
    pub fn SCIPnodePropagateImplics(
        node: *mut SCIP_NODE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns all bound changes based on dual information.\n\n  currently, this methods works only for bound changes made by strong branching on binary variables. we need this\n  method to ensure optimality within reoptimization.\n\n  since the bound changes made by strong branching are stored as SCIP_BOUNDCHGTYPE_CONSINFER or SCIP_BOUNDCHGTYPE_PROPINFER\n  with no constraint or propagator, resp., we are are interested in bound changes with these attributes.\n\n  all bound changes of type SCIP_BOUNDCHGTYPE_BRANCHING are stored in the beginning of the bound change array, afterwards,\n  we can find the other two types. thus, we start the search at the end of the list and stop when reaching the first\n  bound change of type SCIP_BOUNDCHGTYPE_BRANCHING."]
    pub fn SCIPnodeGetDualBoundchgs(
        node: *mut SCIP_NODE,
        vars: *mut *mut SCIP_VAR,
        bounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " returns the number of bound changes based on dual information.\n\n  currently, this methods works only for bound changes made by strong branching on binary variables. we need this\n  method to ensure optimality within reoptimization.\n\n  since the bound changes made by strong branching are stored as SCIP_BOUNDCHGTYPE_CONSINFER or SCIP_BOUNDCHGTYPE_PROPINFER\n  with no constraint or propagator, resp., we are are interested in bound changes with these attributes.\n\n  all bound changes of type SCIP_BOUNDCHGTYPE_BRANCHING are stored in the beginning of the bound change array, afterwards,\n  we can find the other two types. thus, we start the search at the end of the list and stop when reaching the first\n  bound change of type SCIP_BOUNDCHGTYPE_BRANCHING."]
    pub fn SCIPnodeGetNDualBndchgs(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates an initialized tree data structure"]
    pub fn SCIPtreeCreate(
        tree: *mut *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        nodesel: *mut SCIP_NODESEL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees tree data structure"]
    pub fn SCIPtreeFree(
        tree: *mut *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " clears and resets tree data structure and deletes all nodes"]
    pub fn SCIPtreeClear(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the root node of the tree and puts it into the leaves queue"]
    pub fn SCIPtreeCreateRoot(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a temporary presolving root node of the tree and installs it as focus node"]
    pub fn SCIPtreeCreatePresolvingRoot(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        conflict: *mut SCIP_CONFLICT,
        conflictstore: *mut SCIP_CONFLICTSTORE,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the temporary presolving root and resets tree data structure"]
    pub fn SCIPtreeFreePresolvingRoot(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        primal: *mut SCIP_PRIMAL,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        conflict: *mut SCIP_CONFLICT,
        conflictstore: *mut SCIP_CONFLICTSTORE,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the node selector associated with the given node priority queue"]
    pub fn SCIPtreeGetNodesel(tree: *mut SCIP_TREE) -> *mut SCIP_NODESEL;
}
unsafe extern "C" {
    #[doc = " sets the node selector used for sorting the nodes in the priority queue, and resorts the queue if necessary"]
    pub fn SCIPtreeSetNodesel(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        nodesel: *mut SCIP_NODESEL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cuts off nodes with lower bound not better than given upper bound"]
    pub fn SCIPtreeCutoff(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        lp: *mut SCIP_LP,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " constructs the LP relaxation of the focus node"]
    pub fn SCIPtreeLoadLP(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        lp: *mut SCIP_LP,
        initroot: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads LP state for fork/subroot of the focus node"]
    pub fn SCIPtreeLoadLPState(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        stat: *mut SCIP_STAT,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " calculates the node selection priority for moving the given variable's LP value to the given target value;\n  this node selection priority can be given to the SCIPcreateChild() call"]
    pub fn SCIPtreeCalcNodeselPriority(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
        branchdir: SCIP_BRANCHDIR,
        targetvalue: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " calculates an estimate for the objective of the best feasible solution contained in the subtree after applying the given\n  branching; this estimate can be given to the SCIPcreateChild() call"]
    pub fn SCIPtreeCalcChildEstimate(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        var: *mut SCIP_VAR,
        targetvalue: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " branches on a variable x\n  if x is a continuous variable, then two child nodes will be created\n  (x <= x', x >= x')\n  but if the bounds of x are such that their relative difference is smaller than epsilon,\n  the variable is fixed to val (if not SCIP_INVALID) or a well chosen alternative in the current node,\n  i.e., no children are created\n  if x is not a continuous variable, then:\n  if solution value x' is fractional, two child nodes will be created\n  (x <= floor(x'), x >= ceil(x')),\n  if solution value is integral, the x' is equal to lower or upper bound of the branching\n  variable and the bounds of x are finite, then two child nodes will be created\n  (x <= x\", x >= x\"+1 with x\" = floor((lb + ub)/2)),\n  otherwise (up to) three child nodes will be created\n  (x <= x'-1, x == x', x >= x'+1)\n  if solution value is equal to one of the bounds and the other bound is infinite, only two child nodes\n  will be created (the third one would be infeasible anyway)"]
    pub fn SCIPtreeBranchVar(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        var: *mut SCIP_VAR,
        val: f64,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " branches on a variable x; unlike the fp-version this will also branch x <= floor(x'), x >= ceil(x')\n if x' is very close to being integral at one of its bounds;\n in the fp version this case would be branched in the middle of the domain;\n not meant for branching on a continuous variables"]
    pub fn SCIPtreeBranchVarExact(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        var: *mut SCIP_VAR,
        downchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " branches a variable x using the given domain hole; two child nodes will be created (x <= left, x >= right)"]
    pub fn SCIPtreeBranchVarHole(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        downchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " n-ary branching on a variable x\n Branches on variable x such that up to n/2 children are created on each side of the usual branching value.\n The branching value is selected as in SCIPtreeBranchVar().\n If n is 2 or the variables local domain is too small for a branching into n pieces, SCIPtreeBranchVar() is called.\n The parameters minwidth and widthfactor determine the domain width of the branching variable in the child nodes.\n If n is odd, one child with domain width 'width' and having the branching value in the middle is created.\n Otherwise, two children with domain width 'width' and being left and right of the branching value are created.\n Next further nodes to the left and right are created, where width is multiplied by widthfactor with increasing distance from the first nodes.\n The initial width is calculated such that n/2 nodes are created to the left and to the right of the branching value.\n If this value is below minwidth, the initial width is set to minwidth, which may result in creating less than n nodes.\n\n Giving a large value for widthfactor results in creating children with small domain when close to the branching value\n and large domain when closer to the current variable bounds. That is, setting widthfactor to a very large value and n to 3\n results in a ternary branching where the branching variable is mostly fixed in the middle child.\n Setting widthfactor to 1.0 results in children where the branching variable always has the same domain width\n (except for one child if the branching value is not in the middle)."]
    pub fn SCIPtreeBranchVarNary(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        var: *mut SCIP_VAR,
        val: f64,
        n: ::std::os::raw::c_int,
        minwidth: f64,
        widthfactor: f64,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a diving bound change to the tree together with the information if this is a bound change\n  for the preferred direction or not"]
    pub fn SCIPtreeAddDiveBoundChange(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        value: f64,
        preferred: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get the dive bound change data for the preferred or the alternative direction"]
    pub fn SCIPtreeGetDiveBoundChangeData(
        tree: *mut SCIP_TREE,
        variables: *mut *mut *mut SCIP_VAR,
        directions: *mut *mut SCIP_BRANCHDIR,
        values: *mut *mut f64,
        ndivebdchgs: *mut ::std::os::raw::c_int,
        preferred: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " clear the tree dive bound change data structure"]
    pub fn SCIPtreeClearDiveBoundChanges(tree: *mut SCIP_TREE);
}
unsafe extern "C" {
    #[doc = " switches to probing mode and creates a probing root"]
    pub fn SCIPtreeStartProbing(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
        relaxation: *mut SCIP_RELAXATION,
        transprob: *mut SCIP_PROB,
        strongbranching: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a new probing child node in the probing path"]
    pub fn SCIPtreeCreateProbingNode(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the LP state for the current probing node\n\n  @note state and norms are stored at the node and later released by SCIP; therefore, the pointers are set\n        to NULL by the method\n\n  @note the pointers to state and norms must not be NULL; however, they may point to a NULL pointer if the\n        respective information should not be set"]
    pub fn SCIPtreeSetProbingLPState(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        lp: *mut SCIP_LP,
        lpistate: *mut *mut SCIP_LPISTATE,
        lpinorms: *mut *mut SCIP_LPINORMS,
        primalfeas: ::std::os::raw::c_uint,
        dualfeas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " loads the LP state for the current probing node"]
    pub fn SCIPtreeLoadProbingLPState(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        prob: *mut SCIP_PROB,
        eventqueue: *mut SCIP_EVENTQUEUE,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " marks the probing node to have a solved LP relaxation"]
    pub fn SCIPtreeMarkProbingNodeHasLP(
        tree: *mut SCIP_TREE,
        blkmem: *mut BMS_BLKMEM,
        lp: *mut SCIP_LP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " undoes all changes to the problem applied in probing up to the given probing depth;\n  the changes of the probing node of the given probing depth are the last ones that remain active;\n  changes that were applied before calling SCIPtreeCreateProbingNode() cannot be undone"]
    pub fn SCIPtreeBacktrackProbing(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        primal: *mut SCIP_PRIMAL,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
        probingdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " switches back from probing to normal operation mode, frees all nodes on the probing path, restores bounds of all\n  variables and restores active constraints arrays of focus node"]
    pub fn SCIPtreeEndProbing(
        tree: *mut SCIP_TREE,
        reopt: *mut SCIP_REOPT,
        blkmem: *mut BMS_BLKMEM,
        set: *mut SCIP_SET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        stat: *mut SCIP_STAT,
        transprob: *mut SCIP_PROB,
        origprob: *mut SCIP_PROB,
        lp: *mut SCIP_LP,
        relaxation: *mut SCIP_RELAXATION,
        primal: *mut SCIP_PRIMAL,
        branchcand: *mut SCIP_BRANCHCAND,
        eventqueue: *mut SCIP_EVENTQUEUE,
        eventfilter: *mut SCIP_EVENTFILTER,
        cliquetable: *mut SCIP_CLIQUETABLE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores relaxation solution before diving or probing"]
    pub fn SCIPtreeStoreRelaxSol(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
        relaxation: *mut SCIP_RELAXATION,
        transprob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " restores relaxation solution after diving or probing"]
    pub fn SCIPtreeRestoreRelaxSol(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
        relaxation: *mut SCIP_RELAXATION,
        transprob: *mut SCIP_PROB,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of children of the focus node"]
    pub fn SCIPtreeGetNChildren(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of siblings of the focus node"]
    pub fn SCIPtreeGetNSiblings(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of leaves in the tree (excluding children and siblings of focus nodes)"]
    pub fn SCIPtreeGetNLeaves(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets number of open nodes in the tree (children + siblings + leaves)"]
    pub fn SCIPtreeGetNNodes(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the active path goes completely down to the focus node"]
    pub fn SCIPtreeIsPathComplete(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the current node is a temporary probing node"]
    pub fn SCIPtreeProbing(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the temporary probing root node, or NULL if the we are not in probing mode"]
    pub fn SCIPtreeGetProbingRoot(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " returns the current probing depth, i.e. the number of probing sub nodes existing in the probing path"]
    pub fn SCIPtreeGetProbingDepth(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets focus node of the tree"]
    pub fn SCIPtreeGetFocusNode(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets depth of focus node in the tree, or -1 if no focus node exists"]
    pub fn SCIPtreeGetFocusDepth(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the LP was or is to be solved in the focus node"]
    pub fn SCIPtreeHasFocusNodeLP(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " sets mark to solve or to ignore the LP while processing the focus node"]
    pub fn SCIPtreeSetFocusNodeLP(tree: *mut SCIP_TREE, solvelp: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " returns whether the LP of the focus node is already constructed"]
    pub fn SCIPtreeIsFocusNodeLPConstructed(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether the focus node is already solved and only propagated again"]
    pub fn SCIPtreeInRepropagation(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gets current node of the tree, i.e. the last node in the active path, or NULL if no current node exists"]
    pub fn SCIPtreeGetCurrentNode(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets depth of current node in the tree, i.e. the length of the active path minus 1, or -1 if no current node exists"]
    pub fn SCIPtreeGetCurrentDepth(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether the LP was or is to be solved in the current node"]
    pub fn SCIPtreeHasCurrentNodeLP(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the depth of the effective root node (i.e. the first depth level of a node with at least two children)"]
    pub fn SCIPtreeGetEffectiveRootDepth(tree: *mut SCIP_TREE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets the root node of the tree"]
    pub fn SCIPtreeGetRootNode(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " returns whether we are in probing and the objective value of at least one column was changed"]
    pub fn SCIPtreeProbingObjChanged(tree: *mut SCIP_TREE) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " marks the current probing node to have a changed objective function"]
    pub fn SCIPtreeMarkProbingObjChanged(tree: *mut SCIP_TREE);
}
unsafe extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    pub fn SCIPtreeGetPrioChild(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    pub fn SCIPtreeGetPrioSibling(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection strategy"]
    pub fn SCIPtreeGetBestChild(tree: *mut SCIP_TREE, set: *mut SCIP_SET) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection strategy"]
    pub fn SCIPtreeGetBestSibling(tree: *mut SCIP_TREE, set: *mut SCIP_SET) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best leaf from the node queue w.r.t. the node selection strategy"]
    pub fn SCIPtreeGetBestLeaf(tree: *mut SCIP_TREE) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy"]
    pub fn SCIPtreeGetBestNode(tree: *mut SCIP_TREE, set: *mut SCIP_SET) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the minimal lower bound of all nodes in the tree"]
    pub fn SCIPtreeGetLowerbound(tree: *mut SCIP_TREE, set: *mut SCIP_SET) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the minimal exact lower bound of all nodes in the tree or NULL if empty\n\n  @note The user must not modify the return value."]
    pub fn SCIPtreeGetLowerboundExact(
        tree: *mut SCIP_TREE,
        set: *mut SCIP_SET,
    ) -> *mut SCIP_RATIONAL;
}
unsafe extern "C" {
    #[doc = " gets the node with minimal lower bound of all nodes in the tree (child, sibling, or leaf)"]
    pub fn SCIPtreeGetLowerboundNode(tree: *mut SCIP_TREE, set: *mut SCIP_SET) -> *mut SCIP_NODE;
}
unsafe extern "C" {
    #[doc = " gets the average lower bound of all nodes in the tree"]
    pub fn SCIPtreeGetAvgLowerbound(tree: *mut SCIP_TREE, cutoffbound: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " query if focus node was already branched on"]
    pub fn SCIPtreeWasNodeLastBranchParent(
        tree: *mut SCIP_TREE,
        node: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for ExactSol constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrExactSol(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for linking constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLinking(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linking constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLinking(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linkvar: *mut SCIP_VAR,
        binvars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nbinvars: ::std::os::raw::c_int,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a linking constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLinking(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLinking() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLinking(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linkvar: *mut SCIP_VAR,
        binvars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nbinvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks if for the given linking variable (continuous or integer) a linking constraint exists"]
    pub fn SCIPexistsConsLinking(scip: *mut SCIP, linkvar: *mut SCIP_VAR)
    -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the linking constraint belonging the given linking variable (continuous or integer) or NULL if it does not exist yet"]
    pub fn SCIPgetConsLinking(scip: *mut SCIP, linkvar: *mut SCIP_VAR) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " returns the linking variable (continuous or integer) of the linking constraint"]
    pub fn SCIPgetLinkvarLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the binary variables of the linking constraint"]
    pub fn SCIPgetBinvarsLinking(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        binvars: *mut *mut *mut SCIP_VAR,
        nbinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the number of binary variables of the linking constraint"]
    pub fn SCIPgetNBinvarsLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the coefficients of the binary variables"]
    pub fn SCIPgetValsLinking(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " return all binary variable information of the linking constraint"]
    pub fn SCIPgetBinvarsDataLinking(
        cons: *mut SCIP_CONS,
        binvars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        nbinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for logic or constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrLogicor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a logic or constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsLogicor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a logicor constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsLogicor(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsLogicor() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicLogicor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coefficient in logic or constraint"]
    pub fn SCIPaddCoefLogicor(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in logic or constraint"]
    pub fn SCIPgetNVarsLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in logic or constraint"]
    pub fn SCIPgetVarsLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the logic or constraint in the current LP"]
    pub fn SCIPgetDualsolLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the logic or constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given logic or constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of the given logicor constraint"]
    pub fn SCIPcreateRowLogicor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from logicor constraints"]
    pub fn SCIPcleanupConssLogicor(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
pub type SCIP_NLHDLR_METHOD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlhdlr {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLR = SCIP_Nlhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLRDATA = SCIP_NlhdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlhdlrExprData {
    _unused: [u8; 0],
}
pub type SCIP_NLHDLREXPRDATA = SCIP_NlhdlrExprData;
#[doc = " linear auxiliary expression of the form xy {&le;,&ge;,=} coefs[0]w + coefs[1]x + coefs[2]y + cst"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsNonlinear_Auxexpr {
    #[doc = "< coefficients in the auxiliary expression"]
    pub coefs: [f64; 3usize],
    #[doc = "< constant"]
    pub cst: f64,
    #[doc = "< auxiliary variable w in xy {&le;,&ge;,=} auxexpr(w, x, y)"]
    pub auxvar: *mut SCIP_VAR,
    #[doc = "< whether the auxexpr underestimates the product"]
    pub underestimate: ::std::os::raw::c_uint,
    #[doc = "< whether the auxexpr overestimates the product"]
    pub overestimate: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_ConsNonlinear_Auxexpr"]
        [::std::mem::size_of::<SCIP_ConsNonlinear_Auxexpr>() - 48usize];
    ["Alignment of SCIP_ConsNonlinear_Auxexpr"]
        [::std::mem::align_of::<SCIP_ConsNonlinear_Auxexpr>() - 8usize];
    ["Offset of field: SCIP_ConsNonlinear_Auxexpr::coefs"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_Auxexpr, coefs) - 0usize];
    ["Offset of field: SCIP_ConsNonlinear_Auxexpr::cst"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_Auxexpr, cst) - 24usize];
    ["Offset of field: SCIP_ConsNonlinear_Auxexpr::auxvar"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_Auxexpr, auxvar) - 32usize];
    ["Offset of field: SCIP_ConsNonlinear_Auxexpr::underestimate"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_Auxexpr, underestimate) - 40usize];
    ["Offset of field: SCIP_ConsNonlinear_Auxexpr::overestimate"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_Auxexpr, overestimate) - 44usize];
};
#[doc = " linear auxiliary expression of the form xy {&le;,&ge;,=} coefs[0]w + coefs[1]x + coefs[2]y + cst"]
pub type SCIP_CONSNONLINEAR_AUXEXPR = SCIP_ConsNonlinear_Auxexpr;
#[doc = " bilinear term structure\n\n This can represent a product which\n - explicitly exists in the problem and is under- and/or overestimated by a single auxiliary variable\n   stored as `var` in the union `aux` (case `nauxexprs` = 0) or\n - is involved in bilinear relations implicitly given by linear constraints with binary variables, and\n   is under- and/or overestimated by linear expression(s) stored as `exprs` in the union `aux` (case `nauxexprs` > 0).\n\n An explicitly existing product can also be involved in implicit relations, then it will be stored as in\n the second case."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_ConsNonlinear_BilinTerm {
    #[doc = "< first variable"]
    pub x: *mut SCIP_VAR,
    #[doc = "< second variable"]
    pub y: *mut SCIP_VAR,
    pub aux: SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1,
    #[doc = "< number of aux.exprs (0 for products without implicit relations)"]
    pub nauxexprs: ::std::os::raw::c_int,
    #[doc = "< size of the aux.exprs array"]
    pub auxexprssize: ::std::os::raw::c_int,
    #[doc = "< number of positive expression locks"]
    pub nlockspos: ::std::os::raw::c_int,
    #[doc = "< number of negative expression locks"]
    pub nlocksneg: ::std::os::raw::c_int,
    #[doc = "< does the product exist explicitly in the problem?"]
    pub existing: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1 {
    #[doc = "< auxiliary expressions for the implicit product of x and y"]
    pub exprs: *mut *mut SCIP_CONSNONLINEAR_AUXEXPR,
    #[doc = "< auxiliary variable for the explicit product of x and y"]
    pub var: *mut SCIP_VAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1"]
        [::std::mem::size_of::<SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1>() - 8usize];
    ["Alignment of SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1"]
        [::std::mem::align_of::<SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1>() - 8usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1::exprs"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1, exprs) - 0usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1::var"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm__bindgen_ty_1, var) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SCIP_ConsNonlinear_BilinTerm"]
        [::std::mem::size_of::<SCIP_ConsNonlinear_BilinTerm>() - 48usize];
    ["Alignment of SCIP_ConsNonlinear_BilinTerm"]
        [::std::mem::align_of::<SCIP_ConsNonlinear_BilinTerm>() - 8usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::x"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, x) - 0usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::y"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, y) - 8usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::aux"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, aux) - 16usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::nauxexprs"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, nauxexprs) - 24usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::auxexprssize"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, auxexprssize) - 28usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::nlockspos"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, nlockspos) - 32usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::nlocksneg"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, nlocksneg) - 36usize];
    ["Offset of field: SCIP_ConsNonlinear_BilinTerm::existing"]
        [::std::mem::offset_of!(SCIP_ConsNonlinear_BilinTerm, existing) - 40usize];
};
#[doc = " bilinear term structure\n\n This can represent a product which\n - explicitly exists in the problem and is under- and/or overestimated by a single auxiliary variable\n   stored as `var` in the union `aux` (case `nauxexprs` = 0) or\n - is involved in bilinear relations implicitly given by linear constraints with binary variables, and\n   is under- and/or overestimated by linear expression(s) stored as `exprs` in the union `aux` (case `nauxexprs` > 0).\n\n An explicitly existing product can also be involved in implicit relations, then it will be stored as in\n the second case."]
pub type SCIP_CONSNONLINEAR_BILINTERM = SCIP_ConsNonlinear_BilinTerm;
unsafe extern "C" {
    #[doc = " creates the handler for nonlinear constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrNonlinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes a nonlinear constraint upgrade method into the nonlinear constraint handler"]
    pub fn SCIPincludeConsUpgradeNonlinear(
        scip: *mut SCIP,
        nlconsupgd: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut SCIP_CONS,
                nvarexprs: ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                upgdconss: *mut *mut SCIP_CONS,
                upgdconsssize: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        priority: ::std::os::raw::c_int,
        active: ::std::os::raw::c_uint,
        conshdlrname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear constraint with all its constraint flags set to their default values\n\n  All flags can be set via SCIPconsSetFLAGNAME-methods.\n\n  @see SCIPcreateConsNonlinear() for information about the basic constraint flag configuration.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        expr: *mut SCIP_EXPR,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a quadratic nonlinear constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a quadratic nonlinear constraint with all its constraint flags set to their default values\n\n  All flags can be set via SCIPconsSetFLAGNAME-methods.\n\n  @see SCIPcreateConsQuadraticNonlinear() for information about the basic constraint flag configuration.\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadterms: ::std::os::raw::c_int,
        quadvars1: *mut *mut SCIP_VAR,
        quadvars2: *mut *mut SCIP_VAR,
        quadcoefs: *mut f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a nonlinear constraint that is a second-order cone constraint with all its constraint flags set to their default values\n\n \\f$\\sqrt{\\gamma + \\sum_{i=1}^{n} (\\alpha_i\\, (x_i + \\beta_i))^2} \\leq \\alpha_{n+1}\\, (x_{n+1}+\\beta_{n+1})\\f$\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOCNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
        offsets: *mut f64,
        constant: f64,
        rhsvar: *mut SCIP_VAR,
        rhscoeff: f64,
        rhsoffset: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a signpower nonlinear constraint with all its constraint flags set to their default values\n\n \\f$\\textrm{lhs} \\leq \\textrm{sign}(x+a) |x+a|^n + c z \\leq \\textrm{rhs}\\f$\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSignpowerNonlinear(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        x: *mut SCIP_VAR,
        z: *mut SCIP_VAR,
        exponent: f64,
        xoffset: f64,
        zcoef: f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets tag indicating current local variable bounds"]
    pub fn SCIPgetCurBoundsTagNonlinear(conshdlr: *mut SCIP_CONSHDLR)
    -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " gets the `curboundstag` from the last time where variable bounds were relaxed"]
    pub fn SCIPgetLastBoundRelaxTagNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[doc = " increments `curboundstag` and resets `lastboundrelax` in constraint handler data\n\n @attention This method is not intended for normal use.\n   These tags are maintained by the event handler for variable bound change events.\n   This method is used by some unittests."]
    pub fn SCIPincrementCurBoundsTagNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        boundrelax: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " returns the hashmap that is internally used to map variables to their corresponding variable expressions"]
    pub fn SCIPgetVarExprHashmapNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_HASHMAP;
}
unsafe extern "C" {
    #[doc = " processes a rowprep for cut addition and maybe report branchscores"]
    pub fn SCIPprocessRowprepNonlinear(
        scip: *mut SCIP,
        nlhdlr: *mut SCIP_NLHDLR,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
        rowprep: *mut SCIP_ROWPREP,
        overestimate: ::std::os::raw::c_uint,
        auxvar: *mut SCIP_VAR,
        auxvalue: f64,
        allowweakcuts: ::std::os::raw::c_uint,
        branchscoresuccess: ::std::os::raw::c_uint,
        inenforcement: ::std::os::raw::c_uint,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether all nonlinear constraints are assumed to be convex"]
    pub fn SCIPassumeConvexNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " collects all bilinear terms for a given set of constraints\n\n @attention This method should only be used for unit tests that depend on SCIPgetBilinTermsNonlinear(),\n       SCIPgetBilinTermNonlinear() or SCIPgetBilinTermIdxNonlinear()."]
    pub fn SCIPcollectBilinTermsNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the total number of bilinear terms that are contained in all nonlinear constraints\n\n  @note This method should only be used after auxiliary variables have been created, i.e., after CONSINITLP."]
    pub fn SCIPgetNBilinTermsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns all bilinear terms that are contained in all nonlinear constraints\n\n @note This method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @note The value of the auxiliary variable of a bilinear term might be NULL, which indicates that the term does not have an auxiliary variable."]
    pub fn SCIPgetBilinTermsNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> *mut SCIP_CONSNONLINEAR_BILINTERM;
}
unsafe extern "C" {
    #[doc = " returns the index of the bilinear term representing the product of the two given variables\n\n @note The method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @return The method returns -1 if the variables do not appear bilinearly."]
    pub fn SCIPgetBilinTermIdxNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the bilinear term that represents the product of two given variables\n\n @note The method should only be used after auxiliary variables have been created, i.e., after CONSINITLP.\n @return The method returns NULL if the variables do not appear bilinearly."]
    pub fn SCIPgetBilinTermNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
    ) -> *mut SCIP_CONSNONLINEAR_BILINTERM;
}
unsafe extern "C" {
    #[doc = " evaluates an auxiliary expression for a bilinear term"]
    pub fn SCIPevalBilinAuxExprNonlinear(
        scip: *mut SCIP,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxexpr: *mut SCIP_CONSNONLINEAR_AUXEXPR,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " stores the variables of a bilinear term in the data of the constraint handler"]
    pub fn SCIPinsertBilinearTermExistingNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxvar: *mut SCIP_VAR,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " stores the variables of a bilinear term in the data of the constraint handler"]
    pub fn SCIPinsertBilinearTermImplicitNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        x: *mut SCIP_VAR,
        y: *mut SCIP_VAR,
        auxvar: *mut SCIP_VAR,
        coefx: f64,
        coefy: f64,
        coefaux: f64,
        cst: f64,
        overestimate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes a facet of the convex or concave envelope of a vertex polyhedral function\n\n If \\f$ f(x) \\f$ is vertex-polyhedral, then \\f$ g \\f$ is a convex underestimator if and only if\n \\f$ g(v^i) \\leq f(v^i), \\forall i \\f$, where \\f$ \\{ v^i \\}_{i = 1}^{2^n} \\subseteq \\mathbb R^n \\f$ are the vertices\n of the domain of \\f$ x \\f$, \\f$ [\\ell,u] \\f$. Hence, we can compute a linear underestimator by solving the following\n LP (we don't necessarily get a facet of the convex envelope, see below):\n\n \\f{align*}{\n              \\max \\, & \\alpha^T x^* + \\beta \\\\\n     s.t. \\; & \\alpha^T v^i + \\beta \\le f(v^i), \\, \\forall i = 1, \\ldots, 2^n\n \\f}\n\n In principle, one would need to update the LP whenever the domain changes. However, \\f$ [\\ell,u] = T([0, 1]^n) \\f$,\n where \\f$ T \\f$ is an affine linear invertible transformation given by \\f$ T(y)_i = (u_i - \\ell_i) y_i + \\ell_i \\f$.\n Working with the change of variables \\f$ x = T(y) \\f$ allows us to keep the constraints of the LP, even if the domain\n changes. Indeed, after the change of variables, the problem is: find an affine underestimator \\f$ g \\f$ such that \\f$\n g(T(y)) \\le f(T(y)) \\f$, for all \\f$ y \\in [0, 1]^n \\f$. Now \\f$ f(T(y)) \\f$ is componentwise affine, but still\n satisfies that \\f$ g \\f$ is a valid underestimator if and only if \\f$ g(T(u)) \\leq f(T(u)), \\forall u \\in \\{0, 1\\}^n\n \\f$. So we now look for \\f$ \\bar g(y) := g(T(y)) = g(((u_i - \\ell_i) y_i + \\ell_i)_i) = \\bar \\alpha^T y + \\bar \\beta\n \\f$, where \\f$ \\bar \\alpha_i = (u_i - \\ell_i) \\alpha_i \\f$ and \\f$ \\bar \\beta = \\sum_i \\alpha_i \\ell_i + \\beta \\f$. So\n we find \\f$ \\bar g \\f$ by solving the LP:\n\n \\f{align*}{\n              \\max \\, & \\bar \\alpha^T T^{-1}(x^*) + \\bar \\beta \\\\\n     s.t. \\; & \\bar \\alpha^T u + \\bar \\beta \\le f(T(u)), \\, \\forall u \\in \\{0, 1\\}^n\n \\f}\n\n and recover \\f$ g \\f$ by calculating \\f$ \\bar \\alpha_i = (u_i - \\ell_i) \\alpha_i, \\bar \\beta = \\sum_i \\alpha_i \\ell_i +\n \\beta \\f$. Notice that \\f$ f(T(u^i)) = f(v^i) \\f$ so the right hand side doesn't change after the change of variables.\n\n Furthermore, the LP has more constraints than variables, so we solve its dual:\n \\f{align*}{\n              \\min \\, & \\sum_i \\lambda_i f(v^i) \\\\\n     s.t. \\; & \\sum_i \\lambda_i u^i = T^{-1}(x^*) \\\\\n             & \\sum_i \\lambda_i = 1 \\\\\n             & \\forall i, \\, \\lambda_i \\geq 0\n \\f}\n\n In case we look for an overestimate, we do exactly the same, but have to maximize in the dual LP instead\n of minimize.\n\n #### Technical and implementation details\n -# \\f$ U \\f$ has exponentially many variables, so we only apply this separator for \\f$n\\f$ &le; \\ref SCIP_MAXVERTEXPOLYDIM.\n -# If the bounds are not finite, there is no underestimator. Also, \\f$ T^{-1}(x^*) \\f$ must be in the domain,\n otherwise the dual is infeasible.\n -# After a facet is computed, we check whether it is a valid facet (i.e. we check \\f$ \\alpha^T v + \\beta \\le f(v) \\f$\n  for every vertex \\f$ v \\f$). If we find a violation of at most ADJUSTFACETFACTOR * SCIPgetLPFeastol(), then we weaken \\f$\n  \\beta \\f$ by this amount, otherwise, we discard the cut.\n -# If a variable is fixed within tolerances, we replace it with its value and compute the facet of the remaining\n expression. Note that since we are checking the cut for validity, this will never produce wrong result.\n -# If \\f$ x^* \\f$ is in the boundary of the domain, then the LP has infinitely many solutions, some of which might\n have very bad numerical properties. For this reason, we perturb \\f$ x^* \\f$ to be in the interior of the region.\n Furthermore, for some interior points, there might also be infinitely many solutions (e.g. for \\f$ x y \\f$ in \\f$\n [0,1]^2 \\f$ any point \\f$ (x^*, y^*) \\f$ such that \\f$ y^* = 1 - x^* \\f$ has infinitely many solutions). For this\n reason, we perturb any given \\f$ x^* \\f$. The idea is to try to get a facet of the convex/concave envelope. This only\n happens when the solution has \\f$ n + 1 \\f$ non zero \\f$ \\lambda \\f$'s (i.e. the primal has a unique solution).\n -# We need to compute \\f$ f(v^i) \\f$ for every vertex of \\f$ [\\ell,u] \\f$. A vertex is encoded by a number between 0\n and \\f$ 2^n - 1 \\f$, via its binary representation (0 bit is lower bound, 1 bit is upper bound), so we can compute\n all these values by iterating between 0 and \\f$ 2^n - 1 \\f$.\n -# To check that the computed cut is valid we do the following: we use a gray code to loop over the vertices\n of the box domain w.r.t. unfixed variables in order to evaluate the underestimator. To ensure the validity of the\n underestimator, we check whether \\f$ \\alpha v^i + \\beta \\le f(v^i) \\f$ for every vertex \\f$ v^i \\f$ and adjust\n \\f$ \\beta \\f$ if the maximal violation is small.\n\n @todo the solution is a facet if all variables of the primal have positive reduced costs (i.e. the solution is\n unique). In the dual, this means that there are \\f$ n + 1 \\f$ variables with positive value. Can we use this or some\n other information to handle any of both cases (point in the boundary or point in the intersection of polytopes\n defining different pieces of the convex envelope)? In the case where the point is in the boundary, can we use that\n information to maybe solve another to find a facet? How do the polytopes defining the pieces where the convex\n envelope is linear looks like, i.e, given a point in the interior of a facet of the domain, does the midpoint of the\n segment joining \\f$ x^* \\f$ with the center of the domain, always belongs to the interior of one of those polytopes?"]
    pub fn SCIPcomputeFacetVertexPolyhedralNonlinear(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        overestimate: ::std::os::raw::c_uint,
        function: ::std::option::Option<
            unsafe extern "C" fn(
                args: *mut f64,
                nargs: ::std::os::raw::c_int,
                funcdata: *mut ::std::os::raw::c_void,
            ) -> f64,
        >,
        fundata: *mut ::std::os::raw::c_void,
        xstar: *mut f64,
        box_: *mut f64,
        nallvars: ::std::os::raw::c_int,
        targetvalue: f64,
        success: *mut ::std::os::raw::c_uint,
        facetcoefs: *mut f64,
        facetconstant: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the expression of the given nonlinear constraint"]
    pub fn SCIPgetExprNonlinear(cons: *mut SCIP_CONS) -> *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " gets the left hand side of a nonlinear constraint"]
    pub fn SCIPgetLhsNonlinear(cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the right hand side of a nonlinear constraint"]
    pub fn SCIPgetRhsNonlinear(cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the nonlinear constraint as a nonlinear row representation."]
    pub fn SCIPgetNlRowNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nlrow: *mut *mut SCIP_NLROW,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the curvature of the expression of a given nonlinear constraint\n\n @note The curvature information is computed during CONSINITSOL."]
    pub fn SCIPgetCurvatureNonlinear(cons: *mut SCIP_CONS) -> SCIP_EXPRCURV;
}
unsafe extern "C" {
    #[doc = " checks whether expression of constraint can be represented as quadratic form\n\n Only sets `*isquadratic` to TRUE if the whole expression is quadratic (in the non-extended formulation) and non-linear.\n That is, the expression in each \\ref SCIP_QUADEXPR_QUADTERM will be a variable expressions and\n \\ref SCIPgetVarExprVar() can be used to retrieve the variable."]
    pub fn SCIPcheckQuadraticNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        isquadratic: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes left-hand-side of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgLhsNonlinear(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right-hand-side of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgRhsNonlinear(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes expression of a nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPchgExprNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coef * var to nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPaddLinearVarNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coef * expr to nonlinear constraint\n\n @attention This method can only be called in the problem stage."]
    pub fn SCIPaddExprNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        expr: *mut SCIP_EXPR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets absolute violation of nonlinear constraint\n\n This function evaluates the constraints in the given solution.\n\n If this value is at most SCIPfeastol(), the constraint would be considered feasible."]
    pub fn SCIPgetAbsViolationNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets scaled violation of nonlinear constraint\n\n This function evaluates the constraints in the given solution.\n\n The scaling that is applied to the absolute violation of the constraint\n depends on the setting of parameter constraints/nonlinear/violscale."]
    pub fn SCIPgetRelViolationNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns a variable that appears linearly that may be decreased without making any other constraint infeasible"]
    pub fn SCIPgetLinvarMayDecreaseNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut *mut SCIP_VAR,
        coef: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " returns a variable that appears linearly that may be increased without making any other constraint infeasible"]
    pub fn SCIPgetLinvarMayIncreaseNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut *mut SCIP_VAR,
        coef: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " returns the number of positive rounding locks of an expression"]
    pub fn SCIPgetExprNLocksPosNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of negative rounding locks of an expression"]
    pub fn SCIPgetExprNLocksNegNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the variable used for linearizing a given expression (return value might be NULL)\n\n @note for variable expression it returns the corresponding variable"]
    pub fn SCIPgetExprAuxVarNonlinear(expr: *mut SCIP_EXPR) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " returns the number of enforcements for an expression"]
    pub fn SCIPgetExprNEnfosNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the data for one of the enforcements of an expression"]
    pub fn SCIPgetExprEnfoDataNonlinear(
        expr: *mut SCIP_EXPR,
        idx: ::std::os::raw::c_int,
        nlhdlr: *mut *mut SCIP_NLHDLR,
        nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
        nlhdlrparticipation: *mut SCIP_NLHDLR_METHOD,
        sepabelowusesactivity: *mut ::std::os::raw::c_uint,
        sepaaboveusesactivity: *mut ::std::os::raw::c_uint,
        auxvalue: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " sets the auxiliary value of expression for one of the enforcements of an expression"]
    pub fn SCIPsetExprEnfoAuxValueNonlinear(
        expr: *mut SCIP_EXPR,
        idx: ::std::os::raw::c_int,
        auxvalue: f64,
    );
}
unsafe extern "C" {
    #[doc = " number of nonlinear handlers whose activity computation and propagation methods depend on the activity of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNPropUsesActivityNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " number of nonlinear handlers whose separation methods (estimate or enforcement) depend on the activity of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNSepaUsesActivityNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " number of nonlinear handlers whose separation methods (estimate or enforcement) use auxiliary variable of the expression\n\n @note This method can only be used after the detection methods of the nonlinear handlers have been called."]
    pub fn SCIPgetExprNAuxvarUsesNonlinear(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " method to be called by a nlhdlr during NLHDLRDETECT to notify an expression that it will be used\n\n - if `useauxvar` is enabled, then ensures that an auxiliary variable will be created in INITLP\n - if `useactivityforprop` or `useactivityforsepa{below,above}` is enabled, then ensured that activity will be updated for `expr`\n - if `useactivityforprop` is enabled, then increments the count returned by SCIPgetExprNPropUsesActivityNonlinear()\n - if `useactivityforsepa{below,above}` is enabled, then increments the count returned by SCIPgetExprNSepaUsesActivityNonlinear()\n   and also increments this count for all variables in the expression.\n\n The distinction into `useactivityforprop` and `useactivityforsepa{below,above}` is to recognize variables which domain influences\n under/overestimators. Domain propagation routines (like OBBT) may invest more work for these variables.\n The distinction into `useactivityforsepabelow` and `useactivityforsepaabove` is to recognize whether a nlhdlr that called this method\n will use activity of `expr` in enfomethod \\ref SCIP_NLHDLR_METHOD_SEPABELOW or \\ref SCIP_NLHDLR_METHOD_SEPAABOVE."]
    pub fn SCIPregisterExprUsageNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        useauxvar: ::std::os::raw::c_uint,
        useactivityforprop: ::std::os::raw::c_uint,
        useactivityforsepabelow: ::std::os::raw::c_uint,
        useactivityforsepaabove: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes value of constraint expression in a given solution\n\n Stores value of constraint expression in sol in activity.\n In case of a domain error (function cannot be evaluated in sol), activity is set to SCIP_INVALID."]
    pub fn SCIPgetExprActivityNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes absolute violation for auxvar relation in an expression w.r.t. original variables\n\n Assume the expression is f(x), where x are original (i.e., not auxiliary) variables.\n Assume that f(x) is associated with auxiliary variable z.\n\n If there are negative locks, then returns the violation of z &le; f(x) and sets `violover` to TRUE.\n If there are positive locks, then returns the violation of z &ge; f(x) and sets `violunder` to TRUE.\n Of course, if there both negative and positive locks, then return the violation of z = f(x).\n\n If necessary, f is evaluated in the given solution. If that fails (domain error),\n then `viol` is set to SCIPinfinity() and both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprAbsOrigViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
        soltag: ::std::os::raw::c_longlong,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes absolute violation for auxvar relation in an expression w.r.t. auxiliary variables\n\n Assume the expression is f(w), where w are auxiliary variables that were introduced by some nlhdlr.\n Assume that f(w) is associated with auxiliary variable z.\n\n If there are negative locks, then returns the violation of z &le; f(w) and sets `violover` to TRUE.\n If there are positive locks, then returns the violation of z &ge; f(w) and sets `violunder` to TRUE.\n Of course, if there both negative and positive locks, then return the violation of z = f(w).\n\n If the given value of f(w) is SCIP_INVALID, then `viol` is set to SCIPinfinity() and\n both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprAbsAuxViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        auxvalue: f64,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes relative violation for auxvar relation in an expression w.r.t. auxiliary variables\n\n Assume the expression is f(w), where w are auxiliary variables that were introduced by some nlhdlr.\n Assume that f(w) is associated with auxiliary variable z.\n\n Taking the absolute violation from SCIPgetExprAbsAuxViolationNonlinear(), this function returns\n the absolute violation divided by max(1,|f(w)|).\n\n If the given value of f(w) is SCIP_INVALID, then `viol` is set to SCIPinfinity() and\n both `violover` and `violunder` are set to TRUE."]
    pub fn SCIPgetExprRelAuxViolationNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        auxvalue: f64,
        sol: *mut SCIP_SOL,
        viol: *mut f64,
        violunder: *mut ::std::os::raw::c_uint,
        violover: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns bounds on the expression\n\n This gives an intersection of bounds from\n - activity calculation (SCIPexprGetActivity()), if valid,\n - auxiliary variable, if present,\n - stored by SCIPtightenExprIntervalNonlinear() during domain propagation\n\n @note The returned interval can be empty!"]
    pub fn SCIPgetExprBoundsNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_INTERVAL;
}
unsafe extern "C" {
    #[doc = " informs the expression about new bounds that can be used for reverse-propagation and to tighten bounds of\n corresponding (auxiliary) variable (if any)\n\n @attention this function should only be called during domain propagation in cons_nonlinear"]
    pub fn SCIPtightenExprIntervalNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        newbounds: SCIP_INTERVAL,
        cutoff: *mut ::std::os::raw::c_uint,
        ntightenings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " mark constraints that include this expression to be propagated again\n\n This can be used by, e.g., nlhdlrs, to trigger a new propagation of constraints without\n a change of variable bounds, e.g., because new information on the expression is available\n that could potentially lead to tighter expression activity values.\n\n Note, that this call marks also constraints for propagation which only share some variable\n with this expression."]
    pub fn SCIPmarkExprPropagateNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds violation-branching score to an expression\n\n Adds a score to the expression-specific violation-branching score, thereby marking it as branching candidate.\n The expression must either be a variable expression or have an aux-variable.\n In the latter case, branching on auxiliary variables must have been enabled.\n In case of doubt, use SCIPaddExprsViolScoreNonlinear(). Roughly, the difference between these functions is that the current\n function adds `violscore` to the expression directly, while SCIPaddExprsViolScoreNonlinear() will split the\n violation score among all the given expressions according to parameter constraints/nonlinear/branching/violsplit.\n\n @see SCIPaddExprsViolScoreNonlinear()"]
    pub fn SCIPaddExprViolScoreNonlinear(scip: *mut SCIP, expr: *mut SCIP_EXPR, violscore: f64);
}
unsafe extern "C" {
    #[doc = " adds violation-branching score to a set of expressions, distributing the score among all the expressions\n\n Each expression must either be a variable expression or have an aux-variable.\n If branching on aux-variables is disabled, then the violation branching score will be distributed among all\n variables present in `exprs`."]
    pub fn SCIPaddExprsViolScoreNonlinear(
        scip: *mut SCIP,
        exprs: *mut *mut SCIP_EXPR,
        nexprs: ::std::os::raw::c_int,
        violscore: f64,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gives violation-branching score stored in expression, or 0.0 if no valid score has been stored"]
    pub fn SCIPgetExprViolScoreNonlinear(expr: *mut SCIP_EXPR) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the partial derivative of an expression w.r.t. a variable (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPexprGetDerivative()"]
    pub fn SCIPgetExprPartialDiffNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the var's coordinate of Hu partial derivative of an expression w.r.t. a variable (or SCIP_INVALID if there was an evaluation error)\n\n @see SCIPexprGetBardot()"]
    pub fn SCIPgetExprPartialDiffGradientDirNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " evaluates quadratic term in a solution w.r.t. auxiliary variables\n\n \\note This requires that for every expr used in the quadratic data, a variable or auxiliary variable is available."]
    pub fn SCIPevalExprQuadraticAuxNonlinear(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        sol: *mut SCIP_SOL,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " creates a nonlinear handler and includes it into the nonlinear constraint handler"]
    pub fn SCIPincludeNlhdlrNonlinear(
        scip: *mut SCIP,
        nlhdlr: *mut *mut SCIP_NLHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        detectpriority: ::std::os::raw::c_int,
        enfopriority: ::std::os::raw::c_int,
        detect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                cons: *mut SCIP_CONS,
                enforcing: *mut SCIP_NLHDLR_METHOD,
                participating: *mut SCIP_NLHDLR_METHOD,
                nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
        evalaux: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                auxvalue: *mut f64,
                sol: *mut SCIP_SOL,
            ) -> SCIP_RETCODE,
        >,
        nlhdlrdata: *mut SCIP_NLHDLRDATA,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get number of nonlinear handler"]
    pub fn SCIPgetNNlhdlrsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get nonlinear handlers"]
    pub fn SCIPgetNlhdlrsNonlinear(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_NLHDLR;
}
unsafe extern "C" {
    #[doc = " returns a nonlinear handler of a given name (or NULL if not found)"]
    pub fn SCIPfindNlhdlrNonlinear(
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NLHDLR;
}
unsafe extern "C" {
    #[doc = " gives expression data that a given nonlinear handler stored in an expression\n\n Returns NULL if expr has not been detected by nlhdlr or nlhdlr did not store data."]
    pub fn SCIPgetNlhdlrExprDataNonlinear(
        nlhdlr: *mut SCIP_NLHDLR,
        expr: *mut SCIP_EXPR,
    ) -> *mut SCIP_NLHDLREXPRDATA;
}
unsafe extern "C" {
    #[doc = " creates the handler for or constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrOr(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an or constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOr(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an or constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsNonlinear(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsOr() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOr(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        resvar: *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in or constraint"]
    pub fn SCIPgetNVarsOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in or constraint"]
    pub fn SCIPgetVarsOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the resultant variable in or constraint"]
    pub fn SCIPgetResultantOr(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " creates the handler for orbisack constraints and includes it in SCIP\n\n  @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrOrbisack(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether a given binary solution is feasible for the orbisack"]
    pub fn SCIPcheckSolutionOrbisack(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        vars1: *mut *mut SCIP_VAR,
        vars2: *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        printreason: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a orbisack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOrbisack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars1: *const *mut SCIP_VAR,
        vars2: *const *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ispporbisack: ::std::os::raw::c_uint,
        isparttype: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an orbisack constraint in its most basic variant\n\n  All constraint flags set to their default values, which can be set afterwards using SCIPsetConsFLAGNAME() in scip.h.\n\n  @see SCIPcreateConsOrbisack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOrbisack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars1: *mut *mut SCIP_VAR,
        vars2: *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ispporbisack: ::std::os::raw::c_uint,
        isparttype: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
pub type SYM_SPEC = u32;
#[doc = "< permutation symmetries"]
pub const SYM_Symtype_SYM_SYMTYPE_PERM: SYM_Symtype = 0;
#[doc = "< signed permutation symmetries"]
pub const SYM_Symtype_SYM_SYMTYPE_SIGNPERM: SYM_Symtype = 1;
#[doc = " define symmetry types detectable by SCIP"]
pub type SYM_Symtype = ::std::os::raw::c_uint;
#[doc = " define symmetry types detectable by SCIP"]
pub use self::SYM_Symtype as SYM_SYMTYPE;
#[doc = "< operator node"]
pub const SYM_Nodetype_SYM_NODETYPE_OPERATOR: SYM_Nodetype = 0;
#[doc = "< numerical value node"]
pub const SYM_Nodetype_SYM_NODETYPE_VAL: SYM_Nodetype = 1;
#[doc = "< constraint node"]
pub const SYM_Nodetype_SYM_NODETYPE_CONS: SYM_Nodetype = 2;
#[doc = "< variable node"]
pub const SYM_Nodetype_SYM_NODETYPE_VAR: SYM_Nodetype = 3;
#[doc = " define type of nodes in symmetry detection expression trees"]
pub type SYM_Nodetype = ::std::os::raw::c_uint;
#[doc = " define type of nodes in symmetry detection expression trees"]
pub use self::SYM_Nodetype as SYM_NODETYPE;
#[doc = "< unknown constraint type"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_UNKNOWN: SYM_Consoptype = 0;
#[doc = "< constraint of type bounddisjunction"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_BDDISJ: SYM_Consoptype = 1;
#[doc = "< encodes == in indicator constraints for activation variable"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_EQ: SYM_Consoptype = 2;
#[doc = "< encodes pairs in SOS2 constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SOS2_TUPLE: SYM_Consoptype = 3;
#[doc = "< indicates sums if sum-expr undefined"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SUM: SYM_Consoptype = 4;
#[doc = "< indicates slack vars in indicator constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SLACK: SYM_Consoptype = 5;
#[doc = "< indicates coefficients from parent expressions"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_COEF: SYM_Consoptype = 6;
#[doc = "< indicates a squared difference"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_SQDIFF: SYM_Consoptype = 7;
#[doc = "< encodes pairs in cardinality constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_CARD_TUPLE: SYM_Consoptype = 8;
#[doc = "< indicates AND conss in pseudoboolean conss"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_PB_AND: SYM_Consoptype = 9;
#[doc = "< indicates linear conss in pseudoboolean conss"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_PB_LINEAR: SYM_Consoptype = 10;
#[doc = "< indicates pseudoboolean cons is soft constraint"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_PB_SOFT: SYM_Consoptype = 11;
#[doc = "< indicates pseudoboolean cons is objective function"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_PB_OBJ: SYM_Consoptype = 12;
#[doc = "< encodes the AND-operator in AND-constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_AND: SYM_Consoptype = 13;
#[doc = "< encodes the OR-operator in OR-constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_OR: SYM_Consoptype = 14;
#[doc = "< encodes the internal variable in XOR-constraints"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_XORINT: SYM_Consoptype = 15;
#[doc = "< number of predefined enum types, needs to always\n   hold the biggest value"]
pub const SYM_Consoptype_SYM_CONSOPTYPE_LAST: SYM_Consoptype = 16;
#[doc = " define type of simple constraints/operators in symmetry detection"]
pub type SYM_Consoptype = ::std::os::raw::c_uint;
#[doc = " define type of simple constraints/operators in symmetry detection"]
pub use self::SYM_Consoptype as SYM_CONSOPTYPE;
pub type SYM_HANDLETYPE = u32;
#[doc = "< first var in orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_FIRSTINORBIT: SCIP_LeaderRule = 0;
#[doc = "< last var in orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_LASTINORBIT: SCIP_LeaderRule = 1;
#[doc = "< var with most conflicting vars in its orbit"]
pub const SCIP_LeaderRule_SCIP_LEADERRULE_MAXCONFLICTSINORBIT: SCIP_LeaderRule = 2;
#[doc = " selection rules for leaders in SST cuts"]
pub type SCIP_LeaderRule = ::std::os::raw::c_uint;
#[doc = " selection rules for leaders in SST cuts"]
pub use self::SCIP_LeaderRule as SCIP_LEADERRULE;
#[doc = "< orbit of minimum size"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MINORBIT: SCIP_LeaderTiebreakRule = 0;
#[doc = "< orbit of maximum size"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MAXORBIT: SCIP_LeaderTiebreakRule = 1;
#[doc = "< orbit with maximum number of vars in conflict with leader"]
pub const SCIP_LeaderTiebreakRule_SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT:
    SCIP_LeaderTiebreakRule = 2;
#[doc = " tie breaks for leader rule based on the leader's orbit"]
pub type SCIP_LeaderTiebreakRule = ::std::os::raw::c_uint;
#[doc = "< binary variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_BINARY: SCIP_SSTType = 1;
#[doc = "< integer variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_INTEGER: SCIP_SSTType = 2;
#[doc = "< continuous variables"]
pub const SCIP_SSTType_SCIP_SSTTYPE_CONTINUOUS: SCIP_SSTType = 4;
#[doc = " variable types for leader in Schreier Sims cuts"]
pub type SCIP_SSTType = ::std::os::raw::c_uint;
#[doc = " variable types for leader in Schreier Sims cuts"]
pub use self::SCIP_SSTType as SCIP_SSTTYPE;
#[doc = "< constraint is a full orbitope constraint:         rowsum(x) unrestricted"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_FULL: SCIP_OrbitopeType = 0;
#[doc = "< constraint is a partitioning orbitope constraint: rowsum(x) == 1"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_PARTITIONING: SCIP_OrbitopeType = 1;
#[doc = "< constraint is a packing orbitope constraint:      rowsum(x) <= 1"]
pub const SCIP_OrbitopeType_SCIP_ORBITOPETYPE_PACKING: SCIP_OrbitopeType = 2;
#[doc = " type of orbitope constraint: full, packing, or partitioning orbitope"]
pub type SCIP_OrbitopeType = ::std::os::raw::c_uint;
#[doc = " type of orbitope constraint: full, packing, or partitioning orbitope"]
pub use self::SCIP_OrbitopeType as SCIP_ORBITOPETYPE;
unsafe extern "C" {
    #[doc = " includes orbitope constraint handlers\n\n  cons_orbitope serves as an interface for the constraint handlers cons_orbitope_full and cons_orbitope_pp;\n  this function includes their respective constraint handlers"]
    pub fn SCIPincludeConshdlrOrbitope(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a orbitope constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsOrbitope(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars: *mut *mut *mut SCIP_VAR,
        orbitopetype: SCIP_ORBITOPETYPE,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        resolveprop: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        checkpporbitope: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an orbitope constraint in its most basic variant, i. e., with all constraint flags set to their\n  default values, which can be set afterwards using SCIPsetConsFLAGNAME()\n\n  @see SCIPcreateConsOrbitope() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicOrbitope(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        vars: *mut *mut *mut SCIP_VAR,
        orbitopetype: SCIP_ORBITOPETYPE,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        resolveprop: ::std::os::raw::c_uint,
        ismodelcons: ::std::os::raw::c_uint,
        checkpporbitope: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for pseudoboolean constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrPseudoboolean(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[doc = "< this is no valid linear constraint type"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_INVALIDCONS: SCIP_LinearConsType = -1;
#[doc = "< this is the common linear constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_LINEAR: SCIP_LinearConsType = 0;
#[doc = "< this is a logicor constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_LOGICOR: SCIP_LinearConsType = 1;
#[doc = "< this is a knapsack constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_KNAPSACK: SCIP_LinearConsType = 2;
#[doc = "< this is a setppc constraint"]
pub const SCIP_LinearConsType_SCIP_LINEARCONSTYPE_SETPPC: SCIP_LinearConsType = 3;
#[doc = " solution status after solving LP"]
pub type SCIP_LinearConsType = ::std::os::raw::c_int;
#[doc = " solution status after solving LP"]
pub use self::SCIP_LinearConsType as SCIP_LINEARCONSTYPE;
unsafe extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint, with given linear and and-constraints"]
    pub fn SCIPcreateConsPseudobooleanWithConss(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        lincons: *mut SCIP_CONS,
        linconstype: SCIP_LINEARCONSTYPE,
        andconss: *mut *mut SCIP_CONS,
        andcoefs: *mut f64,
        nandconss: ::std::os::raw::c_int,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint\n\n  @note linear and nonlinear terms can be added using SCIPaddCoefPseudoboolean() and SCIPaddTermPseudoboolean(),\n        respectively\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsPseudoboolean(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linvars: *mut *mut SCIP_VAR,
        nlinvars: ::std::os::raw::c_int,
        linvals: *mut f64,
        terms: *mut *mut *mut SCIP_VAR,
        nterms: ::std::os::raw::c_int,
        ntermvars: *mut ::std::os::raw::c_int,
        termvals: *mut f64,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a pseudoboolean constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsPseudoboolean() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicPseudoboolean(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        linvars: *mut *mut SCIP_VAR,
        nlinvars: ::std::os::raw::c_int,
        linvals: *mut f64,
        terms: *mut *mut *mut SCIP_VAR,
        nterms: ::std::os::raw::c_int,
        ntermvars: *mut ::std::os::raw::c_int,
        termvals: *mut f64,
        indvar: *mut SCIP_VAR,
        weight: f64,
        issoftcons: ::std::os::raw::c_uint,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a variable to the pseudo boolean constraint (if it is not zero)\n\n  @note you can only add a coefficient if the special type of linear constraint won't changed\n\n  @todo if adding a coefficient would change the type of the special linear constraint, we need to erase it and\n        create a new linear constraint"]
    pub fn SCIPaddCoefPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds nonlinear term to pseudo boolean constraint (if it is not zero)\n\n  @note you can only add a coefficient if the special type of linear constraint won't changed\n\n  @todo if adding a coefficient would change the type of the special linear constraint, we need to erase it and\n        create a new linear constraint"]
    pub fn SCIPaddTermPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        val: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets indicator variable of pseudoboolean constraint, or NULL if there is no"]
    pub fn SCIPgetIndVarPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinearConsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " gets type of linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinearConsTypePseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> SCIP_LINEARCONSTYPE;
}
unsafe extern "C" {
    #[doc = " gets number of linear variables without artificial terms variables of pseudoboolean constraint"]
    pub fn SCIPgetNLinVarsWithoutAndPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets linear constraint of pseudoboolean constraint"]
    pub fn SCIPgetLinDatasWithoutAndPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nlinvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets and-constraints of pseudoboolean constraint"]
    pub fn SCIPgetAndDatasPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        andconss: *mut *mut SCIP_CONS,
        andcoefs: *mut f64,
        nandconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of and constraints of pseudoboolean constraint"]
    pub fn SCIPgetNAndsPseudoboolean(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " changes left hand side of pseudoboolean constraint\n\n  @note you can only change the left hand side if the special type of linear constraint won't changed\n\n  @todo if changing the left hand side would change the type of the special linear constraint, we need to erase it\n        and create a new linear constraint"]
    pub fn SCIPchgLhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS, lhs: f64)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " changes right hand side of pseudoboolean constraint\n\n  @note you can only change the right hand side if the special type of linear constraint won't changed\n\n  @todo if changing the right hand side would change the type of the special linear constraint, we need to erase it\n        and create a new linear constraint"]
    pub fn SCIPchgRhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS, rhs: f64)
    -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " get left hand side of pseudoboolean constraint"]
    pub fn SCIPgetLhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " get right hand side of pseudoboolean constraint"]
    pub fn SCIPgetRhsPseudoboolean(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " creates the handler for set partitioning / packing / covering constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSetppc(scip: *mut SCIP) -> SCIP_RETCODE;
}
#[doc = "< constraint is a set partitioning constraint: sum(x) == 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_PARTITIONING: SCIP_SetppcType = 0;
#[doc = "< constraint is a set packing constraint:      sum(x) <= 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_PACKING: SCIP_SetppcType = 1;
#[doc = "< constraint is a set covering constraint:     sum(x) >= 1"]
pub const SCIP_SetppcType_SCIP_SETPPCTYPE_COVERING: SCIP_SetppcType = 2;
#[doc = " type of setppc constraint: set partitioning, set packing, or set covering"]
pub type SCIP_SetppcType = ::std::os::raw::c_uint;
#[doc = " type of setppc constraint: set partitioning, set packing, or set covering"]
pub use self::SCIP_SetppcType as SCIP_SETPPCTYPE;
unsafe extern "C" {
    #[doc = " creates and captures a set partitioning constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetpart(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a set partitioning constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpart() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetpart(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a set packing constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetpack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a set packing constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetpack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a set covering constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSetcover(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a set packing constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSetpack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSetcover(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds coefficient in set partitioning / packing / covering constraint"]
    pub fn SCIPaddCoefSetppc(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in set partitioning / packing / covering constraint"]
    pub fn SCIPgetNVarsSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in set partitioning / packing / covering constraint"]
    pub fn SCIPgetVarsSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets type of set partitioning / packing / covering constraint"]
    pub fn SCIPgetTypeSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_SETPPCTYPE;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the set partitioning / packing / covering constraint in the current LP"]
    pub fn SCIPgetDualsolSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the set partitioning / packing / covering constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given set partitioning / packing / covering constraint; may return NULL if no\n  LP row was yet created; the user must not modify the row!"]
    pub fn SCIPgetRowSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of the given set partitioning / packing / covering constraint"]
    pub fn SCIPcreateRowSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns current number of variables fixed to one in the constraint"]
    pub fn SCIPgetNFixedonesSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns current number of variables fixed to zero in the constraint"]
    pub fn SCIPgetNFixedzerosSetppc(scip: *mut SCIP, cons: *mut SCIP_CONS)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from setppc constraints"]
    pub fn SCIPcleanupConssSetppc(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for SOS1 constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSOS1(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an SOS1 constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note The constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()."]
    pub fn SCIPcreateConsSOS1(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an SOS1 constraint\n  in its most basic variant, i. e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSOS1() for the default constraint flag configuration\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be re-sorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOS1(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variable to SOS1 constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarSOS1(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " appends variable to SOS1 constraint"]
    pub fn SCIPappendVarSOS1(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in SOS1 constraint"]
    pub fn SCIPgetNVarsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in SOS1 constraint"]
    pub fn SCIPgetVarsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array of weights in SOS1 constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsSOS1(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " gets conflict graph of SOS1 constraints (or NULL if not existent)\n\n  @note The conflict graph is globally valid; local changes are not taken into account."]
    pub fn SCIPgetConflictgraphSOS1(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_DIGRAPH;
}
unsafe extern "C" {
    #[doc = " gets number of problem variables that are part of the SOS1 conflict graph"]
    pub fn SCIPgetNSOS1Vars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether variable is part of the SOS1 conflict graph"]
    pub fn SCIPvarIsSOS1(
        conshdlr: *mut SCIP_CONSHDLR,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns node of variable in the conflict graph or -1 if variable is not part of the SOS1 conflict graph"]
    pub fn SCIPvarGetNodeSOS1(
        conshdlr: *mut SCIP_CONSHDLR,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns variable that belongs to a given node from the conflict graph"]
    pub fn SCIPnodeGetVarSOS1(
        conflictgraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " based on solution values of the variables, fixes variables to zero to turn all SOS1 constraints feasible"]
    pub fn SCIPmakeSOS1sFeasible(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        sol: *mut SCIP_SOL,
        changed: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for SOS2 constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSOS2(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an SOS2 constraint\n\n  We set the constraint to not be modifable. If the weights are non\n  NULL, the variables are ordered according to these weights (in\n  ascending order).\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSOS2(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a SOS2 constraint with all constraint flags set to their default values.\n\n  @warning Do NOT set the constraint to be modifiable manually, because this might lead\n  to wrong results as the variable array will not be re-sorted\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSOS2(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        weights: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds variable to SOS2 constraint, the position is determined by the given weight"]
    pub fn SCIPaddVarSOS2(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        weight: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " appends variable to SOS2 constraint"]
    pub fn SCIPappendVarSOS2(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in SOS2 constraint"]
    pub fn SCIPgetNVarsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in SOS2 constraint"]
    pub fn SCIPgetVarsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets array of weights in SOS2 constraint (or NULL if not existent)"]
    pub fn SCIPgetWeightsSOS2(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " creates the handler for superindicator constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSuperindicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a superindicator constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSuperindicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        slackcons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a superindicator constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsSuperindicator(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsSuperindicator() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSuperindicator(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        binvar: *mut SCIP_VAR,
        slackcons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets binary variable corresponding to the superindicator constraint"]
    pub fn SCIPgetBinaryVarSuperindicator(cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the slack constraint corresponding to the superindicator constraint"]
    pub fn SCIPgetSlackConsSuperindicator(cons: *mut SCIP_CONS) -> *mut SCIP_CONS;
}
unsafe extern "C" {
    #[doc = " transforms the current problem into a MinUC problem (minimizing the number of unsatisfied constraints),\n  a CIP generalization of the MinULR (min. unsatisfied linear relations) problem"]
    pub fn SCIPtransformMinUC(
        scip: *mut SCIP,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the SCIPtransformMinUC() command"]
    pub fn SCIPdialogExecChangeMinUC(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for symresack constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrSymresack(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a symmetry breaking constraint\n\n Depending on the given permutation, either an orbisack or symresack constraint\n is created."]
    pub fn SCIPcreateSymbreakCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a symresack constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsSymresack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a symresack constraint\n  in its most basic variant, i.e., with all constraint flags set to their default values, which can be set\n  afterwards using SCIPsetConsFLAGNAME() in scip.h\n\n  @see SCIPcreateConsSymresack() for the default constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicSymresack(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ismodelcons: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for variable bound constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrVarbound(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a variable bound constraint: lhs <= x + c*y <= rhs\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsVarbound(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        var: *mut SCIP_VAR,
        vbdvar: *mut SCIP_VAR,
        vbdcoef: f64,
        lhs: f64,
        rhs: f64,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures a varbound constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsVarbound(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsVarbound() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicVarbound(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        var: *mut SCIP_VAR,
        vbdvar: *mut SCIP_VAR,
        vbdcoef: f64,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets left hand side of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetLhsVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets right hand side of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetRhsVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets bounded variable x of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVarVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets bounding variable y of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVbdvarVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets bound coefficient c of variable bound constraint lhs <= x + c*y <= rhs"]
    pub fn SCIPgetVbdcoefVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual solution of the variable bound constraint in the current LP"]
    pub fn SCIPgetDualsolVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " gets the dual Farkas value of the variable bound constraint in the current infeasible LP"]
    pub fn SCIPgetDualfarkasVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> f64;
}
unsafe extern "C" {
    #[doc = " returns the linear relaxation of the given variable bound constraint; may return NULL if no LP row was yet created;\n  the user must not modify the row!"]
    pub fn SCIPgetRowVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
unsafe extern "C" {
    #[doc = " creates and returns the row of the given varbound constraint"]
    pub fn SCIPcreateRowVarbound(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " cleans up (multi-)aggregations and fixings from varbound constraints"]
    pub fn SCIPcleanupConssVarbound(
        scip: *mut SCIP,
        onlychecked: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for xor constraints and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrXor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an xor constraint\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsXor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        rhs: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates and captures an xor constraint\n  in its most basic version, i. e., all constraint flags are set to their basic value as explained for the\n  method SCIPcreateConsXor(); all flags can be set via SCIPsetConsFLAGNAME-methods in scip.h\n\n  @see SCIPcreateConsXor() for information about the basic constraint flag configuration\n\n  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateConsBasicXor(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        rhs: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets number of variables in xor constraint"]
    pub fn SCIPgetNVarsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gets array of variables in xor constraint"]
    pub fn SCIPgetVarsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets integer variable in xor constraint"]
    pub fn SCIPgetIntVarXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_VAR;
}
unsafe extern "C" {
    #[doc = " gets the right hand side of the xor constraint"]
    pub fn SCIPgetRhsXor(scip: *mut SCIP, cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the components constraint handler and includes it in SCIP\n\n @ingroup ConshdlrIncludes"]
    pub fn SCIPincludeConshdlrComponents(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the default display columns in SCIP\n\n  @ingroup DisplayIncludes"]
    pub fn SCIPincludeDispDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " standard menu dialog execution method, that displays it's help screen if the remaining command line is empty"]
    pub fn SCIPdialogExecMenu(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " standard menu dialog execution method, that doesn't display it's help screen"]
    pub fn SCIPdialogExecMenuLazy(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the change add constraint"]
    pub fn SCIPdialogExecChangeAddCons(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the change bounds command"]
    pub fn SCIPdialogExecChangeBounds(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the freetransproblem command"]
    pub fn SCIPdialogExecChangeFreetransproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the changing the objective sense"]
    pub fn SCIPdialogExecChangeObjSense(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the checksol command"]
    pub fn SCIPdialogExecChecksol(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the cliquegraph command"]
    pub fn SCIPdialogExecCliquegraph(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display benders command"]
    pub fn SCIPdialogExecDisplayBenders(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display branching command"]
    pub fn SCIPdialogExecDisplayBranching(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display compression command"]
    pub fn SCIPdialogExecDisplayCompression(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display conflict command"]
    pub fn SCIPdialogExecDisplayConflict(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display conshdlrs command"]
    pub fn SCIPdialogExecDisplayConshdlrs(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display displaycols command"]
    pub fn SCIPdialogExecDisplayDisplaycols(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display exprhdlrs command"]
    pub fn SCIPdialogExecDisplayExprhdlrs(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display cutselectors command"]
    pub fn SCIPdialogExecDisplayCutselectors(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display heuristics command"]
    pub fn SCIPdialogExecDisplayHeuristics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display IIS command"]
    pub fn SCIPdialogExecDisplayIIS(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display memory command"]
    pub fn SCIPdialogExecDisplayMemory(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display nodeselectors command"]
    pub fn SCIPdialogExecDisplayNodeselectors(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display nlpi command"]
    pub fn SCIPdialogExecDisplayNlpi(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display parameters command"]
    pub fn SCIPdialogExecDisplayParameters(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display presolvers command"]
    pub fn SCIPdialogExecDisplayPresolvers(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display pricer command"]
    pub fn SCIPdialogExecDisplayPricers(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display problem command"]
    pub fn SCIPdialogExecDisplayProblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display propagators command"]
    pub fn SCIPdialogExecDisplayPropagators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display readers command"]
    pub fn SCIPdialogExecDisplayReaders(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display relaxators command"]
    pub fn SCIPdialogExecDisplayRelaxators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display separators command"]
    pub fn SCIPdialogExecDisplaySeparators(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display solution command"]
    pub fn SCIPdialogExecDisplaySolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display finitesolution command"]
    pub fn SCIPdialogExecDisplayFiniteSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display dual solution command"]
    pub fn SCIPdialogExecDisplayDualSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display of solutions in the pool command"]
    pub fn SCIPdialogExecDisplaySolutionPool(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display subproblem command"]
    pub fn SCIPdialogExecDisplaySubproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display subsolution command"]
    pub fn SCIPdialogExecDisplaySubSolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display statistics command"]
    pub fn SCIPdialogExecDisplayStatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display symmetry command"]
    pub fn SCIPdialogExecDisplaySymmetry(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display reoptstatistics command"]
    pub fn SCIPdialogExecDisplayReoptStatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display transproblem command"]
    pub fn SCIPdialogExecDisplayTransproblem(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display value command"]
    pub fn SCIPdialogExecDisplayValue(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display varbranchstatistics command"]
    pub fn SCIPdialogExecDisplayVarbranchstatistics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display LP solution quality command"]
    pub fn SCIPdialogExecDisplayLPSolutionQuality(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the display transsolution command"]
    pub fn SCIPdialogExecDisplayTranssolution(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the help command"]
    pub fn SCIPdialogExecHelp(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the free command"]
    pub fn SCIPdialogExecFree(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the newstart command"]
    pub fn SCIPdialogExecNewstart(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the transform command"]
    pub fn SCIPdialogExecTransform(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the optimize command"]
    pub fn SCIPdialogExecOptimize(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the parallelopt command"]
    pub fn SCIPdialogExecConcurrentOpt(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the presolve command"]
    pub fn SCIPdialogExecPresolve(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the iis command"]
    pub fn SCIPdialogExecIIS(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the quit command"]
    pub fn SCIPdialogExecQuit(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the read command"]
    pub fn SCIPdialogExecRead(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set default command"]
    pub fn SCIPdialogExecSetDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set load command"]
    pub fn SCIPdialogExecSetLoad(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set save command"]
    pub fn SCIPdialogExecSetSave(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set diffsave command"]
    pub fn SCIPdialogExecSetDiffsave(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set parameter command"]
    pub fn SCIPdialogExecSetParam(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog description method for the set parameter command"]
    pub fn SCIPdialogDescSetParam(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the fix parameter command"]
    pub fn SCIPdialogExecFixParam(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog description method for the fix parameter command"]
    pub fn SCIPdialogDescFixParam(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set branching direction command"]
    pub fn SCIPdialogExecSetBranchingDirection(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set branching priority command"]
    pub fn SCIPdialogExecSetBranchingPriority(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set heuristics aggressive command"]
    pub fn SCIPdialogExecSetHeuristicsAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set heuristics default command"]
    pub fn SCIPdialogExecSetHeuristicsDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set heuristics fast command"]
    pub fn SCIPdialogExecSetHeuristicsFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set heuristics off command"]
    pub fn SCIPdialogExecSetHeuristicsOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set presolving aggressive command"]
    pub fn SCIPdialogExecSetPresolvingAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set presolving default command"]
    pub fn SCIPdialogExecSetPresolvingDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set presolving fast command"]
    pub fn SCIPdialogExecSetPresolvingFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set presolving off command"]
    pub fn SCIPdialogExecSetPresolvingOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set separating aggressive command"]
    pub fn SCIPdialogExecSetSeparatingAggressive(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set separating default command"]
    pub fn SCIPdialogExecSetSeparatingDefault(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set separating fast command"]
    pub fn SCIPdialogExecSetSeparatingFast(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set separating off command"]
    pub fn SCIPdialogExecSetSeparatingOff(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis counter command"]
    pub fn SCIPdialogExecSetEmphasisCounter(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis cpsolver command"]
    pub fn SCIPdialogExecSetEmphasisCpsolver(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis easy CIP command"]
    pub fn SCIPdialogExecSetEmphasisEasycip(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis feasibility command"]
    pub fn SCIPdialogExecSetEmphasisFeasibility(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis hard LP command"]
    pub fn SCIPdialogExecSetEmphasisHardlp(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis optimality command"]
    pub fn SCIPdialogExecSetEmphasisOptimality(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis numerics command"]
    pub fn SCIPdialogExecSetEmphasisNumerics(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set emphasis benchmark command"]
    pub fn SCIPdialogExecSetEmphasisBenchmark(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for the set limits objective command"]
    pub fn SCIPdialogExecSetLimitsObjective(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " dialog execution method for linear constraint type classification"]
    pub fn SCIPdialogExecDisplayLinearConsClassification(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        nextdialog: *mut *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a root dialog"]
    pub fn SCIPcreateRootDialog(scip: *mut SCIP, root: *mut *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes or updates the default dialog menus in SCIP except for menus \"fix\" and \"set\""]
    pub fn SCIPincludeDialogDefaultBasic(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes or updates the \"set\" menu for each available parameter setting"]
    pub fn SCIPincludeDialogDefaultSet(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes or updates the \"fix\" menu for each available parameter setting"]
    pub fn SCIPincludeDialogDefaultFix(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates event handler for tree size estimation"]
    pub fn SCIPincludeEventHdlrEstim(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    pub fn SCIPgetTreesizeEstimation(scip: *mut SCIP) -> f64;
}
unsafe extern "C" {
    #[doc = " creates event handler for solving phase event"]
    pub fn SCIPincludeEventHdlrSolvingphase(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes event handler for soft time limit"]
    pub fn SCIPincludeEventHdlrSofttimelimit(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an absolute value expression"]
    pub fn SCIPcreateExprAbs(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of abs-type"]
    pub fn SCIPisExprAbs(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for absolute expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrAbs(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for entropy expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrEntropy(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates an entropy expression"]
    pub fn SCIPcreateExprEntropy(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of entropy-type"]
    pub fn SCIPisExprEntropy(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates an exponential expression"]
    pub fn SCIPcreateExprExp(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of exp-type"]
    pub fn SCIPisExprExp(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for exponential expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrExp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a logarithmic expression"]
    pub fn SCIPcreateExprLog(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of log-type"]
    pub fn SCIPisExprLog(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for logarithmic expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrLog(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a power expression"]
    pub fn SCIPcreateExprPow(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        exponent: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a signpower expression"]
    pub fn SCIPcreateExprSignpower(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        exponent: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of signpower-type"]
    pub fn SCIPisExprSignpower(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for power expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrPow(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for signed power expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSignpower(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes coefficients of linearization of a square term in a reference point"]
    pub fn SCIPaddSquareLinearization(
        scip: *mut SCIP,
        sqrcoef: f64,
        refpoint: f64,
        isint: ::std::os::raw::c_uint,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " computes coefficients of secant of a square term"]
    pub fn SCIPaddSquareSecant(
        scip: *mut SCIP,
        sqrcoef: f64,
        lb: f64,
        ub: f64,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Separation for roots with exponent in [0,1]"]
    pub fn SCIPestimateRoot(
        scip: *mut SCIP,
        exponent: f64,
        overestimate: ::std::os::raw::c_uint,
        xlb: f64,
        xub: f64,
        xref: f64,
        constant: *mut f64,
        slope: *mut f64,
        islocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " creates the handler for product expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrProduct(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a product expression"]
    pub fn SCIPcreateExprProduct(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        coefficient: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for sum expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSum(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a sum expression"]
    pub fn SCIPcreateExprSum(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        coefficients: *mut f64,
        constant: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the constant of a summation expression"]
    pub fn SCIPsetConstantExprSum(expr: *mut SCIP_EXPR, constant: f64);
}
unsafe extern "C" {
    #[doc = " appends an expression to a sum expression"]
    pub fn SCIPappendExprSumExpr(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        childcoef: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " multiplies given sum expression by a constant"]
    pub fn SCIPmultiplyByConstantExprSum(expr: *mut SCIP_EXPR, constant: f64);
}
unsafe extern "C" {
    #[doc = " constructs the expanded product of two sum expressions"]
    pub fn SCIPmultiplyBySumExprSum(
        scip: *mut SCIP,
        product: *mut *mut SCIP_EXPR,
        factor1: *mut SCIP_EXPR,
        factor2: *mut SCIP_EXPR,
        simplify: ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " constructs the expanded power of a sum expression\n\n @attention The number of terms in the expansion grows exponential with the exponent. Be aware of what you wish for."]
    pub fn SCIPpowerExprSum(
        scip: *mut SCIP,
        result: *mut *mut SCIP_EXPR,
        base: *mut SCIP_EXPR,
        exponent: ::std::os::raw::c_int,
        simplify: ::std::os::raw::c_uint,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for sin expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrSin(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for cos expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrCos(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a sin expression"]
    pub fn SCIPcreateExprSin(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a cos expression"]
    pub fn SCIPcreateExprCos(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        child: *mut SCIP_EXPR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of sine-type"]
    pub fn SCIPisExprSin(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is of cosine-type"]
    pub fn SCIPisExprCos(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the handler for constant value expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrValue(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates constant value expression"]
    pub fn SCIPcreateExprValue(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        value: f64,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for variable expression and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrVar(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a variable expression"]
    pub fn SCIPcreateExprVar(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        var: *mut SCIP_VAR,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the actconsdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurActconsdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the adaptivediving heuristic and includes it in SCIP"]
    pub fn SCIPincludeHeurAdaptivediving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the bound primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurBound(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the clique primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurClique(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the coefdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCoefdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the completesol primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCompletesol(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the conflictdiving heuristic and includes it in SCIP"]
    pub fn SCIPincludeHeurConflictdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the crossover primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurCrossover(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the DINS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDins(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the distributiondiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDistributiondiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the aks primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDKS(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dps primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDps(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dualVal primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurDualval(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main procedure of the dualval heuristic"]
    pub fn SCIPapplyHeurDualval(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        refpoint: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the farkasdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFarkasdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the feaspump primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFeaspump(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the fix-and-infer primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFixandinfer(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the fracdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurFracdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the gins primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurGins(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the guideddiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurGuideddiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the indicator primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIndicator(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " pass partial solution for indicator variables to heuristic"]
    pub fn SCIPheurPassIndicator(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        nindconss: ::std::os::raw::c_int,
        indconss: *mut *mut SCIP_CONS,
        solcand: *mut ::std::os::raw::c_uint,
        obj: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the indicatordiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIndicatordiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the intdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIntdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the intshifting heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurIntshifting(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the linesearchdiving primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLinesearchdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates local branching primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLocalbranching(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the locks primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLocks(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " apply fix-and-propagate scheme based on variable locks\n\n  @note probing mode of SCIP needs to be enabled before"]
    pub fn SCIPapplyLockFixings(
        scip: *mut SCIP,
        heurdata: *mut SCIP_HEURDATA,
        cutoff: *mut ::std::os::raw::c_uint,
        allrowsfulfilled: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the lpface primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurLpface(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the alns primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurAlns(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the multistart primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMultistart(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the mutation primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMutation(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the mpec primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurMpec(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the fracdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurNlpdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the objpscostdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurObjpscostdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the octane primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOctane(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the ofins primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOfins(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the oneopt primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurOneopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the PADM primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurPADM(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the pscostdiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurPscostdiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the proximity primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurProximity(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main procedure of the proximity heuristic, creates and solves a sub-SCIP\n\n  @note the method can be applied in an iterative way, keeping the same subscip in between. If the @p freesubscip\n        parameter is set to FALSE, the heuristic will keep the subscip data structures. Always set this parameter\n        to TRUE, or call SCIPdeleteSubproblemProximity() afterwards"]
    pub fn SCIPapplyProximity(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minimprove: f64,
        nnodes: ::std::os::raw::c_longlong,
        nlpiters: ::std::os::raw::c_longlong,
        nusednodes: *mut ::std::os::raw::c_longlong,
        nusedlpiters: *mut ::std::os::raw::c_longlong,
        freesubscip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the sub-MIP created by proximity"]
    pub fn SCIPdeleteSubproblemProximity(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the rand rounding heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRandrounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates RENS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRens(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main procedure of the RNS heuristic, creates and solves a sub-SCIP"]
    pub fn SCIPapplyRens(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minfixingrate: f64,
        minimprove: f64,
        maxnodes: ::std::os::raw::c_longlong,
        nstallnodes: ::std::os::raw::c_longlong,
        startsol: ::std::os::raw::c_char,
        binarybounds: ::std::os::raw::c_uint,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the reoptsols primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurReoptsols(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = "@addtogroup PRIMALHEURISTICS\n\n @{"]
    pub fn SCIPreoptsolsGetNCheckedsols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPreoptsolsGetNImprovingsols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " creates the repair primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRepair(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates RINS primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRins(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the rootsoldiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRootsoldiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the rounding heuristic with infeasibility recovering and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurRounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the scheduler primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurScheduler(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the shiftandpropagate primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurShiftandpropagate(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the shifting heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurShifting(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the simple rounding heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurSimplerounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the NLP local search primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurSubNlp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main procedure of the subNLP heuristic"]
    pub fn SCIPapplyHeurSubNlp(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        refpoint: *mut SCIP_SOL,
        resultsol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " updates the starting point for the NLP heuristic\n\n Is called, for example, by a constraint handler that handles nonlinear constraints when a check on feasibility of a solution fails."]
    pub fn SCIPupdateStartpointHeurSubNlp(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        solcand: *mut SCIP_SOL,
        violation: f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets startpoint candidate to be used in next call to NLP heuristic, or NULL if none"]
    pub fn SCIPgetStartCandidateHeurSubNlp(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> *mut SCIP_SOL;
}
unsafe extern "C" {
    #[doc = " creates the trivial primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrivial(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the trivialnegation primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrivialnegation(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates local branching primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrustregion(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the trysol primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTrySol(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " pass solution to trysol heuristic"]
    pub fn SCIPheurPassSolTrySol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        sol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " pass solution to trysol heuristic which just gets added (without checking feasibility"]
    pub fn SCIPheurPassSolAddSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        sol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the twoopt primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurTwoopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the undercover primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurUndercover(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes a minimal set of covering variables"]
    pub fn SCIPcomputeCoverUndercover(
        scip: *mut SCIP,
        coversize: *mut ::std::os::raw::c_int,
        cover: *mut *mut SCIP_VAR,
        timelimit: f64,
        memorylimit: f64,
        objlimit: f64,
        globalbounds: ::std::os::raw::c_uint,
        onlyconvexify: ::std::os::raw::c_uint,
        coverand: ::std::os::raw::c_uint,
        coverbd: ::std::os::raw::c_uint,
        coverind: ::std::os::raw::c_uint,
        covernl: ::std::os::raw::c_uint,
        coveringobj: ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the variable bounds primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurVbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the veclendiving heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurVeclendiving(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the zeroobj primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurZeroobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " main procedure of the zeroobj heuristic, creates and solves a sub-SCIP"]
    pub fn SCIPapplyZeroobj(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        minimprove: f64,
        nnodes: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the zirounding primal heuristic and includes it in SCIP\n\n  @ingroup PrimalHeuristicIncludes"]
    pub fn SCIPincludeHeurZirounding(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the greedy IIS finder rule and includes it in SCIP\n\n @ingroup IISfinderIncludes"]
    pub fn SCIPincludeIISfinderGreedy(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " perform the greedy deletion algorithm with singleton batches to obtain an irreducible infeasible subsystem (IIS)"]
    pub fn SCIPiisGreedyMakeIrreducible(iis: *mut SCIP_IIS) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the copy handler callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetCopyHdlr(
        nlhdlr: *mut SCIP_NLHDLR,
        copy: ::std::option::Option<
            unsafe extern "C" fn(
                targetscip: *mut SCIP,
                targetconshdlr: *mut SCIP_CONSHDLR,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcenlhdlr: *mut SCIP_NLHDLR,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the nonlinear handler callback to free the nonlinear handler data"]
    pub fn SCIPnlhdlrSetFreeHdlrData(
        nlhdlr: *mut SCIP_NLHDLR,
        freehdlrdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                nlhdlrdata: *mut *mut SCIP_NLHDLRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the nonlinear handler callback to free expression specific data of nonlinear handler"]
    pub fn SCIPnlhdlrSetFreeExprData(
        nlhdlr: *mut SCIP_NLHDLR,
        freeexprdata: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the initialization and deinitialization callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetInitExit(
        nlhdlr: *mut SCIP_NLHDLR,
        init: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nlhdlr: *mut SCIP_NLHDLR) -> SCIP_RETCODE,
        >,
        exit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nlhdlr: *mut SCIP_NLHDLR) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the propagation callbacks of a nonlinear handler"]
    pub fn SCIPnlhdlrSetProp(
        nlhdlr: *mut SCIP_NLHDLR,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                interval: *mut SCIP_INTERVAL,
                intevalvar: ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        var: *mut SCIP_VAR,
                        intevalvardata: *mut ::std::os::raw::c_void,
                    ) -> SCIP_INTERVAL,
                >,
                intevalvardata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        reverseprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                bounds: SCIP_INTERVAL,
                infeasible: *mut ::std::os::raw::c_uint,
                nreductions: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the enforcement callbacks of a nonlinear handler"]
    pub fn SCIPnlhdlrSetSepa(
        nlhdlr: *mut SCIP_NLHDLR,
        initsepa: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                overestimate: ::std::os::raw::c_uint,
                underestimate: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        enfo: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                auxvalue: f64,
                overestimate: ::std::os::raw::c_uint,
                allowweakcuts: ::std::os::raw::c_uint,
                separated: ::std::os::raw::c_uint,
                addbranchscores: ::std::os::raw::c_uint,
                branchcandonly: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                auxvalue: f64,
                overestimate: ::std::os::raw::c_uint,
                targetvalue: f64,
                addbranchscores: ::std::os::raw::c_uint,
                rowpreps: *mut SCIP_PTRARRAY,
                success: *mut ::std::os::raw::c_uint,
                addedbranchscores: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        exitsepa: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " sets the solution linearization callback of a nonlinear handler"]
    pub fn SCIPnlhdlrSetSollinearize(
        nlhdlr: *mut SCIP_NLHDLR,
        sollinearize: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nlhdlr: *mut SCIP_NLHDLR,
                expr: *mut SCIP_EXPR,
                nlhdlrexprdata: *mut SCIP_NLHDLREXPRDATA,
                sol: *mut SCIP_SOL,
                solisbest: ::std::os::raw::c_uint,
                overestimate: ::std::os::raw::c_uint,
                underestimate: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    );
}
unsafe extern "C" {
    #[doc = " gives name of nonlinear handler"]
    pub fn SCIPnlhdlrGetName(nlhdlr: *mut SCIP_NLHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gives description of nonlinear handler, can be NULL"]
    pub fn SCIPnlhdlrGetDesc(nlhdlr: *mut SCIP_NLHDLR) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gives detection priority of nonlinear handler"]
    pub fn SCIPnlhdlrGetDetectPriority(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gives enforcement priority of nonlinear handler"]
    pub fn SCIPnlhdlrGetEnfoPriority(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler is enabled"]
    pub fn SCIPnlhdlrIsEnabled(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives handler data of nonlinear handler"]
    pub fn SCIPnlhdlrGetData(nlhdlr: *mut SCIP_NLHDLR) -> *mut SCIP_NLHDLRDATA;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the interval evaluation callback"]
    pub fn SCIPnlhdlrHasIntEval(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the reverse propagation callback"]
    pub fn SCIPnlhdlrHasReverseProp(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the separation initialization callback"]
    pub fn SCIPnlhdlrHasInitSepa(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the separation deinitialization callback"]
    pub fn SCIPnlhdlrHasExitSepa(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the enforcement callback"]
    pub fn SCIPnlhdlrHasEnfo(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the estimator callback"]
    pub fn SCIPnlhdlrHasEstimate(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns whether nonlinear handler implements the solution linearization callback"]
    pub fn SCIPnlhdlrHasSollinearize(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " compares two nonlinear handlers by detection priority\n\n if handlers have same detection priority, then compare by name"]
    pub fn SCIPnlhdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " includes bilinear nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrBilinear(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns an array of expressions that have been detected by the bilinear nonlinear handler"]
    pub fn SCIPgetExprsBilinear(nlhdlr: *mut SCIP_NLHDLR) -> *mut *mut SCIP_EXPR;
}
unsafe extern "C" {
    #[doc = " returns the total number of expressions that have been detected by the bilinear nonlinear handler"]
    pub fn SCIPgetNExprsBilinear(nlhdlr: *mut SCIP_NLHDLR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " adds a globally valid inequality of the form \\f$\\text{xcoef}\\cdot x \\leq \\text{ycoef} \\cdot y + \\text{constant}\\f$ to a product expression of the form \\f$x\\cdot y\\f$"]
    pub fn SCIPaddIneqBilinear(
        scip: *mut SCIP,
        nlhdlr: *mut SCIP_NLHDLR,
        expr: *mut SCIP_EXPR,
        xcoef: f64,
        ycoef: f64,
        constant: f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point"]
    pub fn SCIPaddBilinLinearization(
        scip: *mut SCIP,
        bilincoef: f64,
        refpointx: f64,
        refpointy: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " computes coefficients of McCormick under- or overestimation of a bilinear term"]
    pub fn SCIPaddBilinMcCormick(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given a linear inequality\n  involving only the variables of the bilinear term\n\n  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\"\n        by Marco Locatelli"]
    pub fn SCIPcomputeBilinEnvelope1(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        xcoef: f64,
        ycoef: f64,
        constant: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given two linear inequalities\n  involving only the variables of the bilinear term\n\n  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\"\n        by Marco Locatelli"]
    pub fn SCIPcomputeBilinEnvelope2(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        xcoef1: f64,
        ycoef1: f64,
        constant1: f64,
        xcoef2: f64,
        ycoef2: f64,
        constant2: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " includes convex nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrConvex(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes concave nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrConcave(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether a given expression is convex or concave w.r.t. the original variables\n\n This function uses the methods that are used in the detection algorithm of the convex nonlinear handler."]
    pub fn SCIPhasExprCurvature(
        scip: *mut SCIP,
        expr: *mut SCIP_EXPR,
        curv: SCIP_EXPRCURV,
        success: *mut ::std::os::raw::c_uint,
        assumevarfixed: *mut SCIP_HASHMAP,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes default nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes perspective nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrPerspective(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes quadratic nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrQuadratic(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes quotient nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrQuotient(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes signomial nonlinear handler to nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrSignomial(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes SOC nonlinear handler in nonlinear constraint handler\n\n @ingroup NlhdlrIncludes"]
    pub fn SCIPincludeNlhdlrSoc(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether constraint is SOC representable in original variables and returns the SOC representation\n\n The SOC representation has the form:\n \\f$\\sqrt{\\sum_{i=1}^{n} (v_i^T x + \\beta_i)^2} - v_{n+1}^T x - \\beta_{n+1} \\lessgtr 0\\f$,\n where \\f$n+1 = \\text{nterms}\\f$ and the inequality type is given by sidetype (`SCIP_SIDETYPE_RIGHT` if inequality\n is \\f$\\leq\\f$, `SCIP_SIDETYPE_LEFT` if \\f$\\geq\\f$).\n\n For each term (i.e. for each \\f$i\\f$ in the above notation as well as \\f$n+1\\f$), the constant \\f$\\beta_i\\f$ is given by the\n corresponding element `offsets[i-1]` and `termbegins[i-1]` is the starting position of the term in arrays\n `transcoefs` and `transcoefsidx`. The overall number of nonzeros is `termbegins[nterms]`.\n\n Arrays `transcoefs` and `transcoefsidx` have size `termbegins[nterms]` and define the linear expressions \\f$v_i^T x\\f$\n for each term. For a term \\f$i\\f$ in the above notation, the nonzeroes are given by elements\n `termbegins[i-1]...termbegins[i]` of `transcoefs` and `transcoefsidx`. There may be no nonzeroes for some term (i.e.,\n constant terms are possible). `transcoefs` contains the coefficients \\f$v_i\\f$ and `transcoefsidx` contains positions of\n variables in the `vars` array.\n\n The `vars` array has size `nvars` and contains \\f$x\\f$ variables; each variable is included at most once.\n\n The arrays should be freed by calling SCIPfreeSOCArraysNonlinear().\n\n This function uses the methods that are used in the detection algorithm of the SOC nonlinear handler."]
    pub fn SCIPisSOCNonlinear(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        compeigenvalues: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        sidetype: *mut SCIP_SIDETYPE,
        vars: *mut *mut *mut SCIP_VAR,
        offsets: *mut *mut f64,
        transcoefs: *mut *mut f64,
        transcoefsidx: *mut *mut ::std::os::raw::c_int,
        termbegins: *mut *mut ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
        nterms: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees arrays created by SCIPisSOCNonlinear()"]
    pub fn SCIPfreeSOCArraysNonlinear(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        offsets: *mut *mut f64,
        transcoefs: *mut *mut f64,
        transcoefsidx: *mut *mut ::std::os::raw::c_int,
        termbegins: *mut *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
        nterms: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " creates the node selector for best first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselBfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the node selector for breadth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselBreadthfirst(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the node selector for depth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselDfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the node selector for best estimate search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselEstimate(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the node selector for hybrid best estim / best bound search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselHybridestim(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the uct node selector and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselUct(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the node selector for restarting depth first search and includes it in SCIP\n\n  @ingroup NodeSelectorIncludes"]
    pub fn SCIPincludeNodeselRestartdfs(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the boundshift presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolBoundshift(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the convertinttobin presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolConvertinttobin(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dominated column presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDomcol(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dualagg presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualagg(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dualcomp presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualcomp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dual inference presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolDualinfer(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the gateextraction presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolGateextraction(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the implics presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolImplics(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the implicit integer presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolImplint(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the inttobinary presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolInttobinary(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the MILP presolver and includes it in SCIP if the presolve library is available\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolMILP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the redvub presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolRedvub(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the QP KKT reformulation presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolQPKKTref(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the trivial presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolTrivial(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the tworowbnd presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolTworowbnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the sparsify presolver and includes it in SCIP"]
    pub fn SCIPincludePresolSparsify(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dual sparsify presolver and includes it in SCIP"]
    pub fn SCIPincludePresolDualsparsify(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the stuffing presolver and includes it in SCIP\n\n @ingroup PresolverIncludes"]
    pub fn SCIPincludePresolStuffing(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dual fixing propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropDualfix(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " adds a generalized variable bound to the genvbounds propagator; if there is already a genvbound for the bound\n  \"boundtype\" of variable \"var\", it will be replaced"]
    pub fn SCIPgenVBoundAdd(
        scip: *mut SCIP,
        genvboundprop: *mut SCIP_PROP,
        vars: *mut *mut SCIP_VAR,
        var: *mut SCIP_VAR,
        coefs: *mut f64,
        ncoefs: ::std::os::raw::c_int,
        coefcutoffbound: f64,
        constant: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the genvbounds propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropGenvbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the nlobbt propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropNlobbt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the obbt propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropObbt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the probing propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " applies and evaluates probing of a single variable in the given direction and bound"]
    pub fn SCIPapplyProbingVar(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        probingpos: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bound: f64,
        maxproprounds: ::std::os::raw::c_int,
        impllbs: *mut f64,
        implubs: *mut f64,
        proplbs: *mut f64,
        propubs: *mut f64,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " analyses boundchanges resulting from probing on a variable and performs deduced fixations, aggregations, and domain tightenings\n\n  Given a variable probingvar with domain [l,u] and bound tightening results from reducing the\n  domain once to [l,leftub] and once to [rightlb,u], the method computes and applies resulting\n  variable fixations, aggregations, implications, and bound changes. Variable probingvar does not\n  need to be binary.  The whole domain of probingvar need to be covered by the left and right\n  branches, i.e., we assume leftub >= rightlb for continuous variables or floor(leftub) >=\n  ceil(rightlb)-1 for discrete variables.  Bounds after applying implications and cliques do not\n  need to be provided, but if they are omitted and probingvar is a binary variable, then already\n  existing implications may be added."]
    pub fn SCIPanalyzeDeductionsProbing(
        scip: *mut SCIP,
        probingvar: *mut SCIP_VAR,
        leftub: f64,
        rightlb: f64,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        leftimpllbs: *mut f64,
        leftimplubs: *mut f64,
        leftproplbs: *mut f64,
        leftpropubs: *mut f64,
        rightimpllbs: *mut f64,
        rightimplubs: *mut f64,
        rightproplbs: *mut f64,
        rightpropubs: *mut f64,
        nfixedvars: *mut ::std::os::raw::c_int,
        naggrvars: *mut ::std::os::raw::c_int,
        nimplications: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the pseudo objective function propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropPseudoobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " propagates the cutoff bound for the given variables"]
    pub fn SCIPpropagateCutoffboundVar(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        var: *mut SCIP_VAR,
        cutoffbound: f64,
        pseudoobjval: f64,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the redcost propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropRedcost(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the root node reduced cost strengthening propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropRootredcost(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " include symmetry propagator"]
    pub fn SCIPincludePropSymmetry(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return currently available symmetry group information"]
    pub fn SCIPgetSymmetry(
        scip: *mut SCIP,
        npermvars: *mut ::std::os::raw::c_int,
        permvars: *mut *mut *mut SCIP_VAR,
        permvarmap: *mut *mut SCIP_HASHMAP,
        nperms: *mut ::std::os::raw::c_int,
        perms: *mut *mut *mut ::std::os::raw::c_int,
        permstrans: *mut *mut *mut ::std::os::raw::c_int,
        log10groupsize: *mut f64,
        binvaraffected: *mut ::std::os::raw::c_uint,
        components: *mut *mut ::std::os::raw::c_int,
        componentbegins: *mut *mut ::std::os::raw::c_int,
        vartocomponent: *mut *mut ::std::os::raw::c_int,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " return number of the symmetry group's generators"]
    pub fn SCIPgetSymmetryNGenerators(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " displays generators of symmetry group, if available"]
    pub fn SCIPdisplaySymmetryGenerators(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates new operator node type (used for symmetry detection) and returns its representation\n\n  If the operator node already exists, the function terminates with SCIP_INVALIDDATA."]
    pub fn SCIPcreateSymOpNodeType(
        scip: *mut SCIP,
        opnodename: *const ::std::os::raw::c_char,
        nodetype: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns representation of an operator node type.\n\n  If the node type does not already exist, a new node type will be created."]
    pub fn SCIPgetSymOpNodeType(
        scip: *mut SCIP,
        opnodename: *const ::std::os::raw::c_char,
        nodetype: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the vbounds propagator and includes it in SCIP\n\n @ingroup PropagatorIncludes"]
    pub fn SCIPincludePropVbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns TRUE if the propagator has the status that all variable lower and upper bounds are propagated"]
    pub fn SCIPisPropagatedVbounds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " performs propagation of variables lower and upper bounds"]
    pub fn SCIPexecPropVbounds(
        scip: *mut SCIP,
        force: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the bnd file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderBnd(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the ccg file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCcg(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteCcg(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the cip file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCip(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the cnf file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCnf(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the cor file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderCor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadCor(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the COR reader data"]
    pub fn SCIPfreeReaderdataCor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns whether the COR file has been successfully read. This is used by the TIM and STO readers."]
    pub fn SCIPcorHasRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " returns the number of variable names in the COR problem"]
    pub fn SCIPcorGetNVarNames(reader: *mut SCIP_READER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the number of constraint names in the COR problem"]
    pub fn SCIPcorGetNConsNames(reader: *mut SCIP_READER) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns the variable name for the given index"]
    pub fn SCIPcorGetVarName(
        reader: *mut SCIP_READER,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns the constraint name for the given index"]
    pub fn SCIPcorGetConsName(
        reader: *mut SCIP_READER,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " includes the decomposition file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderDec(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the diff file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderDiff(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadDiff(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the fix file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderFix(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the FlatZinc file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderFzn(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " print given solution in Flatzinc format w.r.t. the output annotation"]
    pub fn SCIPprintSolReaderFzn(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the gms file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderGms(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteGms(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the lp file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderLp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadLp(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteLp(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objoffset: f64,
        objscale: f64,
        objoffsetexact: *mut SCIP_RATIONAL,
        objscaleexact: *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the mps file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderMps(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadMps(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
        varnames: *mut *mut *const ::std::os::raw::c_char,
        consnames: *mut *mut *const ::std::os::raw::c_char,
        varnamessize: *mut ::std::os::raw::c_int,
        consnamessize: *mut ::std::os::raw::c_int,
        nvarnames: *mut ::std::os::raw::c_int,
        nconsnames: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteMps(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objoffset: f64,
        objscale: f64,
        objoffsetexact: *mut SCIP_RATIONAL,
        objscaleexact: *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        fixedvars: *mut *mut SCIP_VAR,
        nfixedvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the mst file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderMst(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the .nl file reader into SCIP"]
    pub fn SCIPincludeReaderNl(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes AMPL solution file\n\n problem must have been read with .nl reader"]
    pub fn SCIPwriteSolutionNl(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the opb file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderOpb(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadOpb(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwriteOpb(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objoffset: f64,
        objscale: f64,
        objoffsetexact: *mut SCIP_RATIONAL,
        objscaleexact: *mut SCIP_RATIONAL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        fixedvars: *mut *mut SCIP_VAR,
        nfixedvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        genericnames: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the osil file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderOsil(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the pip file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPip(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads problem from file"]
    pub fn SCIPreadPip(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwritePip(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        transformed: ::std::os::raw::c_uint,
        objsense: SCIP_OBJSENSE,
        objscale: f64,
        objoffset: f64,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        nbinvars: ::std::os::raw::c_int,
        nintvars: ::std::os::raw::c_int,
        nimplvars: ::std::os::raw::c_int,
        ncontvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the ppm file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPpm(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " writes problem to file"]
    pub fn SCIPwritePpm(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
        transformed: ::std::os::raw::c_uint,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the pbm file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderPbm(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = "@addtogroup FILEREADERS\n\n @{"]
    pub fn SCIPwritePbm(
        scip: *mut SCIP,
        file: *mut FILE,
        name: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
        transformed: ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the rlp file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderRlp(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the smps file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSmps(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the sol file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSol(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the sto file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderSto(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads the stochastic information for a stochastic program that is in SMPS format"]
    pub fn SCIPreadSto(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the total number of scenarios added to the problem"]
    pub fn SCIPstoGetNScenarios(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " frees the STO reader data"]
    pub fn SCIPfreeReaderdataSto(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the tim file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderTim(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " reads the stage information for a stochastic programming instance in SMPS format"]
    pub fn SCIPreadTim(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " frees the reader data for the tim file"]
    pub fn SCIPfreeReaderdataTim(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    pub fn SCIPtimHasRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn SCIPtimGetNStages(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPtimGetStageName(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn SCIPtimConsGetStageName(
        scip: *mut SCIP,
        consname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn SCIPtimFindStage(
        scip: *mut SCIP,
        stage: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPtimGetStageVars(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_VAR;
}
unsafe extern "C" {
    pub fn SCIPtimGetStageConss(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> *mut *mut SCIP_CONS;
}
unsafe extern "C" {
    pub fn SCIPtimGetStageNVars(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SCIPtimGetStageNConss(
        scip: *mut SCIP,
        stagenum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " includes the wbo file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderWbo(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes the zpl file reader into SCIP\n\n  @ingroup FileReaderIncludes"]
    pub fn SCIPincludeReaderZpl(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the edge-concave separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaEccuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the Chvatal-Gomory-MIP cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaCGMIP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the clique separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaClique(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the closecuts separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaClosecuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets point to be used as base point for computing the point to be separated\n\n  The point is only stored if separation of relative interior points is used. The solution is copied."]
    pub fn SCIPsetBasePointClosecuts(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the aggregation separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaAggregation(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the convexproj separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaConvexproj(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the disjunctive cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaDisjunctive(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the flower separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaFlower(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the gauge separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaGauge(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the Gomory MIR cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaGomory(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the impliedbounds separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaImpliedbounds(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the interminor separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaInterminor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the integer objective value separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaIntobj(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the Lagromory separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaLagromory(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the mcf separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMcf(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the minor separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMinor(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the mixing separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaMixing(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the oddcycle separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaOddcycle(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the rapidlearning separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaRapidlearning(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the RLT separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaRlt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the {0,1/2}-cut separator and includes it in SCIP\n\n @ingroup SeparatorIncludes"]
    pub fn SCIPincludeSepaZerohalf(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " evaluates command line parameters and runs SCIP appropriately in the given SCIP instance"]
    pub fn SCIPprocessShellArguments(
        scip: *mut SCIP,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        defaultsetname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a SCIP instance with default plugins, evaluates command line parameters, runs SCIP appropriately,\n  and frees the SCIP instance"]
    pub fn SCIPrunShell(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        defaultsetname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns inferred type of variable used for symmetry handling"]
    pub fn SCIPgetSymInferredVarType(var: *mut SCIP_VAR) -> SCIP_VARTYPE;
}
unsafe extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1."]
    pub fn SCIPcomputeOrbitsSym(
        scip: *mut SCIP,
        issigned: ::std::os::raw::c_uint,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group using filtered generators\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1.\n\n  Only permutations that are not inactive (as marked by @p inactiveperms) are used. Thus, one can use this array to\n  filter out permutations."]
    pub fn SCIPcomputeOrbitsFilterSym(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        inactiveperms: *mut u8,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        vartocomponent: *mut ::std::os::raw::c_int,
        componentblocked: *mut ::std::os::raw::c_uint,
        ncomponents: ::std::os::raw::c_int,
        nmovedpermvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compute non-trivial orbits of symmetry group\n\n  The non-trivial orbits of the group action are stored in the array orbits of length npermvars. This array contains\n  the indices of variables from the permvars array such that variables that are contained in the same orbit appear\n  consecutively in the orbits array. The variables of the i-th orbit have indices\n  orbits[orbitbegins[i]], ... , orbits[orbitbegins[i + 1] - 1].\n  Note that the description of the orbits ends at orbitbegins[norbits] - 1.\n\n  This function is adapted from SCIPcomputeOrbitsFilterSym()."]
    pub fn SCIPcomputeOrbitsComponentsSym(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        vartocomponent: *mut ::std::os::raw::c_int,
        ncomponents: ::std::os::raw::c_int,
        orbits: *mut ::std::os::raw::c_int,
        orbitbegins: *mut ::std::os::raw::c_int,
        norbits: *mut ::std::os::raw::c_int,
        varorbitmap: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Compute orbit of a given variable and store it in @p orbit. The first entry of the orbit will\n  be the given variable index and the rest is filled with the remaining variables excluding\n  the ones specified in @p ignoredvars.\n\n  @pre orbit is an initialized array of size propdata->npermvars\n  @pre at least one of @p perms and @p permstrans should not be NULL"]
    pub fn SCIPcomputeOrbitVar(
        scip: *mut SCIP,
        npermvars: ::std::os::raw::c_int,
        perms: *mut *mut ::std::os::raw::c_int,
        permstrans: *mut *mut ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        componentbegins: *mut ::std::os::raw::c_int,
        ignoredvars: *mut u8,
        varfound: *mut u8,
        varidx: ::std::os::raw::c_int,
        component: ::std::os::raw::c_int,
        orbit: *mut ::std::os::raw::c_int,
        orbitsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Checks whether a permutation is a composition of 2-cycles and in this case determine the number of overall\n  2-cycles and binary 2-cycles. It is a composition of 2-cycles iff @p ntwocyclesperm > 0 upon termination."]
    pub fn SCIPisInvolutionPerm(
        perm: *mut ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        ntwocyclesperm: *mut ::std::os::raw::c_int,
        nbincyclesperm: *mut ::std::os::raw::c_int,
        earlytermination: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " determine number of variables affected by symmetry group"]
    pub fn SCIPdetermineNVarsAffectedSym(
        scip: *mut SCIP,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        nvarsaffected: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " compute components of symmetry group"]
    pub fn SCIPcomputeComponentsSym(
        scip: *mut SCIP,
        symtype: SYM_SYMTYPE,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        transposed: ::std::os::raw::c_uint,
        components: *mut *mut ::std::os::raw::c_int,
        componentbegins: *mut *mut ::std::os::raw::c_int,
        vartocomponent: *mut *mut ::std::os::raw::c_int,
        componentblocked: *mut *mut ::std::os::raw::c_uint,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Given a matrix with nrows and \\#perms + 1 columns whose first nfilledcols columns contain entries of variables, this routine\n  checks whether the 2-cycles of perm intersect each row of column coltoextend in exactly one position. In this case,\n  we add one column to the suborbitope of the first nfilledcols columns.\n\n  @pre Every non-trivial cycle of perm is a 2-cycle.\n  @pre perm has nrows many 2-cycles"]
    pub fn SCIPextendSubOrbitope(
        suborbitope: *mut *mut ::std::os::raw::c_int,
        nrows: ::std::os::raw::c_int,
        nfilledcols: ::std::os::raw::c_int,
        coltoextend: ::std::os::raw::c_int,
        perm: *mut ::std::os::raw::c_int,
        leftextension: ::std::os::raw::c_uint,
        nusedelems: *mut *mut ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        rowisbinary: *mut u8,
        success: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " generate variable matrix for orbitope constraint handler"]
    pub fn SCIPgenerateOrbitopeVarsMatrix(
        scip: *mut SCIP,
        vars: *mut *mut *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        permvars: *mut *mut SCIP_VAR,
        npermvars: ::std::os::raw::c_int,
        orbitopevaridx: *mut *mut ::std::os::raw::c_int,
        columnorder: *mut ::std::os::raw::c_int,
        nusedelems: *mut ::std::os::raw::c_int,
        rowisbinary: *mut u8,
        infeasible: *mut ::std::os::raw::c_uint,
        storelexorder: ::std::os::raw::c_uint,
        lexorder: *mut *mut ::std::os::raw::c_int,
        nvarsorder: *mut ::std::os::raw::c_int,
        maxnvarsorder: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " checks whether an orbitope is a packing or partitioning orbitope"]
    pub fn SCIPisPackingPartitioningOrbitope(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nrows: ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        pprows: *mut *mut ::std::os::raw::c_uint,
        npprows: *mut ::std::os::raw::c_int,
        type_: *mut SCIP_ORBITOPETYPE,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " detects whether permutations define single or double lex matrices\n\n  A single lex matrix is a matrix whose columns can be partitioned into blocks such that the\n  columns within each block can be permuted arbitrarily. A double lex matrix is a single lex\n  matrix such that also blocks of rows have the aforementioned property."]
    pub fn SCIPdetectSingleOrDoubleLexMatrices(
        scip: *mut SCIP,
        detectsinglelex: ::std::os::raw::c_uint,
        perms: *mut *mut ::std::os::raw::c_int,
        nperms: ::std::os::raw::c_int,
        permlen: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
        isorbitope: *mut ::std::os::raw::c_uint,
        lexmatrix: *mut *mut *mut ::std::os::raw::c_int,
        nrows: *mut ::std::os::raw::c_int,
        ncols: *mut ::std::os::raw::c_int,
        lexrowsbegin: *mut *mut ::std::os::raw::c_int,
        lexcolsbegin: *mut *mut ::std::os::raw::c_int,
        nrowmatrices: *mut ::std::os::raw::c_int,
        ncolmatrices: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " helper function to test if val1 = val2 while permitting infinity-values"]
    pub fn SCIPsymEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " helper function to test if val1 <= val2 while permitting infinity-values"]
    pub fn SCIPsymLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " helper function to test if val1 >= val2 while permitting infinity-values"]
    pub fn SCIPsymGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " helper function to test if val1 < val2 while permitting infinity-values"]
    pub fn SCIPsymLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " helper function to test if val1 > val2 while permitting infinity-values"]
    pub fn SCIPsymGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " creates the default statistics tables and includes them in SCIP\n\n  @ingroup TableIncludes"]
    pub fn SCIPincludeTableDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the concurrent SCIP solver plugins and includes them in SCIP"]
    pub fn SCIPincludeConcurrentScipSolvers(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the default Benders' decomposition and includes it in SCIP\n\n  @ingroup BendersIncludes"]
    pub fn SCIPincludeBendersDefault(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " Creates a default Benders' decomposition algorithm and activates it in SCIP"]
    pub fn SCIPcreateBendersDefault(
        scip: *mut SCIP,
        subproblems: *mut *mut SCIP,
        nsubproblems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the benders relaxator and includes it in SCIP"]
    pub fn SCIPincludeRelaxBenders(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " returns the master problem SCIP instance"]
    pub fn SCIPgetMasterProblemRelaxBenders(scip: *mut SCIP) -> *mut SCIP;
}
unsafe extern "C" {
    #[doc = " creates the hybrid separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselHybrid(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is the selection method of the hybrid cut selector which uses a weighted sum of the\n  efficacy, parallelism, directed cutoff distance, and the integral support.\n  The input cuts array gets re-sorted s.t the selected cuts come first and the remaining\n  ones are the end."]
    pub fn SCIPselectCutsHybrid(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        randnumgen: *mut SCIP_RANDNUMGEN,
        goodscorefac: f64,
        badscorefac: f64,
        goodmaxparall: f64,
        maxparall: f64,
        dircutoffdistweight: f64,
        efficacyweight: f64,
        objparalweight: f64,
        intsupportweight: f64,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the dynamic hybrid separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselDynamic(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is an extension of the hybrid cutselector to employ a dynamic range\n  when applying orthogonality filtering, dependent on the efficacy ratio between cuts.\n\n  The input cuts array should be re-sorted such that the selected cuts come first."]
    pub fn SCIPselectCutsDynamic(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        randnumgen: *mut SCIP_RANDNUMGEN,
        filtermode: ::std::os::raw::c_char,
        mingain: f64,
        maxparall: f64,
        dircutoffdistweight: f64,
        efficacyweight: f64,
        objparalweight: f64,
        intsupportweight: f64,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the ensemble separator and includes it in SCIP\n\n @ingroup CutSelectorIncludes"]
    pub fn SCIPincludeCutselEnsemble(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts\n\n  This is the selection method of the ensemble cut selector. It uses a weighted sum of normalised efficacy,\n  normalised directed cutoff distance, normalised expected improvements, objective parallelism,\n  integer support, sparsity, dynamism, pseudo-costs, and variable locks.\n  In addition to the weighted sum score, there are optionally parallelism-based filtering and penalties,\n  and density filtering.\n  There are also additional budget constraints on the number of cuts that should be added.\n  The input cuts array gets re-sorted such that the selected cuts come first and the remaining ones are the end."]
    pub fn SCIPselectCutsEnsemble(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        forcedcuts: *mut *mut SCIP_ROW,
        cutseldata: *mut SCIP_CUTSELDATA,
        root: ::std::os::raw::c_uint,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates the handler for variable index expressions and includes it into SCIP\n\n @ingroup ExprhdlrIncludes"]
    pub fn SCIPincludeExprhdlrVaridx(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " creates a variable index expression"]
    pub fn SCIPcreateExprVaridx(
        scip: *mut SCIP,
        expr: *mut *mut SCIP_EXPR,
        varidx: ::std::os::raw::c_int,
        ownercreate: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                expr: *mut SCIP_EXPR,
                ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                ownerfree: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerprint: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        file: *mut FILE,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownerevalactivity: *mut ::std::option::Option<
                    unsafe extern "C" fn(
                        scip: *mut SCIP,
                        expr: *mut SCIP_EXPR,
                        ownerdata: *mut SCIP_EXPR_OWNERDATA,
                    ) -> SCIP_RETCODE,
                >,
                ownercreatedata: *mut ::std::os::raw::c_void,
            ) -> SCIP_RETCODE,
        >,
        ownercreatedata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " indicates whether expression is varidx expression"]
    pub fn SCIPisExprVaridx(scip: *mut SCIP, expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives the index stored in a varidx expression"]
    pub fn SCIPgetIndexExprVaridx(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the index stored in a varidx expression"]
    pub fn SCIPsetIndexExprVaridx(expr: *mut SCIP_EXPR, newindex: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " create solver interface for Ipopt solver and includes it into SCIP, if Ipopt is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverIpopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets string that identifies Ipopt (version number)"]
    pub fn SCIPgetSolverNameIpopt() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets string that describes Ipopt"]
    pub fn SCIPgetSolverDescIpopt() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether Ipopt is available, i.e., whether it has been linked in"]
    pub fn SCIPisIpoptAvailableIpopt() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " gives a pointer to the NLPIORACLE object stored in Ipopt-NLPI's NLPI problem data structure"]
    pub fn SCIPgetNlpiOracleIpopt(
        nlpiproblem: *mut SCIP_NLPIPROBLEM,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Calls Lapacks Dsyev routine to compute eigenvalues and eigenvectors of a dense matrix.\n\n This uses Ipopt's interface to Lapack."]
    pub fn SCIPcallLapackDsyevIpopt(
        computeeigenvectors: ::std::os::raw::c_uint,
        N: ::std::os::raw::c_int,
        a: *mut f64,
        w: *mut f64,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " solves a linear problem of the form Ax = b for a regular matrix A\n\n  Calls Lapacks DGETRF routine to calculate a LU factorization and uses this factorization to solve\n  the linear problem Ax = b.\n\n This uses Ipopt's interface to Lapack."]
    pub fn SCIPsolveLinearEquationsIpopt(
        N: ::std::os::raw::c_int,
        A: *mut f64,
        b: *mut f64,
        x: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " create solver interface for filterSQP solver and include it into SCIP, if filterSQP is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverFilterSQP(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets string that identifies filterSQP"]
    pub fn SCIPgetSolverNameFilterSQP() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets string that describes filterSQP"]
    pub fn SCIPgetSolverDescFilterSQP() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether filterSQP is available, i.e., whether it has been linked in"]
    pub fn SCIPisFilterSQPAvailableFilterSQP() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " create solver interface for Worhp solver and includes it into SCIP, if Worhp is available\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverWorhp(
        scip: *mut SCIP,
        useip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " gets string that identifies Worhp (version number)"]
    pub fn SCIPgetSolverNameWorhp() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets string that describes Worhp (version number)"]
    pub fn SCIPgetSolverDescWorhp() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether Worhp is available, i.e., whether it has been linked in"]
    pub fn SCIPisWorhpAvailableWorhp() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " create solver interface for CONOPT solver and includes it into SCIP\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverConopt(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " sets the license to be passed to CONOPT's COIDEF_License"]
    pub fn SCIPsetLicenseConopt(
        nlpi: *mut SCIP_NLPI,
        integer_1: ::std::os::raw::c_int,
        integer_2: ::std::os::raw::c_int,
        integer_3: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " gets string that identifies CONOPT"]
    pub fn SCIPgetSolverNameConopt() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " gets string that describes CONOPT"]
    pub fn SCIPgetSolverDescConopt() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " returns whether CONOPT is available, i.e., whether it has been linked in"]
    pub fn SCIPisConoptAvailableConopt() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " create solver interface for the solver \"All\" and includes it into SCIP, if at least 2 NLPIs have already been included\n\n This method should be called after all other NLP solver interfaces have been included.\n\n @ingroup NLPIIncludes"]
    pub fn SCIPincludeNlpSolverAll(scip: *mut SCIP) -> SCIP_RETCODE;
}
unsafe extern "C" {
    #[doc = " includes default plugins into SCIP with respect to priorities"]
    pub fn SCIPincludeDefaultPlugins(scip: *mut SCIP) -> SCIP_RETCODE;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
